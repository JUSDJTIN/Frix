diff --git a/rtl/ao486/ao486.v b/rtl/ao486/ao486.v
index b25cbfb..4a5f897 100644
--- a/rtl/ao486/ao486.v
+++ b/rtl/ao486/ao486.v
@@ -24,11 +24,12 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-`include "defines.v"
+`include "defines.v"
+`include "./autogen/defines.v"
 
 module ao486 (
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //--------------------------------------------------------------------------
     input               interrupt_do,
@@ -87,7 +88,6 @@ wire        wr_debug_init;
 wire        wr_new_push_ss_fault;
 wire        wr_string_es_fault;
 wire        wr_push_ss_fault;
-
 wire        read_ac_fault;
 wire        read_page_fault;
 wire        write_ac_fault;
@@ -96,14 +96,12 @@ wire [15:0] tlb_code_pf_error_code;
 wire [15:0] tlb_check_pf_error_code;
 wire [15:0] tlb_write_pf_error_code;
 wire [15:0] tlb_read_pf_error_code;
-
 wire        wr_int;
 wire        wr_int_soft_int;
 wire        wr_int_soft_int_ib;
 wire [7:0]  wr_int_vector;
 wire        wr_exception_external_set;
 wire        wr_exception_finished;
-
 wire [31:0] eip;
 wire [31:0] dec_eip;
 wire [31:0] rd_eip;
@@ -112,28 +110,22 @@ wire [31:0] wr_eip;
 wire [3:0]  rd_consumed;
 wire [3:0]  exe_consumed;
 wire [3:0]  wr_consumed;
-
 wire        rd_dec_is_front;
 wire        rd_is_front;
 wire        exe_is_front;
 wire        wr_is_front;
-
 wire        wr_interrupt_possible;
 wire        wr_string_in_progress_final;
 wire        wr_is_esp_speculative;
-
 wire        real_mode;
-
 wire [15:0] rd_error_code;
 wire [15:0] exe_error_code;
 wire [15:0] wr_error_code;
-
 wire        exc_dec_reset;
 wire        exc_micro_reset;
 wire        exc_rd_reset;
 wire        exc_exe_reset;
 wire        exc_wr_reset;
-
 wire        exc_restore_esp;
 wire        exc_set_rflag;
 wire        exc_debug_start;
@@ -149,10 +141,99 @@ wire        exc_pf_read;
 wire        exc_pf_write;
 wire        exc_pf_code;
 wire        exc_pf_check;
+wire        io_read_do;
+wire [15:0] io_read_address;
+wire [2:0]  io_read_length;
+wire [31:0] io_read_data;
+wire        io_read_done;
+wire        io_write_do;
+wire [15:0] io_write_address;
+wire [2:0]  io_write_length;
+wire [31:0] io_write_data;
+wire        io_write_done;
+wire        glob_param_1_set;
+wire [31:0] glob_param_1_value;
+wire        glob_param_2_set;
+wire [31:0] glob_param_2_value;
+wire        glob_param_3_set;
+wire [31:0] glob_param_3_value;
+wire        glob_param_4_set;
+wire [31:0] glob_param_4_value;
+wire        glob_param_5_set;
+wire [31:0] glob_param_5_value;
+wire        glob_descriptor_set;
+wire [63:0] glob_descriptor_value;
+wire        glob_descriptor_2_set;
+wire [63:0] glob_descriptor_2_value;
+wire [31:0] glob_param_1;
+wire [31:0] glob_param_2;
+wire [31:0] glob_param_3;
+wire [31:0] glob_param_4;
+wire [31:0] glob_param_5;
+wire [63:0] glob_descriptor;
+wire [63:0] glob_descriptor_2;
+wire [31:0] glob_desc_base;
+wire [31:0] glob_desc_limit;
+wire [31:0] glob_desc_2_limit;
+wire        read_do;
+wire        read_done;
+wire [1:0]  read_cpl;
+wire [31:0] read_address;
+wire [3:0]  read_length;
+wire        read_lock;
+wire        read_rmw;
+wire [63:0] read_data;
+wire        write_do;
+wire        write_done;
+wire [1:0]  write_cpl;
+wire [31:0] write_address;
+wire [2:0]  write_length;
+wire        write_lock;
+wire        write_rmw;
+wire [31:0] write_data;
+wire        tlbcheck_do;
+wire        tlbcheck_done;
+wire        tlbcheck_page_fault;
+wire [31:0] tlbcheck_address;
+wire        tlbcheck_rw;
+wire        dcache_busy;
+wire        tlbflushsingle_do;
+wire        tlbflushsingle_done;
+wire [31:0] tlbflushsingle_address;
+wire        tlbflushall_do;
+wire        invdcode_do;
+wire        invdcode_done;
+wire        invddata_do;
+wire        invddata_done;
+wire        wbinvddata_do;
+wire        wbinvddata_done;
+wire [1:0]  prefetch_cpl;
+wire [31:0] prefetch_eip;
+wire [63:0] cs_cache;
+wire        cr0_pg;
+wire        cr0_wp;
+wire        cr0_am;
+wire        cr0_cd;
+wire        cr0_nw;
+wire        acflag;
+wire [31:0] cr3;
+wire        prefetchfifo_accept_do;
+wire [67:0] prefetchfifo_accept_data;
+wire        prefetchfifo_accept_empty;
+wire        pipeline_after_read_empty;
+wire        pipeline_after_prefetch_empty;
+wire [31:0] tlb_code_pf_cr2;
+wire [31:0] tlb_check_pf_cr2;
+wire [31:0] tlb_write_pf_cr2;
+wire [31:0] tlb_read_pf_cr2;
+wire        pr_reset;
+wire        rd_reset;
+wire        exe_reset;
+wire        wr_reset;
 
 exception exception_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     //exception indicators
     .dec_gp_fault                  (dec_gp_fault),                  //input
@@ -266,21 +347,11 @@ exception exception_inst(
 
 //------------------------------------------------------------------------------
 
-wire        io_read_do;
-wire [15:0] io_read_address;
-wire [2:0]  io_read_length;
-wire [31:0] io_read_data;
-wire        io_read_done;
 
-wire        io_write_do;
-wire [15:0] io_write_address;
-wire [2:0]  io_write_length;
-wire [31:0] io_write_data;
-wire        io_write_done;
 
 avalon_io avalon_io_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     //io_read
     .io_read_do                    (io_read_do),                    //input
@@ -313,34 +384,10 @@ avalon_io avalon_io_inst(
 
 //------------------------------------------------------------------------------
 
-wire        glob_param_1_set;
-wire [31:0] glob_param_1_value;
-wire        glob_param_2_set;
-wire [31:0] glob_param_2_value;
-wire        glob_param_3_set;
-wire [31:0] glob_param_3_value;
-wire        glob_param_4_set;
-wire [31:0] glob_param_4_value;
-wire        glob_param_5_set;
-wire [31:0] glob_param_5_value;
-wire        glob_descriptor_set;
-wire [63:0] glob_descriptor_value;
-wire        glob_descriptor_2_set;
-wire [63:0] glob_descriptor_2_value;
-wire [31:0] glob_param_1;
-wire [31:0] glob_param_2;
-wire [31:0] glob_param_3;
-wire [31:0] glob_param_4;
-wire [31:0] glob_param_5;
-wire [63:0] glob_descriptor;
-wire [63:0] glob_descriptor_2;
-wire [31:0] glob_desc_base;
-wire [31:0] glob_desc_limit;
-wire [31:0] glob_desc_2_limit;
 
 global_regs global_regs_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     //input
     .glob_param_1_set              (glob_param_1_set),              //input
@@ -373,81 +420,26 @@ global_regs global_regs_inst(
 
 //------------------------------------------------------------------------------
 
-wire        read_do;
-wire        read_done;
 
-wire [1:0]  read_cpl;
-wire [31:0] read_address;
-wire [3:0]  read_length;
-wire        read_lock;
-wire        read_rmw;
-wire [63:0] read_data;
 
-wire        write_do;
-wire        write_done;
 
-wire [1:0]  write_cpl;
-wire [31:0] write_address;
-wire [2:0]  write_length;
-wire        write_lock;
-wire        write_rmw;
-wire [31:0] write_data;
 
-wire        tlbcheck_do;
-wire        tlbcheck_done;
-wire        tlbcheck_page_fault;
-wire [31:0] tlbcheck_address;
-wire        tlbcheck_rw;
 
-wire        dcache_busy;
 
-wire        tlbflushsingle_do;
-wire        tlbflushsingle_done;
-wire [31:0] tlbflushsingle_address;
 
-wire        tlbflushall_do;
-wire        invdcode_do;
-wire        invdcode_done;
-wire        invddata_do;
-wire        invddata_done;
-wire        wbinvddata_do;
-wire        wbinvddata_done;
 
-wire [1:0]  prefetch_cpl;
-wire [31:0] prefetch_eip;
-wire [63:0] cs_cache;
 
-wire        cr0_pg;
-wire        cr0_wp;
-wire        cr0_am;
-wire        cr0_cd;
-wire        cr0_nw;
 
-wire        acflag;
 
-wire [31:0] cr3;
 
-wire        prefetchfifo_accept_do;
-wire [67:0] prefetchfifo_accept_data;
-wire        prefetchfifo_accept_empty;
 
-wire        pipeline_after_read_empty;
-wire        pipeline_after_prefetch_empty;
 
-wire [31:0] tlb_code_pf_cr2;
-wire [31:0] tlb_check_pf_cr2;
-wire [31:0] tlb_write_pf_cr2;
-wire [31:0] tlb_read_pf_cr2;
 
-wire        pr_reset;
-wire        rd_reset;
-wire        exe_reset;
-wire        wr_reset;
 
 
 memory memory_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     //REQ:
     .read_do                       (read_do),                       //input
@@ -561,7 +553,7 @@ memory memory_inst(
 
 pipeline pipeline_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     //to memory
     .pr_reset                      (pr_reset),                      //output
diff --git a/rtl/ao486/autogen/avalon_io.v b/rtl/ao486/autogen/avalon_io.v
index 2e2cdc6..ebb7345 100644
--- a/rtl/ao486/autogen/avalon_io.v
+++ b/rtl/ao486/autogen/avalon_io.v
@@ -1,30 +1,53 @@
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire was_readdatavalid_to_reg;
+wire [31:0] io_read_data_to_reg ;
+wire io_read_done_to_reg;
+wire [2:0] state_to_reg ;
+wire [31:0] avalon_io_writedata_to_reg ;
+wire [15:0] avalon_io_address_to_reg ;
+wire avalon_io_write_reg_to_reg;
+wire [3:0] avalon_io_byteenable_to_reg ;
+wire avalon_io_read_reg_to_reg;
+wire io_write_done_to_reg;
+
 //======================================================== conditions
-wire cond_0 = state == STATE_IDLE;
-wire cond_1 = io_write_do && io_write_done == `FALSE && dcache_busy == `FALSE;
-wire cond_2 = io_read_do && io_read_done == `FALSE && dcache_busy == `FALSE;
-wire cond_3 = state == STATE_WRITE_1;
-wire cond_4 = avalon_io_waitrequest == `FALSE || address_out_of_bounds;
-wire cond_5 = write_two_stage;
-wire cond_6 = state == STATE_WRITE_2;
-wire cond_7 = state == STATE_READ_1;
-wire cond_8 = avalon_io_readdatavalid || address_out_of_bounds;
-wire cond_9 = read_two_stage;
-wire cond_10 = avalon_io_waitrequest == `FALSE;
-wire cond_11 = state == STATE_READ_2;
+ assign cond_0 = state == STATE_IDLE;
+ assign cond_1 = io_write_do && io_write_done == `FALSE && dcache_busy == `FALSE;
+ assign cond_2 = io_read_do && io_read_done == `FALSE && dcache_busy == `FALSE;
+ assign cond_3 = state == STATE_WRITE_1;
+ assign cond_4 = avalon_io_waitrequest == `FALSE || address_out_of_bounds;
+ assign cond_5 = write_two_stage;
+ assign cond_6 = state == STATE_WRITE_2;
+ assign cond_7 = state == STATE_READ_1;
+ assign cond_8 = avalon_io_readdatavalid || address_out_of_bounds;
+ assign cond_9 = read_two_stage;
+ assign cond_10 = avalon_io_waitrequest == `FALSE;
+ assign cond_11 = state == STATE_READ_2;
 //======================================================== saves
-wire  was_readdatavalid_to_reg =
+ assign was_readdatavalid_to_reg =
     (cond_0 && ~cond_1 && cond_2)? ( `FALSE) :
     was_readdatavalid;
-wire [31:0] io_read_data_to_reg =
+ assign io_read_data_to_reg =
     (cond_7 && cond_8)? ( read_data_1) :
     (cond_11 && cond_8)? ( read_data_2) :
     io_read_data;
-wire  io_read_done_to_reg =
+ assign io_read_done_to_reg =
     (cond_0)? (  `FALSE) :
     (cond_7 && cond_8 && ~cond_9)? ( `TRUE) :
     (cond_11 && cond_8)? ( `TRUE) :
     io_read_done;
-wire [2:0] state_to_reg =
+ assign state_to_reg =
     (cond_0 && cond_1)? ( STATE_WRITE_1) :
     (cond_0 && ~cond_1 && cond_2)? ( STATE_READ_1) :
     (cond_3 && cond_4 && cond_5)? ( STATE_WRITE_2) :
@@ -34,29 +57,29 @@ wire [2:0] state_to_reg =
     (cond_7 && cond_8 && ~cond_9)? ( STATE_IDLE) :
     (cond_11 && cond_8)? ( STATE_IDLE) :
     state;
-wire [31:0] avalon_io_writedata_to_reg =
+ assign avalon_io_writedata_to_reg =
     (cond_0 && cond_1)? (  write_1_data) :
     (cond_3 && cond_4 && cond_5)? (   write_2_data) :
     avalon_io_writedata;
-wire [15:0] avalon_io_address_to_reg =
+ assign avalon_io_address_to_reg =
     (cond_0 && cond_1)? (    { io_write_address[15:2], 2'b0 }) :
     (cond_0 && ~cond_1 && cond_2)? (     { io_read_address[15:2], 2'b0 }) :
     (cond_3 && cond_4 && cond_5)? (     { write_address_next[15:2], 2'b0 }) :
     (cond_7 && cond_8 && cond_9)? (     { read_address_next[15:2], 2'b0 }) :
     avalon_io_address;
-wire  avalon_io_write_reg_to_reg =
+ assign avalon_io_write_reg_to_reg =
     (cond_0 && cond_1)? (  `TRUE) :
     (cond_3 && cond_4 && cond_5)? (   `TRUE) :
     (cond_3 && cond_4 && ~cond_5)? ( `FALSE) :
     (cond_6 && cond_4)? ( `FALSE) :
     avalon_io_write_reg;
-wire [3:0] avalon_io_byteenable_to_reg =
+ assign avalon_io_byteenable_to_reg =
     (cond_0 && cond_1)? ( write_1_byteenable) :
     (cond_0 && ~cond_1 && cond_2)? (  read_1_byteenable) :
     (cond_3 && cond_4 && cond_5)? (  write_2_byteenable) :
     (cond_7 && cond_8 && cond_9)? (  read_2_byteenable) :
     avalon_io_byteenable;
-wire  avalon_io_read_reg_to_reg =
+ assign avalon_io_read_reg_to_reg =
     (cond_0 && ~cond_1 && cond_2)? (    `TRUE) :
     (cond_7 && cond_8 && cond_9)? ( `TRUE) :
     (cond_7 && cond_8 && ~cond_9)? ( `FALSE) :
@@ -64,50 +87,50 @@ wire  avalon_io_read_reg_to_reg =
     (cond_11 && cond_8)? ( `FALSE) :
     (cond_11 && cond_10)? ( `FALSE) :
     avalon_io_read_reg;
-wire  io_write_done_to_reg =
+ assign io_write_done_to_reg =
     (cond_0)? ( `FALSE) :
     (cond_3 && cond_4 && ~cond_5)? ( `TRUE) :
     (cond_6 && cond_4)? ( `TRUE) :
     io_write_done;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) was_readdatavalid <= 1'd0;
+always @(posedge clk) begin
+    if(rst) was_readdatavalid <= 1'd0;
     else              was_readdatavalid <= was_readdatavalid_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) io_read_data <= 32'd0;
+always @(posedge clk) begin
+    if(rst) io_read_data <= 32'd0;
     else              io_read_data <= io_read_data_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) io_read_done <= 1'd0;
+always @(posedge clk) begin
+    if(rst) io_read_done <= 1'd0;
     else              io_read_done <= io_read_done_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) state <= 3'd0;
+always @(posedge clk) begin
+    if(rst) state <= 3'd0;
     else              state <= state_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) avalon_io_writedata <= 32'd0;
+always @(posedge clk) begin
+    if(rst) avalon_io_writedata <= 32'd0;
     else              avalon_io_writedata <= avalon_io_writedata_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) avalon_io_address <= 16'd0;
+always @(posedge clk) begin
+    if(rst) avalon_io_address <= 16'd0;
     else              avalon_io_address <= avalon_io_address_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) avalon_io_write_reg <= 1'd0;
+always @(posedge clk) begin
+    if(rst) avalon_io_write_reg <= 1'd0;
     else              avalon_io_write_reg <= avalon_io_write_reg_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) avalon_io_byteenable <= 4'd0;
+always @(posedge clk) begin
+    if(rst) avalon_io_byteenable <= 4'd0;
     else              avalon_io_byteenable <= avalon_io_byteenable_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) avalon_io_read_reg <= 1'd0;
+always @(posedge clk) begin
+    if(rst) avalon_io_read_reg <= 1'd0;
     else              avalon_io_read_reg <= avalon_io_read_reg_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) io_write_done <= 1'd0;
+always @(posedge clk) begin
+    if(rst) io_write_done <= 1'd0;
     else              io_write_done <= io_write_done_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/avalon_mem.v b/rtl/ao486/autogen/avalon_mem.v
index 5397a29..3ff3f21 100644
--- a/rtl/ao486/autogen/avalon_mem.v
+++ b/rtl/ao486/autogen/avalon_mem.v
@@ -1,32 +1,76 @@
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire cond_12;
+wire cond_13;
+wire cond_14;
+wire cond_15;
+wire cond_16;
+wire cond_17;
+wire cond_18;
+wire cond_19;
+wire cond_20;
+wire cond_21;
+wire cond_22;
+wire cond_23;
+wire cond_24;
+wire cond_25;
+wire avm_read_to_reg;
+wire read_line_done_trigger_to_reg;
+wire [1:0] counter_to_reg ;
+wire [1:0] state_to_reg ;
+wire [31:0] bus_3_to_reg ;
+wire [31:0] avm_writedata_to_reg ;
+wire [31:0] bus_0_to_reg ;
+wire [31:0] bus_2_to_reg ;
+wire [3:0] byteenable_next_to_reg ;
+wire [31:0] bus_1_to_reg ;
+wire [31:0] avm_address_to_reg ;
+wire avm_write_to_reg;
+wire [31:0] bus_code_partial_to_reg ;
+wire read_burst_done_trigger_to_reg;
+wire [3:0] avm_byteenable_to_reg ;
+wire [2:0] avm_burstcount_to_reg ;
+wire read_code_done_trigger_to_reg;
+
 //======================================================== conditions
-wire cond_0 = state == STATE_IDLE;
-wire cond_1 = read_burst_done_trigger;
-wire cond_2 = read_line_done_trigger;
-wire cond_3 = read_code_done_trigger;
-wire cond_4 = writeburst_do;
-wire cond_5 = writeline_do;
-wire cond_6 = readburst_do && ~(readburst_done);
-wire cond_7 = readline_do && ~(readline_done);
-wire cond_8 = readcode_do && ~(readcode_done);
-wire cond_9 = state == STATE_WRITE;
-wire cond_10 = ~(avm_waitrequest) && counter == 2'd0;
-wire cond_11 = ~(avm_waitrequest) && counter != 2'd0;
-wire cond_12 = state == STATE_READ;
-wire cond_13 = avm_readdatavalid;
-wire cond_14 = avm_burstcount - { 1'b0, counter } == 3'd1;
-wire cond_15 = avm_burstcount - { 1'b0, counter } == 3'd2;
-wire cond_16 = avm_burstcount - { 1'b0, counter } == 3'd3;
-wire cond_17 = avm_burstcount - { 1'b0, counter } == 3'd4;
-wire cond_18 = counter == 2'd0;
-wire cond_19 = avm_burstcount == 3'd4;
-wire cond_20 = avm_waitrequest == `FALSE;
-wire cond_21 = state == STATE_READ_CODE;
-wire cond_22 = counter == 2'd3;
-wire cond_23 = counter == 2'd2;
-wire cond_24 = counter == 2'd1;
-wire cond_25 = counter < 2'd3;
+ assign cond_0 = state == STATE_IDLE;
+ assign cond_1 = read_burst_done_trigger;
+ assign cond_2 = read_line_done_trigger;
+ assign cond_3 = read_code_done_trigger;
+ assign cond_4 = writeburst_do;
+ assign cond_5 = writeline_do;
+ assign cond_6 = readburst_do && ~(readburst_done);
+ assign cond_7 = readline_do && ~(readline_done);
+ assign cond_8 = readcode_do && ~(readcode_done);
+ assign cond_9 = state == STATE_WRITE;
+ assign cond_10 = ~(avm_waitrequest) && counter == 2'd0;
+ assign cond_11 = ~(avm_waitrequest) && counter != 2'd0;
+ assign cond_12 = state == STATE_READ;
+ assign cond_13 = avm_readdatavalid;
+ assign cond_14 = avm_burstcount - { 1'b0, counter } == 3'd1;
+ assign cond_15 = avm_burstcount - { 1'b0, counter } == 3'd2;
+ assign cond_16 = avm_burstcount - { 1'b0, counter } == 3'd3;
+ assign cond_17 = avm_burstcount - { 1'b0, counter } == 3'd4;
+ assign cond_18 = counter == 2'd0;
+ assign cond_19 = avm_burstcount == 3'd4;
+ assign cond_20 = avm_waitrequest == `FALSE;
+ assign cond_21 = state == STATE_READ_CODE;
+ assign cond_22 = counter == 2'd3;
+ assign cond_23 = counter == 2'd2;
+ assign cond_24 = counter == 2'd1;
+ assign cond_25 = counter < 2'd3;
 //======================================================== saves
-wire  avm_read_to_reg =
+ assign avm_read_to_reg =
     (cond_0 && ~cond_4 && ~cond_5 && cond_6)? (      `TRUE) :
     (cond_0 && ~cond_4 && ~cond_5 && ~cond_6 && cond_7)? (      `TRUE) :
     (cond_0 && ~cond_4 && ~cond_5 && ~cond_6 && ~cond_7 && cond_8)? (      `TRUE) :
@@ -35,11 +79,11 @@ wire  avm_read_to_reg =
     (cond_21 && cond_13 && cond_18)? ( `FALSE) :
     (cond_21 && cond_20)? ( `FALSE) :
     avm_read;
-wire  read_line_done_trigger_to_reg =
+ assign read_line_done_trigger_to_reg =
     (cond_0 && cond_2)? ( `FALSE) :
     (cond_12 && cond_13 && cond_18 && cond_19)? ( `TRUE) :
     read_line_done_trigger;
-wire [1:0] counter_to_reg =
+ assign counter_to_reg =
     (cond_0 && cond_4)? (    writeburst_dword_length - 2'd1) :
     (cond_0 && ~cond_4 && cond_5)? (    2'd3) :
     (cond_0 && ~cond_4 && ~cond_5 && cond_6)? (    readburst_dword_length - 2'd1) :
@@ -49,7 +93,7 @@ wire [1:0] counter_to_reg =
     (cond_12 && cond_13)? ( counter - 2'd1) :
     (cond_21 && cond_13)? ( counter - 2'd1) :
     counter;
-wire [1:0] state_to_reg =
+ assign state_to_reg =
     (cond_0 && cond_4)? (      STATE_WRITE) :
     (cond_0 && ~cond_4 && cond_5)? (      STATE_WRITE) :
     (cond_0 && ~cond_4 && ~cond_5 && cond_6)? (      STATE_READ) :
@@ -59,57 +103,57 @@ wire [1:0] state_to_reg =
     (cond_12 && cond_13 && cond_18)? ( STATE_IDLE) :
     (cond_21 && cond_13 && cond_18)? ( STATE_IDLE) :
     state;
-wire [31:0] bus_3_to_reg =
+ assign bus_3_to_reg =
     (cond_12 && cond_13 && cond_17)? ( avm_readdata) :
     (cond_21 && cond_13 && cond_18)? ( avm_readdata) :
     bus_3;
-wire [31:0] avm_writedata_to_reg =
+ assign avm_writedata_to_reg =
     (cond_0 && cond_4)? (         writeburst_data[31:0]) :
     (cond_0 && ~cond_4 && cond_5)? ( writeline_line[31:0]) :
     (cond_9 && cond_11)? ( bus_0) :
     avm_writedata;
-wire [31:0] bus_0_to_reg =
+ assign bus_0_to_reg =
     (cond_0 && cond_4)? (         { 8'd0, writeburst_data[55:32] }) :
     (cond_0 && ~cond_4 && cond_5)? (         writeline_line[63:32]) :
     (cond_9 && cond_11)? (         bus_1) :
     (cond_12 && cond_13 && cond_14)? ( avm_readdata) :
     (cond_21 && cond_13 && cond_22)? ( avm_readdata) :
     bus_0;
-wire [31:0] bus_2_to_reg =
+ assign bus_2_to_reg =
     (cond_0 && ~cond_4 && cond_5)? (         writeline_line[127:96]) :
     (cond_12 && cond_13 && cond_16)? ( avm_readdata) :
     (cond_21 && cond_13 && cond_24)? ( avm_readdata) :
     bus_2;
-wire [3:0] byteenable_next_to_reg =
+ assign byteenable_next_to_reg =
     (cond_0 && cond_4)? (    writeburst_byteenable_1) :
     (cond_0 && ~cond_4 && cond_5)? (    4'hF) :
     byteenable_next;
-wire [31:0] bus_1_to_reg =
+ assign bus_1_to_reg =
     (cond_0 && ~cond_4 && cond_5)? (         writeline_line[95:64]) :
     (cond_9 && cond_11)? (         bus_2) :
     (cond_12 && cond_13 && cond_15)? ( avm_readdata) :
     (cond_21 && cond_13 && cond_23)? ( avm_readdata) :
     bus_1;
-wire [31:0] avm_address_to_reg =
+ assign avm_address_to_reg =
     (cond_0 && cond_4)? (        { writeburst_address[31:2], 2'd0 }) :
     (cond_0 && ~cond_4 && cond_5)? (        { writeline_address[31:4], 4'd0 }) :
     (cond_0 && ~cond_4 && ~cond_5 && cond_6)? (    { readburst_address[31:2], 2'd0 }) :
     (cond_0 && ~cond_4 && ~cond_5 && ~cond_6 && cond_7)? (    { readline_address[31:4], 4'd0 }) :
     (cond_0 && ~cond_4 && ~cond_5 && ~cond_6 && ~cond_7 && cond_8)? (    { readcode_address[31:2], 2'd0 }) :
     avm_address;
-wire  avm_write_to_reg =
+ assign avm_write_to_reg =
     (cond_0 && cond_4)? (          `TRUE) :
     (cond_0 && ~cond_4 && cond_5)? (          `TRUE) :
     (cond_9 && cond_10)? (  `FALSE) :
     avm_write;
-wire [31:0] bus_code_partial_to_reg =
+ assign bus_code_partial_to_reg =
     (cond_21 && cond_13)? ( avm_readdata) :
     bus_code_partial;
-wire  read_burst_done_trigger_to_reg =
+ assign read_burst_done_trigger_to_reg =
     (cond_0 && cond_1)? ( `FALSE) :
     (cond_12 && cond_13 && cond_18 && ~cond_19)? (`TRUE) :
     read_burst_done_trigger;
-wire [3:0] avm_byteenable_to_reg =
+ assign avm_byteenable_to_reg =
     (cond_0 && cond_4)? (     writeburst_byteenable_0) :
     (cond_0 && ~cond_4 && cond_5)? (     4'hF) :
     (cond_0 && ~cond_4 && ~cond_5 && cond_6)? ( read_burst_byteenable) :
@@ -117,84 +161,84 @@ wire [3:0] avm_byteenable_to_reg =
     (cond_0 && ~cond_4 && ~cond_5 && ~cond_6 && ~cond_7 && cond_8)? ( 4'hF) :
     (cond_9 && cond_11)? ( byteenable_next) :
     avm_byteenable;
-wire [2:0] avm_burstcount_to_reg =
+ assign avm_burstcount_to_reg =
     (cond_0 && cond_4)? (     { 1'b0, writeburst_dword_length }) :
     (cond_0 && ~cond_4 && cond_5)? (     3'd4) :
     (cond_0 && ~cond_4 && ~cond_5 && cond_6)? ( { 1'b0, readburst_dword_length }) :
     (cond_0 && ~cond_4 && ~cond_5 && ~cond_6 && cond_7)? ( 3'd4) :
     (cond_0 && ~cond_4 && ~cond_5 && ~cond_6 && ~cond_7 && cond_8)? ( 3'd4) :
     avm_burstcount;
-wire  read_code_done_trigger_to_reg =
+ assign read_code_done_trigger_to_reg =
     (cond_0 && cond_3)? ( `FALSE) :
     (cond_21 && cond_13 && cond_18)? ( `TRUE) :
     read_code_done_trigger;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) avm_read <= 1'd0;
+always @(posedge clk) begin
+    if(rst) avm_read <= 1'd0;
     else              avm_read <= avm_read_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) read_line_done_trigger <= 1'd0;
+always @(posedge clk) begin
+    if(rst) read_line_done_trigger <= 1'd0;
     else              read_line_done_trigger <= read_line_done_trigger_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) counter <= 2'd0;
+always @(posedge clk) begin
+    if(rst) counter <= 2'd0;
     else              counter <= counter_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) state <= 2'd0;
+always @(posedge clk) begin
+    if(rst) state <= 2'd0;
     else              state <= state_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) bus_3 <= 32'd0;
+always @(posedge clk) begin
+    if(rst) bus_3 <= 32'd0;
     else              bus_3 <= bus_3_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) avm_writedata <= 32'd0;
+always @(posedge clk) begin
+    if(rst) avm_writedata <= 32'd0;
     else              avm_writedata <= avm_writedata_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) bus_0 <= 32'd0;
+always @(posedge clk) begin
+    if(rst) bus_0 <= 32'd0;
     else              bus_0 <= bus_0_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) bus_2 <= 32'd0;
+always @(posedge clk) begin
+    if(rst) bus_2 <= 32'd0;
     else              bus_2 <= bus_2_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) byteenable_next <= 4'd0;
+always @(posedge clk) begin
+    if(rst) byteenable_next <= 4'd0;
     else              byteenable_next <= byteenable_next_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) bus_1 <= 32'd0;
+always @(posedge clk) begin
+    if(rst) bus_1 <= 32'd0;
     else              bus_1 <= bus_1_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) avm_address <= 32'd0;
+always @(posedge clk) begin
+    if(rst) avm_address <= 32'd0;
     else              avm_address <= avm_address_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) avm_write <= 1'd0;
+always @(posedge clk) begin
+    if(rst) avm_write <= 1'd0;
     else              avm_write <= avm_write_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) bus_code_partial <= 32'd0;
+always @(posedge clk) begin
+    if(rst) bus_code_partial <= 32'd0;
     else              bus_code_partial <= bus_code_partial_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) read_burst_done_trigger <= 1'd0;
+always @(posedge clk) begin
+    if(rst) read_burst_done_trigger <= 1'd0;
     else              read_burst_done_trigger <= read_burst_done_trigger_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) avm_byteenable <= 4'd0;
+always @(posedge clk) begin
+    if(rst) avm_byteenable <= 4'd0;
     else              avm_byteenable <= avm_byteenable_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) avm_burstcount <= 3'd0;
+always @(posedge clk) begin
+    if(rst) avm_burstcount <= 3'd0;
     else              avm_burstcount <= avm_burstcount_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) read_code_done_trigger <= 1'd0;
+always @(posedge clk) begin
+    if(rst) read_code_done_trigger <= 1'd0;
     else              read_code_done_trigger <= read_code_done_trigger_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/dcache.v b/rtl/ao486/autogen/dcache.v
index c9a938e..56b6587 100644
--- a/rtl/ao486/autogen/dcache.v
+++ b/rtl/ao486/autogen/dcache.v
@@ -1,42 +1,78 @@
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire cond_12;
+wire cond_13;
+wire cond_14;
+wire cond_15;
+wire cond_16;
+wire cond_17;
+wire cond_18;
+wire cond_19;
+wire cond_20;
+wire cond_21;
+wire cond_22;
+wire cond_23;
+wire cond_24;
+wire cond_25;
+wire cond_26;
+wire cond_27;
+wire is_write_to_reg;
+wire [31:0] address_to_reg ;
+wire [2:0] state_to_reg ;
+wire [3:0] length_to_reg ;
+wire write_through_to_reg;
+wire [31:0] write_data_to_reg ;
+wire cache_disable_to_reg;
+
 //======================================================== conditions
-wire cond_0 = state == STATE_IDLE;
-wire cond_1 = invddata_do;
-wire cond_2 = wbinvddata_do;
-wire cond_3 = dcachewrite_do;
-wire cond_4 = dcacheread_do;
-wire cond_5 = state == STATE_READ_CHECK;
-wire cond_6 = matched;
-wire cond_7 = cache_disable;
-wire cond_8 = writeback_needed;
-wire cond_9 = state == STATE_WRITE_CHECK;
-wire cond_10 = matched_index == 2'd0;
-wire cond_11 = matched_index == 2'd1;
-wire cond_12 = matched_index == 2'd2;
-wire cond_13 = matched_index == 2'd3;
-wire cond_14 = write_through;
-wire cond_15 = state == STATE_READ_BURST;
-wire cond_16 = readburst_done;
-wire cond_17 = state == STATE_WRITE_BACK;
-wire cond_18 = writeline_done;
-wire cond_19 = state == STATE_READ_LINE;
-wire cond_20 = readline_done;
-wire cond_21 = is_write;
-wire cond_22 = plru_index == 2'd0;
-wire cond_23 = plru_index == 2'd1;
-wire cond_24 = plru_index == 2'd2;
-wire cond_25 = plru_index == 2'd3;
-wire cond_26 = state == STATE_WRITE_THROUGH;
-wire cond_27 = writeburst_done;
+ assign cond_0 = state == STATE_IDLE;
+ assign cond_1 = invddata_do;
+ assign cond_2 = wbinvddata_do;
+ assign cond_3 = dcachewrite_do;
+ assign cond_4 = dcacheread_do;
+ assign cond_5 = state == STATE_READ_CHECK;
+ assign cond_6 = matched;
+ assign cond_7 = cache_disable;
+ assign cond_8 = writeback_needed;
+ assign cond_9 = state == STATE_WRITE_CHECK;
+ assign cond_10 = matched_index == 2'd0;
+ assign cond_11 = matched_index == 2'd1;
+ assign cond_12 = matched_index == 2'd2;
+ assign cond_13 = matched_index == 2'd3;
+ assign cond_14 = write_through;
+ assign cond_15 = state == STATE_READ_BURST;
+ assign cond_16 = readburst_done;
+ assign cond_17 = state == STATE_WRITE_BACK;
+ assign cond_18 = writeline_done;
+ assign cond_19 = state == STATE_READ_LINE;
+ assign cond_20 = readline_done;
+ assign cond_21 = is_write;
+ assign cond_22 = plru_index == 2'd0;
+ assign cond_23 = plru_index == 2'd1;
+ assign cond_24 = plru_index == 2'd2;
+ assign cond_25 = plru_index == 2'd3;
+ assign cond_26 = state == STATE_WRITE_THROUGH;
+ assign cond_27 = writeburst_done;
 //======================================================== saves
-wire  is_write_to_reg =
+ assign is_write_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && cond_3)? ( `TRUE) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && cond_4)? ( `FALSE) :
     is_write;
-wire [31:0] address_to_reg =
+ assign address_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && cond_3)? (        dcachewrite_address) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && cond_4)? (        dcacheread_address) :
     address;
-wire [2:0] state_to_reg =
+ assign state_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && cond_3)? ( STATE_WRITE_CHECK) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && cond_4)? ( STATE_READ_CHECK) :
     (cond_5 && cond_6)? ( STATE_IDLE) :
@@ -55,47 +91,47 @@ wire [2:0] state_to_reg =
     (cond_19 && cond_20 && ~cond_21)? ( STATE_IDLE) :
     (cond_26 && cond_27)? ( STATE_IDLE) :
     state;
-wire [3:0] length_to_reg =
+ assign length_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && cond_3)? (         { 1'b0, dcachewrite_length }) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && cond_4)? (         dcacheread_length) :
     length;
-wire  write_through_to_reg =
+ assign write_through_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && cond_3)? (  dcachewrite_write_through) :
     write_through;
-wire [31:0] write_data_to_reg =
+ assign write_data_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && cond_3)? (     dcachewrite_data) :
     write_data;
-wire  cache_disable_to_reg =
+ assign cache_disable_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && cond_3)? (  dcachewrite_cache_disable) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && cond_4)? (  dcacheread_cache_disable) :
     cache_disable;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) is_write <= 1'd0;
+always @(posedge clk) begin
+    if(rst) is_write <= 1'd0;
     else              is_write <= is_write_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) address <= 32'd0;
+always @(posedge clk) begin
+    if(rst) address <= 32'd0;
     else              address <= address_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) state <= 3'd0;
+always @(posedge clk) begin
+    if(rst) state <= 3'd0;
     else              state <= state_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) length <= 4'd0;
+always @(posedge clk) begin
+    if(rst) length <= 4'd0;
     else              length <= length_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) write_through <= 1'd0;
+always @(posedge clk) begin
+    if(rst) write_through <= 1'd0;
     else              write_through <= write_through_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) write_data <= 32'd0;
+always @(posedge clk) begin
+    if(rst) write_data <= 32'd0;
     else              write_data <= write_data_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) cache_disable <= 1'd0;
+always @(posedge clk) begin
+    if(rst) cache_disable <= 1'd0;
     else              cache_disable <= cache_disable_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/dcache_control_ram.v b/rtl/ao486/autogen/dcache_control_ram.v
index ccf8bc4..18fb287 100644
--- a/rtl/ao486/autogen/dcache_control_ram.v
+++ b/rtl/ao486/autogen/dcache_control_ram.v
@@ -1,59 +1,75 @@
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire [9:0] wbinvd_counter_to_reg ;
+wire after_invalidate_to_reg;
+wire [7:0] invd_counter_to_reg ;
+wire [1:0] state_to_reg ;
+wire init_done_to_reg;
+
 //======================================================== conditions
-wire cond_0 = init_done == `FALSE;
-wire cond_1 = invd_counter == 8'd255;
-wire cond_2 = state == STATE_IDLE;
-wire cond_3 = init_done && invddata_do;
-wire cond_4 = init_done && wbinvddata_do;
-wire cond_5 = state == STATE_INVD;
-wire cond_6 = state == STATE_WBINVD;
-wire cond_7 = wbinvd_valid;
-wire cond_8 = writeline_done;
-wire cond_9 = wbinvd_counter == 10'd1023;
+ assign cond_0 = init_done == `FALSE;
+ assign cond_1 = invd_counter == 8'd255;
+ assign cond_2 = state == STATE_IDLE;
+ assign cond_3 = init_done && invddata_do;
+ assign cond_4 = init_done && wbinvddata_do;
+ assign cond_5 = state == STATE_INVD;
+ assign cond_6 = state == STATE_WBINVD;
+ assign cond_7 = wbinvd_valid;
+ assign cond_8 = writeline_done;
+ assign cond_9 = wbinvd_counter == 10'd1023;
 //======================================================== saves
-wire [9:0] wbinvd_counter_to_reg =
+ assign wbinvd_counter_to_reg =
     (cond_6 && cond_7 && cond_8)? (      wbinvd_counter_next) :
     (cond_6 && ~cond_7)? ( wbinvd_counter_next) :
     wbinvd_counter;
-wire  after_invalidate_to_reg =
+ assign after_invalidate_to_reg =
     (cond_0 && cond_1)? ( `TRUE) :
     (cond_2)? ( `FALSE) :
     (cond_5 && cond_1)? ( `TRUE) :
     (cond_6 && cond_7 && cond_8 && cond_9)? ( `TRUE) :
     (cond_6 && ~cond_7 && cond_9)? ( `TRUE) :
     after_invalidate;
-wire [7:0] invd_counter_to_reg =
+ assign invd_counter_to_reg =
     (cond_0)? ( invd_counter + 8'd1) :
     (cond_5)? ( invd_counter + 8'd1) :
     invd_counter;
-wire [1:0] state_to_reg =
+ assign state_to_reg =
     (cond_2 && cond_3)? ( STATE_INVD) :
     (cond_2 && ~cond_3 && cond_4)? ( STATE_WBINVD) :
     (cond_5 && cond_1)? ( STATE_IDLE) :
     (cond_6 && cond_7 && cond_8 && cond_9)? ( STATE_IDLE) :
     (cond_6 && ~cond_7 && cond_9)? ( STATE_IDLE) :
     state;
-wire  init_done_to_reg =
+ assign init_done_to_reg =
     (cond_0 && cond_1)? (        `TRUE) :
     init_done;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) wbinvd_counter <= 10'd0;
+always @(posedge clk) begin
+    if(rst) wbinvd_counter <= 10'd0;
     else              wbinvd_counter <= wbinvd_counter_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) after_invalidate <= 1'd0;
+always @(posedge clk) begin
+    if(rst) after_invalidate <= 1'd0;
     else              after_invalidate <= after_invalidate_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) invd_counter <= 8'd0;
+always @(posedge clk) begin
+    if(rst) invd_counter <= 8'd0;
     else              invd_counter <= invd_counter_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) state <= 2'd0;
+always @(posedge clk) begin
+    if(rst) state <= 2'd0;
     else              state <= state_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) init_done <= 1'd0;
+always @(posedge clk) begin
+    if(rst) init_done <= 1'd0;
     else              init_done <= init_done_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/decode_commands.v b/rtl/ao486/autogen/decode_commands.v
index f77d94b..46e8723 100644
--- a/rtl/ao486/autogen/decode_commands.v
+++ b/rtl/ao486/autogen/decode_commands.v
@@ -1,737 +1,884 @@
-//======================================================== conditions
-wire cond_0 = dec_ready_2byte_modregrm && { decoder[7:1], 1'b0 } == 8'hC0;
-wire cond_1 = prefix_group_1_lock  && `DEC_MODREGRM_IS_MOD_11;
-wire cond_2 = decoder[0] == 1'b0;
-wire cond_3 = dec_ready_one_one && decoder[7:0] == 8'hE3;
-wire cond_4 = prefix_group_1_lock ;
-wire cond_5 = dec_ready_call_jmp_imm && (decoder[7:0] == 8'h9A || decoder[7:0] == 8'hE8);
-wire cond_6 = decoder[1] == 1'b0;
-wire cond_7 = dec_ready_modregrm_one && decoder[7:0] == 8'hFF && (decoder[13:11] == 3'd2 || decoder[13:11] == 3'd3);
-wire cond_8 = prefix_group_1_lock  || (decoder[13:11] == 3'd3 && `DEC_MODREGRM_IS_MOD_11);
-wire cond_9 = decoder[11] == 1'b0;
-wire cond_10 = (dec_ready_one && (decoder[7:0] == 8'h06 || decoder[7:0] == 8'h16 || decoder[7:0] == 8'h0E || decoder[7:0] == 8'h1E)) || (dec_ready_2byte_one && (decoder[7:0] == 8'hA0 || decoder[7:0] == 8'hA8));
-wire cond_11 = dec_ready_modregrm_one && decoder[7:0] == 8'h8C;
-wire cond_12 = prefix_group_1_lock  || decoder[13:11] >= 3'd6;
-wire cond_13 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd0;
-wire cond_14 = prefix_group_1_lock  || ~(protected_mode);
-wire cond_15 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd1;
-wire cond_16 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd3;
-wire cond_17 = (dec_ready_one_one && decoder[7:4] == 4'h7) || (dec_ready_2byte_imm && decoder[7:4] == 4'h8);
-wire cond_18 = ~(dec_prefix_2byte);
-wire cond_19 = dec_prefix_2byte;
-wire cond_20 = dec_ready_2byte_one && decoder[7:0] == 8'h08;
-wire cond_21 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd7;
-wire cond_22 = prefix_group_1_lock  || `DEC_MODREGRM_IS_MOD_11;
-wire cond_23 = dec_ready_one && decoder[7:0] == 8'hF4;
-wire cond_24 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'hAE;
-wire cond_25 = dec_prefix_group_1_rep != 2'd0;
-wire cond_26 = dec_ready_one && decoder[7:4] == 4'h4;
-wire cond_27 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hFE && { decoder[13:12], 1'b0 } == 3'b000;
-wire cond_28 = (dec_ready_one && decoder[7:0] == 8'hC3) || (dec_ready_one_two && decoder[7:0] == 8'hC2);
-wire cond_29 = dec_ready_modregrm_one && decoder[7:0] == 8'h63;
-wire cond_30 = dec_ready_2byte_one && { decoder[7:3], 3'b000 } == 8'hC8;
-wire cond_31 = (dec_ready_modregrm_one && (decoder[7:0] == 8'hC4 || decoder[7:0] == 8'hC5)) || (dec_ready_2byte_modregrm && (decoder[7:0] == 8'hB2 || decoder[7:0] == 8'hB4 || decoder[7:0] == 8'hB5));
-wire cond_32 = dec_ready_modregrm_one && decoder[7:0] == 8'h8E;
-wire cond_33 = prefix_group_1_lock  || decoder[13:11] >= 3'd6 || decoder[13:11] == 3'd1;
-wire cond_34 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd2;
-wire cond_35 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd3;
-wire cond_36 = dec_ready_one && decoder[7:0] == 8'hF8;
-wire cond_37 = dec_ready_one && decoder[7:0] == 8'hFC;
-wire cond_38 = dec_ready_one && decoder[7:0] == 8'hF5;
-wire cond_39 = dec_ready_one && decoder[7:0] == 8'hF9;
-wire cond_40 = dec_ready_one && decoder[7:0] == 8'hFD;
-wire cond_41 = dec_ready_one && decoder[7:0] == 8'h9E;
-wire cond_42 = dec_ready_one_one && decoder[7:0] == 8'hD5;
-wire cond_43 = dec_ready_one_one && decoder[7:0] == 8'hD4;
-wire cond_44 = (dec_ready_one && (decoder[7:0] == 8'h07 || decoder[7:0] == 8'h17 || decoder[7:0] == 8'h1F)) || (dec_ready_2byte_one && (decoder[7:0] == 8'hA1 || decoder[7:0] == 8'hA9));
-wire cond_45 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hA3) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hBA && decoder[13:11] == 3'd4);
-wire cond_46 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hB3) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hBA && decoder[13:11] == 3'd6);
-wire cond_47 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hAB) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hBA && decoder[13:11] == 3'd5);
-wire cond_48 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hBB) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hBA && decoder[13:11] == 3'd7);
-wire cond_49 = dec_ready_one && decoder[7:0] == 8'hCF;
-wire cond_50 = ~(protected_mode);
-wire cond_51 = dec_ready_one && { decoder[7:3], 3'b0 } == 8'h58;
-wire cond_52 = dec_ready_modregrm_one && decoder[7:0] == 8'h8F && decoder[13:11] == 3'd0;
-wire cond_53 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd6;
-wire cond_54 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd7;
-wire cond_55 = dec_ready_modregrm_one && { decoder[7:2], 2'b0 } == 8'hD0;
-wire cond_56 = decoder[1];
-wire cond_57 = dec_ready_modregrm_imm && { decoder[7:1], 1'b0 } == 8'hC0;
-wire cond_58 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'hA6;
-wire cond_59 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd4;
-wire cond_60 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd6;
-wire cond_61 = dec_ready_2byte_modregrm && { decoder[7:2], 1'b0, decoder[0] } == 8'h20;
-wire cond_62 = prefix_group_1_lock  || (decoder[13:11] != 3'd0 && decoder[13:11] != 3'd2 && decoder[13:11] != 3'd3);
-wire cond_63 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd2;
-wire cond_64 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd3;
-wire cond_65 = dec_ready_one && decoder[7:0] == 8'h60;
-wire cond_66 = dec_ready_one && decoder[7:0] == 8'h9B;
-wire cond_67 = dec_ready_modregrm_one && { decoder[7:3], 3'b0 } == 8'hD8;
-wire cond_68 = dec_ready_2byte_modregrm && decoder[7:4] == 4'h9;
-wire cond_69 = dec_ready_2byte_modregrm && { decoder[7:1], 1'b0 } == 8'hB0;
-wire cond_70 = dec_ready_one_three && decoder[7:0] == 8'hC8;
-wire cond_71 = (dec_ready_modregrm_one && ({ decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd5)) || (dec_ready_2byte_modregrm && decoder[7:0] == 8'hAF);
-wire cond_72 = dec_ready_modregrm_imm && (decoder[7:0] == 8'h69 || decoder[7:0] == 8'h6B);
-wire cond_73 = dec_ready_one && decoder[7:0] == 8'hC9;
-wire cond_74 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hA5) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hA4);
-wire cond_75 = decoder[0];
-wire cond_76 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hAD) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hAC);
-wire cond_77 = dec_ready_2byte_one && decoder[7:0] == 8'h09;
-wire cond_78 = dec_ready_one_imm && decoder[7:6] == 2'b00 && decoder[2:1] == 2'b10;
-wire cond_79 = dec_ready_modregrm_one && decoder[7:6] == 2'b00 && decoder[2] == 1'b0;
-wire cond_80 = prefix_group_1_lock  && (decoder[1] == 1'b1 || `DEC_MODREGRM_IS_MOD_11 || decoder[5:3] == 3'b111);
-wire cond_81 = dec_ready_modregrm_imm && { decoder[7:2], 2'b00 } == 8'h80;
-wire cond_82 = prefix_group_1_lock  && (decoder[13:11] == 3'b111 || `DEC_MODREGRM_IS_MOD_11);
-wire cond_83 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd4;
-wire cond_84 = dec_ready_one_one && (decoder[7:0] == 8'hE0 || decoder[7:0] == 8'hE1 || decoder[7:0] == 8'hE2);
-wire cond_85 = dec_ready_one_imm && { decoder[7:1], 1'b0 } == 8'hA8;
-wire cond_86 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'h84;
-wire cond_87 = dec_ready_modregrm_imm && { decoder[7:1], 1'b0 } == 8'hF6 && { decoder[13:12], 1'b0 } == 3'd0;
-wire cond_88 = dec_ready_2byte_one && decoder[7:0] == 8'h06;
-wire cond_89 = (dec_ready_one && decoder[7:0] == 8'hCB) || (dec_ready_one_two && decoder[7:0] == 8'hCA);
-wire cond_90 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'hAC;
-wire cond_91 = dec_ready_one && { decoder[7:3], 3'b0 } == 8'h90;
-wire cond_92 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'h86;
-wire cond_93 = dec_ready_one && { decoder[7:3], 3'b0 } == 8'h50;
-wire cond_94 = dec_ready_one_imm && (decoder[7:0] == 8'h6A || decoder[7:0] == 8'h68);
-wire cond_95 = dec_ready_modregrm_one && decoder[7:0] == 8'hFF && decoder[13:11] == 3'd6;
-wire cond_96 = (dec_ready_one && (decoder[7:0] == 8'hCC || decoder[7:0] == 8'hCE || decoder[7:0] == 8'hF1)) || (dec_ready_one_one && decoder[7:0] == 8'hCD);
-wire cond_97 = (decoder[0] ^ decoder[2]) == 1'b1;
-wire cond_98 = dec_ready_2byte_one && decoder[7:0] == 8'hA2;
-wire cond_99 = (dec_ready_one && { decoder[7:1], 1'b0 } == 8'hEC) || (dec_ready_one_one && { decoder[7:1], 1'b0 } == 8'hE4);
-wire cond_100 = decoder[3];
-wire cond_101 = decoder[3] == 1'b1;
-wire cond_102 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd2;
-wire cond_103 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd4;
-wire cond_104 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd5;
-wire cond_105 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h02;
-wire cond_106 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h03;
-wire cond_107 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'hAA;
-wire cond_108 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'h6C;
-wire cond_109 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'h6E;
-wire cond_110 = dec_ready_one && decoder[7:0] == 8'h9C;
-wire cond_111 = dec_ready_call_jmp_imm && (decoder[7:0] == 8'hEA || decoder[7:0] == 8'hE9 || decoder[7:0] == 8'hEB);
-wire cond_112 = decoder[3:0] == 4'hB;
-wire cond_113 = dec_ready_modregrm_one && decoder[7:0] == 8'hFF && (decoder[13:11] == 3'd4 || decoder[13:11] == 3'd5);
-wire cond_114 = prefix_group_1_lock  || (decoder[13:11] == 3'd5 && `DEC_MODREGRM_IS_MOD_11);
-wire cond_115 = (dec_ready_one && { decoder[7:1], 1'b0 } == 8'hEE) || (dec_ready_one_one && { decoder[7:1], 1'b0 } == 8'hE6);
-wire cond_116 = dec_ready_mem_offset && { decoder[7:2], 2'b0 } == 8'hA0;
-wire cond_117 = dec_ready_one_imm && decoder[7:4] == 4'hB;
-wire cond_118 = decoder[3] == 1'b0;
-wire cond_119 = dec_ready_modregrm_one && { decoder[7:2], 2'b0 } == 8'h88;
-wire cond_120 = dec_ready_modregrm_imm && { decoder[7:1], 1'b0 } == 8'hC6 && decoder[13:11] == 3'd0;
-wire cond_121 = dec_ready_one && decoder[7:0] == 8'h9F;
-wire cond_122 = dec_ready_one && decoder[7:0] == 8'h98;
-wire cond_123 = dec_ready_one && decoder[7:0] == 8'h99;
-wire cond_124 = dec_ready_one && decoder[7:0] == 8'h9D;
-wire cond_125 = dec_ready_one && decoder[7:0] == 8'hFA;
-wire cond_126 = dec_ready_one && decoder[7:0] == 8'hFB;
-wire cond_127 = dec_ready_modregrm_one && decoder[7:0] == 8'h62;
-wire cond_128 = dec_ready_one && decoder[7:0] == 8'hD6;
-wire cond_129 = dec_ready_modregrm_one && decoder[7:0] == 8'h8D;
-wire cond_130 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd0;
-wire cond_131 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd1;
-wire cond_132 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'hA4;
-wire cond_133 = dec_ready_2byte_modregrm && { decoder[7:1], 1'b0 } == 8'hB6;
-wire cond_134 = dec_ready_2byte_modregrm && { decoder[7:1], 1'b0 } == 8'hBE;
-wire cond_135 = dec_ready_one && decoder[7:0] == 8'h61;
-wire cond_136 = dec_ready_2byte_modregrm && { decoder[7:2], 1'b0, decoder[0] } == 8'h21;
-wire cond_137 = dec_ready_one && decoder[7:0] == 8'hD7;
-wire cond_138 = dec_ready_one && decoder[7:0] == 8'h37;
-wire cond_139 = dec_ready_one && decoder[7:0] == 8'h3F;
-wire cond_140 = dec_ready_one && decoder[7:0] == 8'h27;
-wire cond_141 = dec_ready_one && decoder[7:0] == 8'h2F;
-wire cond_142 = dec_ready_2byte_modregrm && decoder[7:0] == 8'hBC;
-wire cond_143 = dec_ready_2byte_modregrm && decoder[7:0] == 8'hBD;
-//======================================================== saves
-//======================================================== always
-//======================================================== sets
-assign consume_mem_offset =
-    (cond_116 && ~cond_4)? (`TRUE) :
-    1'd0;
-assign dec_cmd =
-    (cond_0 && ~cond_1)? ( `CMD_XADD) :
-    (cond_3 && ~cond_4)? ( `CMD_JCXZ) :
-    (cond_5 && ~cond_4)? ( `CMD_CALL) :
-    (cond_7 && ~cond_8)? ( `CMD_CALL) :
-    (cond_10 && ~cond_4)? ( `CMD_PUSH_MOV_SEG) :
-    (cond_11 && ~cond_12)? ( `CMD_PUSH_MOV_SEG) :
-    (cond_13 && ~cond_14)? ( `CMD_PUSH_MOV_SEG) :
-    (cond_15 && ~cond_14)? ( `CMD_PUSH_MOV_SEG) :
-    (cond_16 && ~cond_1)? ( `CMD_NEG) :
-    (cond_17 && ~cond_4)? ( `CMD_Jcc) :
-    (cond_20 && ~cond_4)? ( `CMD_INVD) :
-    (cond_21 && ~cond_22)? ( `CMD_INVLPG) :
-    (cond_23 && ~cond_4)? ( `CMD_HLT) :
-    (cond_24 && ~cond_4)? ( `CMD_SCAS) :
-    (cond_26 && ~cond_4)? ( `CMD_INC_DEC) :
-    (cond_27 && ~cond_1)? ( `CMD_INC_DEC) :
-    (cond_28 && ~cond_4)? ( `CMD_RET_near) :
-    (cond_29 && ~cond_14)? ( `CMD_ARPL) :
-    (cond_30 && ~cond_4)? ( `CMD_BSWAP) :
-    (cond_31 && ~cond_22)? ( `CMD_LxS) :
-    (cond_32 && ~cond_33)? ( `CMD_MOV_to_seg) :
-    (cond_34 && ~cond_14)? ( `CMD_LLDT) :
-    (cond_35 && ~cond_14)? ( `CMD_LTR) :
-    (cond_36 && ~cond_4)? ( `CMD_CLC) :
-    (cond_37 && ~cond_4)? ( `CMD_CLD) :
-    (cond_38 && ~cond_4)? ( `CMD_CMC) :
-    (cond_39 && ~cond_4)? ( `CMD_STC) :
-    (cond_40 && ~cond_4)? ( `CMD_STD) :
-    (cond_41 && ~cond_4)? ( `CMD_SAHF) :
-    (cond_42 && ~cond_4)? ( `CMD_AAD) :
-    (cond_43 && ~cond_4)? ( `CMD_AAM) :
-    (cond_44 && ~cond_4)? ( `CMD_POP_seg) :
-    (cond_45 && ~cond_4)? ( `CMD_BT) :
-    (cond_46 && ~cond_1)? ( `CMD_BTR) :
-    (cond_47 && ~cond_1)? ( `CMD_BTS) :
-    (cond_48 && ~cond_1)? ( `CMD_BTC) :
-    (cond_49 && ~cond_4)? ( `CMD_IRET) :
-    (cond_51 && ~cond_4)? ( `CMD_POP) :
-    (cond_52 && ~cond_4)? ( `CMD_POP) :
-    (cond_53 && ~cond_4)? ( `CMD_DIV) :
-    (cond_54 && ~cond_4)? ( `CMD_IDIV) :
-    (cond_55 && ~cond_4)? ( `CMD_Shift) :
-    (cond_57 && ~cond_4)? ( `CMD_Shift) :
-    (cond_58 && ~cond_4)? ( `CMD_CMPS) :
-    (cond_59 && ~cond_4)? ( `CMD_control_reg) :
-    (cond_60 && ~cond_4)? ( `CMD_control_reg) :
-    (cond_61 && ~cond_62)? ( `CMD_control_reg) :
-    (cond_63 && ~cond_22)? ( `CMD_LGDT) :
-    (cond_64 && ~cond_22)? ( `CMD_LIDT) :
-    (cond_65 && ~cond_4)? ( `CMD_PUSHA) :
-    (cond_66 && ~cond_4)? ( `CMD_fpu) :
-    (cond_67 && ~cond_4)? ( `CMD_fpu) :
-    (cond_68 && ~cond_4)? ( `CMD_SETcc) :
-    (cond_69 && ~cond_1)? ( `CMD_CMPXCHG) :
-    (cond_70 && ~cond_4)? ( `CMD_ENTER) :
-    (cond_71 && ~cond_4)? ( `CMD_IMUL) :
-    (cond_72 && ~cond_4)? ( `CMD_IMUL) :
-    (cond_73 && ~cond_4)? ( `CMD_LEAVE) :
-    (cond_74 && ~cond_4)? ( `CMD_SHLD) :
-    (cond_76 && ~cond_4)? ( `CMD_SHRD) :
-    (cond_77 && ~cond_4)? ( `CMD_WBINVD) :
-    (cond_78 && ~cond_4)? ( {`CMD_Arith | { 4'd0, decoder[5:3] } }) :
-    (cond_79 && ~cond_80)? ( {`CMD_Arith | { 4'd0, decoder[5:3] } }) :
-    (cond_81 && ~cond_82)? ( {`CMD_Arith | { 4'd0, decoder[13:11] } }) :
-    (cond_83 && ~cond_4)? ( `CMD_MUL) :
-    (cond_84 && ~cond_4)? ( `CMD_LOOP) :
-    (cond_85 && ~cond_4)? ( `CMD_TEST) :
-    (cond_86 && ~cond_4)? ( `CMD_TEST) :
-    (cond_87 && ~cond_4)? ( `CMD_TEST) :
-    (cond_88 && ~cond_4)? ( `CMD_CLTS) :
-    (cond_89 && ~cond_4)? ( `CMD_RET_far) :
-    (cond_90 && ~cond_4)? ( `CMD_LODS) :
-    (cond_91 && ~cond_4)? ( `CMD_XCHG) :
-    (cond_92 && ~cond_1)? ( `CMD_XCHG) :
-    (cond_93 && ~cond_4)? ( `CMD_PUSH) :
-    (cond_94 && ~cond_4)? ( `CMD_PUSH) :
-    (cond_95 && ~cond_4)? ( `CMD_PUSH) :
-    (cond_96 && ~cond_4)? ( `CMD_INT_INTO) :
-    (cond_98 && ~cond_4)? ( `CMD_CPUID) :
-    (cond_99 && ~cond_4)? ( `CMD_IN) :
-    (cond_102 && ~cond_1)? ( `CMD_NOT) :
-    (cond_103 && ~cond_14)? ( `CMD_VERR) :
-    (cond_104 && ~cond_14)? ( `CMD_VERW) :
-    (cond_105 && ~cond_14)? ( `CMD_LAR) :
-    (cond_106 && ~cond_14)? ( `CMD_LSL) :
-    (cond_107 && ~cond_4)? ( `CMD_STOS) :
-    (cond_108 && ~cond_4)? ( `CMD_INS) :
-    (cond_109 && ~cond_4)? ( `CMD_OUTS) :
-    (cond_110 && ~cond_4)? ( `CMD_PUSHF) :
-    (cond_111 && ~cond_4)? ( `CMD_JMP) :
-    (cond_113 && ~cond_114)? ( `CMD_JMP) :
-    (cond_115 && ~cond_4)? ( `CMD_OUT) :
-    (cond_116 && ~cond_4)? ( `CMD_MOV) :
-    (cond_117 && ~cond_4)? ( `CMD_MOV) :
-    (cond_119 && ~cond_4)? ( `CMD_MOV) :
-    (cond_120 && ~cond_4)? ( `CMD_MOV) :
-    (cond_121 && ~cond_4)? ( `CMD_LAHF) :
-    (cond_122 && ~cond_4)? ( `CMD_CBW) :
-    (cond_123 && ~cond_4)? ( `CMD_CWD) :
-    (cond_124 && ~cond_4)? ( `CMD_POPF) :
-    (cond_125 && ~cond_4)? ( `CMD_CLI) :
-    (cond_126 && ~cond_4)? ( `CMD_STI) :
-    (cond_127 && ~cond_22)? ( `CMD_BOUND) :
-    (cond_128 && ~cond_4)? ( `CMD_SALC) :
-    (cond_129 && ~cond_22)? ( `CMD_LEA) :
-    (cond_130 && ~cond_22)? ( `CMD_SGDT) :
-    (cond_131 && ~cond_22)? ( `CMD_SIDT) :
-    (cond_132 && ~cond_4)? ( `CMD_MOVS) :
-    (cond_133 && ~cond_4)? ( `CMD_MOVZX) :
-    (cond_134 && ~cond_4)? ( `CMD_MOVSX) :
-    (cond_135 && ~cond_4)? ( `CMD_POPA) :
-    (cond_136 && ~cond_4)? ( `CMD_debug_reg) :
-    (cond_137 && ~cond_4)? ( `CMD_XLAT) :
-    (cond_138 && ~cond_4)? ( `CMD_AAA) :
-    (cond_139 && ~cond_4)? ( `CMD_AAS) :
-    (cond_140 && ~cond_4)? ( `CMD_DAA) :
-    (cond_141 && ~cond_4)? ( `CMD_DAS) :
-    (cond_142 && ~cond_4)? ( `CMD_BSF) :
-    (cond_143 && ~cond_4)? ( `CMD_BSR) :
-    7'd0;
-assign dec_is_complex =
-    (cond_0 && ~cond_1)? (`TRUE) :
-    (cond_5 && ~cond_4)? (`TRUE) :
-    (cond_7 && ~cond_8)? (`TRUE) :
-    (cond_20 && ~cond_4)? (`TRUE) :
-    (cond_21 && ~cond_22)? (`TRUE) :
-    (cond_23 && ~cond_4)? (`TRUE) :
-    (cond_24 && ~cond_4 && cond_25)? (`TRUE) :
-    (cond_28 && ~cond_4)? (`TRUE) :
-    (cond_31 && ~cond_22)? (`TRUE) :
-    (cond_32 && ~cond_33)? (`TRUE) :
-    (cond_34 && ~cond_14)? (`TRUE) :
-    (cond_35 && ~cond_14)? (`TRUE) :
-    (cond_44 && ~cond_4)? (`TRUE) :
-    (cond_49 && ~cond_4)? (`TRUE) :
-    (cond_52 && ~cond_4)? (`TRUE) :
-    (cond_58 && ~cond_4)? (`TRUE) :
-    (cond_60 && ~cond_4)? (`TRUE) :
-    (cond_61 && ~cond_62 && cond_56)? (`TRUE) :
-    (cond_63 && ~cond_22)? (`TRUE) :
-    (cond_64 && ~cond_22)? (`TRUE) :
-    (cond_65 && ~cond_4)? (`TRUE) :
-    (cond_70 && ~cond_4)? (`TRUE) :
-    (cond_77 && ~cond_4)? (`TRUE) :
-    (cond_88 && ~cond_4)? (`TRUE) :
-    (cond_89 && ~cond_4)? (`TRUE) :
-    (cond_90 && ~cond_4 && cond_25)? (`TRUE) :
-    (cond_92 && ~cond_1)? (`TRUE) :
-    (cond_96 && ~cond_4)? (`TRUE) :
-    (cond_98 && ~cond_4)? (`TRUE) :
-    (cond_99 && ~cond_4)? (`TRUE) :
-    (cond_103 && ~cond_14)? (`TRUE) :
-    (cond_104 && ~cond_14)? (`TRUE) :
-    (cond_105 && ~cond_14)? (`TRUE) :
-    (cond_106 && ~cond_14)? (`TRUE) :
-    (cond_107 && ~cond_4 && cond_25)? (`TRUE) :
-    (cond_108 && ~cond_4)? (`TRUE) :
-    (cond_109 && ~cond_4)? (`TRUE) :
-    (cond_111 && ~cond_4)? (`TRUE) :
-    (cond_113 && ~cond_114)? (`TRUE) :
-    (cond_115 && ~cond_4)? (`TRUE) :
-    (cond_124 && ~cond_4)? (`TRUE) :
-    (cond_127 && ~cond_22)? (`TRUE) :
-    (cond_130 && ~cond_22)? (`TRUE) :
-    (cond_131 && ~cond_22)? (`TRUE) :
-    (cond_132 && ~cond_4 && cond_25)? (`TRUE) :
-    (cond_135 && ~cond_4)? (`TRUE) :
-    (cond_136 && ~cond_4 && cond_56)? (`TRUE) :
-    1'd0;
-assign consume_one_two =
-    (cond_28 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_89 && ~cond_4 && cond_2)? (`TRUE) :
-    1'd0;
-assign consume_modregrm_imm =
-    (cond_45 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_46 && ~cond_1 && cond_2)? (`TRUE) :
-    (cond_47 && ~cond_1 && cond_2)? (`TRUE) :
-    (cond_48 && ~cond_1 && cond_2)? (`TRUE) :
-    (cond_57 && ~cond_4)? (`TRUE) :
-    (cond_72 && ~cond_4)? (`TRUE) :
-    (cond_74 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_76 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_81 && ~cond_82)? (`TRUE) :
-    (cond_87 && ~cond_4)? (`TRUE) :
-    (cond_120 && ~cond_4)? (`TRUE) :
-    1'd0;
-assign consume_one =
-    (cond_10 && ~cond_4)? (`TRUE) :
-    (cond_20 && ~cond_4)? (`TRUE) :
-    (cond_23 && ~cond_4)? (`TRUE) :
-    (cond_24 && ~cond_4)? (`TRUE) :
-    (cond_26 && ~cond_4)? (`TRUE) :
-    (cond_28 && ~cond_4 && ~cond_2)? (`TRUE) :
-    (cond_30 && ~cond_4)? (`TRUE) :
-    (cond_36 && ~cond_4)? (`TRUE) :
-    (cond_37 && ~cond_4)? (`TRUE) :
-    (cond_38 && ~cond_4)? (`TRUE) :
-    (cond_39 && ~cond_4)? (`TRUE) :
-    (cond_40 && ~cond_4)? (`TRUE) :
-    (cond_41 && ~cond_4)? (`TRUE) :
-    (cond_44 && ~cond_4)? (`TRUE) :
-    (cond_49 && ~cond_4)? (`TRUE) :
-    (cond_51 && ~cond_4)? (`TRUE) :
-    (cond_58 && ~cond_4)? (`TRUE) :
-    (cond_65 && ~cond_4)? (`TRUE) :
-    (cond_66 && ~cond_4)? (`TRUE) :
-    (cond_73 && ~cond_4)? (`TRUE) :
-    (cond_77 && ~cond_4)? (`TRUE) :
-    (cond_88 && ~cond_4)? (`TRUE) :
-    (cond_89 && ~cond_4 && ~cond_2)? (`TRUE) :
-    (cond_90 && ~cond_4)? (`TRUE) :
-    (cond_91 && ~cond_4)? (`TRUE) :
-    (cond_93 && ~cond_4)? (`TRUE) :
-    (cond_96 && ~cond_4 && cond_97)? (`TRUE) :
-    (cond_98 && ~cond_4)? (`TRUE) :
-    (cond_99 && ~cond_4 && cond_101)? (`TRUE) :
-    (cond_107 && ~cond_4)? (`TRUE) :
-    (cond_108 && ~cond_4)? (`TRUE) :
-    (cond_109 && ~cond_4)? (`TRUE) :
-    (cond_110 && ~cond_4)? (`TRUE) :
-    (cond_115 && ~cond_4 && cond_101)? (`TRUE) :
-    (cond_121 && ~cond_4)? (`TRUE) :
-    (cond_122 && ~cond_4)? (`TRUE) :
-    (cond_123 && ~cond_4)? (`TRUE) :
-    (cond_124 && ~cond_4)? (`TRUE) :
-    (cond_125 && ~cond_4)? (`TRUE) :
-    (cond_126 && ~cond_4)? (`TRUE) :
-    (cond_128 && ~cond_4)? (`TRUE) :
-    (cond_132 && ~cond_4)? (`TRUE) :
-    (cond_135 && ~cond_4)? (`TRUE) :
-    (cond_137 && ~cond_4)? (`TRUE) :
-    (cond_138 && ~cond_4)? (`TRUE) :
-    (cond_139 && ~cond_4)? (`TRUE) :
-    (cond_140 && ~cond_4)? (`TRUE) :
-    (cond_141 && ~cond_4)? (`TRUE) :
-    1'd0;
-assign consume_one_one =
-    (cond_3 && ~cond_4)? (`TRUE) :
-    (cond_17 && ~cond_4 && ~cond_19)? (`TRUE) :
-    (cond_42 && ~cond_4)? (`TRUE) :
-    (cond_43 && ~cond_4)? (`TRUE) :
-    (cond_84 && ~cond_4)? (`TRUE) :
-    (cond_96 && ~cond_4 && ~cond_97)? (`TRUE) :
-    (cond_99 && ~cond_4 && ~cond_101)? (`TRUE) :
-    (cond_115 && ~cond_4 && ~cond_101)? (`TRUE) :
-    1'd0;
-assign exception_ud =
-    (cond_0 && cond_1)? (`TRUE) :
-    (cond_3 && cond_4)? (`TRUE) :
-    (cond_5 && cond_4)? (`TRUE) :
-    (cond_7 && cond_8)? (`TRUE) :
-    (cond_10 && cond_4)? (`TRUE) :
-    (cond_11 && cond_12)? (`TRUE) :
-    (cond_13 && cond_14)? (`TRUE) :
-    (cond_15 && cond_14)? (`TRUE) :
-    (cond_16 && cond_1)? (`TRUE) :
-    (cond_17 && cond_4)? (`TRUE) :
-    (cond_20 && cond_4)? (`TRUE) :
-    (cond_21 && cond_22)? (`TRUE) :
-    (cond_23 && cond_4)? (`TRUE) :
-    (cond_24 && cond_4)? (`TRUE) :
-    (cond_26 && cond_4)? (`TRUE) :
-    (cond_27 && cond_1)? (`TRUE) :
-    (cond_28 && cond_4)? (`TRUE) :
-    (cond_29 && cond_14)? (`TRUE) :
-    (cond_30 && cond_4)? (`TRUE) :
-    (cond_31 && cond_22)? (`TRUE) :
-    (cond_32 && cond_33)? (`TRUE) :
-    (cond_34 && cond_14)? (`TRUE) :
-    (cond_35 && cond_14)? (`TRUE) :
-    (cond_36 && cond_4)? (`TRUE) :
-    (cond_37 && cond_4)? (`TRUE) :
-    (cond_38 && cond_4)? (`TRUE) :
-    (cond_39 && cond_4)? (`TRUE) :
-    (cond_40 && cond_4)? (`TRUE) :
-    (cond_41 && cond_4)? (`TRUE) :
-    (cond_42 && cond_4)? (`TRUE) :
-    (cond_43 && cond_4)? (`TRUE) :
-    (cond_44 && cond_4)? (`TRUE) :
-    (cond_45 && cond_4)? (`TRUE) :
-    (cond_46 && cond_1)? (`TRUE) :
-    (cond_47 && cond_1)? (`TRUE) :
-    (cond_48 && cond_1)? (`TRUE) :
-    (cond_49 && cond_4)? (`TRUE) :
-    (cond_51 && cond_4)? (`TRUE) :
-    (cond_52 && cond_4)? (`TRUE) :
-    (cond_53 && cond_4)? (`TRUE) :
-    (cond_54 && cond_4)? (`TRUE) :
-    (cond_55 && cond_4)? (`TRUE) :
-    (cond_57 && cond_4)? (`TRUE) :
-    (cond_58 && cond_4)? (`TRUE) :
-    (cond_59 && cond_4)? (`TRUE) :
-    (cond_60 && cond_4)? (`TRUE) :
-    (cond_61 && cond_62)? (`TRUE) :
-    (cond_63 && cond_22)? (`TRUE) :
-    (cond_64 && cond_22)? (`TRUE) :
-    (cond_65 && cond_4)? (`TRUE) :
-    (cond_66 && cond_4)? (`TRUE) :
-    (cond_67 && cond_4)? (`TRUE) :
-    (cond_68 && cond_4)? (`TRUE) :
-    (cond_69 && cond_1)? (`TRUE) :
-    (cond_70 && cond_4)? (`TRUE) :
-    (cond_71 && cond_4)? (`TRUE) :
-    (cond_72 && cond_4)? (`TRUE) :
-    (cond_73 && cond_4)? (`TRUE) :
-    (cond_74 && cond_4)? (`TRUE) :
-    (cond_76 && cond_4)? (`TRUE) :
-    (cond_77 && cond_4)? (`TRUE) :
-    (cond_78 && cond_4)? (`TRUE) :
-    (cond_79 && cond_80)? (`TRUE) :
-    (cond_81 && cond_82)? (`TRUE) :
-    (cond_83 && cond_4)? (`TRUE) :
-    (cond_84 && cond_4)? (`TRUE) :
-    (cond_85 && cond_4)? (`TRUE) :
-    (cond_86 && cond_4)? (`TRUE) :
-    (cond_87 && cond_4)? (`TRUE) :
-    (cond_88 && cond_4)? (`TRUE) :
-    (cond_89 && cond_4)? (`TRUE) :
-    (cond_90 && cond_4)? (`TRUE) :
-    (cond_91 && cond_4)? (`TRUE) :
-    (cond_92 && cond_1)? (`TRUE) :
-    (cond_93 && cond_4)? (`TRUE) :
-    (cond_94 && cond_4)? (`TRUE) :
-    (cond_95 && cond_4)? (`TRUE) :
-    (cond_96 && cond_4)? (`TRUE) :
-    (cond_98 && cond_4)? (`TRUE) :
-    (cond_99 && cond_4)? (`TRUE) :
-    (cond_102 && cond_1)? (`TRUE) :
-    (cond_103 && cond_14)? (`TRUE) :
-    (cond_104 && cond_14)? (`TRUE) :
-    (cond_105 && cond_14)? (`TRUE) :
-    (cond_106 && cond_14)? (`TRUE) :
-    (cond_107 && cond_4)? (`TRUE) :
-    (cond_108 && cond_4)? (`TRUE) :
-    (cond_109 && cond_4)? (`TRUE) :
-    (cond_110 && cond_4)? (`TRUE) :
-    (cond_111 && cond_4)? (`TRUE) :
-    (cond_113 && cond_114)? (`TRUE) :
-    (cond_115 && cond_4)? (`TRUE) :
-    (cond_116 && cond_4)? (`TRUE) :
-    (cond_117 && cond_4)? (`TRUE) :
-    (cond_119 && cond_4)? (`TRUE) :
-    (cond_120 && cond_4)? (`TRUE) :
-    (cond_121 && cond_4)? (`TRUE) :
-    (cond_122 && cond_4)? (`TRUE) :
-    (cond_123 && cond_4)? (`TRUE) :
-    (cond_124 && cond_4)? (`TRUE) :
-    (cond_125 && cond_4)? (`TRUE) :
-    (cond_126 && cond_4)? (`TRUE) :
-    (cond_127 && cond_22)? (`TRUE) :
-    (cond_128 && cond_4)? (`TRUE) :
-    (cond_129 && cond_22)? (`TRUE) :
-    (cond_130 && cond_22)? (`TRUE) :
-    (cond_131 && cond_22)? (`TRUE) :
-    (cond_132 && cond_4)? (`TRUE) :
-    (cond_133 && cond_4)? (`TRUE) :
-    (cond_134 && cond_4)? (`TRUE) :
-    (cond_135 && cond_4)? (`TRUE) :
-    (cond_136 && cond_4)? (`TRUE) :
-    (cond_137 && cond_4)? (`TRUE) :
-    (cond_138 && cond_4)? (`TRUE) :
-    (cond_139 && cond_4)? (`TRUE) :
-    (cond_140 && cond_4)? (`TRUE) :
-    (cond_141 && cond_4)? (`TRUE) :
-    (cond_142 && cond_4)? (`TRUE) :
-    (cond_143 && cond_4)? (`TRUE) :
-    1'd0;
-assign consume_one_imm =
-    (cond_17 && ~cond_4 && cond_19)? (`TRUE) :
-    (cond_78 && ~cond_4)? (`TRUE) :
-    (cond_85 && ~cond_4)? (`TRUE) :
-    (cond_94 && ~cond_4)? (`TRUE) :
-    (cond_117 && ~cond_4)? (`TRUE) :
-    1'd0;
-assign consume_call_jmp_imm =
-    (cond_5 && ~cond_4)? (`TRUE) :
-    (cond_111 && ~cond_4)? (`TRUE) :
-    1'd0;
-assign consume_modregrm_one =
-    (cond_0 && ~cond_1)? (`TRUE) :
-    (cond_7 && ~cond_8)? (`TRUE) :
-    (cond_11 && ~cond_12)? (`TRUE) :
-    (cond_13 && ~cond_14)? (`TRUE) :
-    (cond_15 && ~cond_14)? (`TRUE) :
-    (cond_16 && ~cond_1)? (`TRUE) :
-    (cond_21 && ~cond_22)? (`TRUE) :
-    (cond_27 && ~cond_1)? (`TRUE) :
-    (cond_29 && ~cond_14)? (`TRUE) :
-    (cond_31 && ~cond_22)? (`TRUE) :
-    (cond_32 && ~cond_33)? (`TRUE) :
-    (cond_34 && ~cond_14)? (`TRUE) :
-    (cond_35 && ~cond_14)? (`TRUE) :
-    (cond_45 && ~cond_4 && ~cond_2)? (`TRUE) :
-    (cond_46 && ~cond_1 && ~cond_2)? (`TRUE) :
-    (cond_47 && ~cond_1 && ~cond_2)? (`TRUE) :
-    (cond_48 && ~cond_1 && ~cond_2)? (`TRUE) :
-    (cond_52 && ~cond_4)? (`TRUE) :
-    (cond_53 && ~cond_4)? (`TRUE) :
-    (cond_54 && ~cond_4)? (`TRUE) :
-    (cond_55 && ~cond_4)? (`TRUE) :
-    (cond_59 && ~cond_4)? (`TRUE) :
-    (cond_60 && ~cond_4)? (`TRUE) :
-    (cond_61 && ~cond_62)? (`TRUE) :
-    (cond_63 && ~cond_22)? (`TRUE) :
-    (cond_64 && ~cond_22)? (`TRUE) :
-    (cond_67 && ~cond_4)? (`TRUE) :
-    (cond_68 && ~cond_4)? (`TRUE) :
-    (cond_69 && ~cond_1)? (`TRUE) :
-    (cond_71 && ~cond_4)? (`TRUE) :
-    (cond_74 && ~cond_4 && ~cond_2)? (`TRUE) :
-    (cond_76 && ~cond_4 && ~cond_2)? (`TRUE) :
-    (cond_79 && ~cond_80)? (`TRUE) :
-    (cond_83 && ~cond_4)? (`TRUE) :
-    (cond_86 && ~cond_4)? (`TRUE) :
-    (cond_92 && ~cond_1)? (`TRUE) :
-    (cond_95 && ~cond_4)? (`TRUE) :
-    (cond_102 && ~cond_1)? (`TRUE) :
-    (cond_103 && ~cond_14)? (`TRUE) :
-    (cond_104 && ~cond_14)? (`TRUE) :
-    (cond_105 && ~cond_14)? (`TRUE) :
-    (cond_106 && ~cond_14)? (`TRUE) :
-    (cond_113 && ~cond_114)? (`TRUE) :
-    (cond_119 && ~cond_4)? (`TRUE) :
-    (cond_127 && ~cond_22)? (`TRUE) :
-    (cond_129 && ~cond_22)? (`TRUE) :
-    (cond_130 && ~cond_22)? (`TRUE) :
-    (cond_131 && ~cond_22)? (`TRUE) :
-    (cond_133 && ~cond_4)? (`TRUE) :
-    (cond_134 && ~cond_4)? (`TRUE) :
-    (cond_136 && ~cond_4)? (`TRUE) :
-    (cond_142 && ~cond_4)? (`TRUE) :
-    (cond_143 && ~cond_4)? (`TRUE) :
-    1'd0;
-assign consume_one_three =
-    (cond_70 && ~cond_4)? (`TRUE) :
-    1'd0;
-assign dec_is_8bit =
-    (cond_0 && ~cond_1 && cond_2)? (`TRUE) :
-    (cond_3 && ~cond_4)? (`TRUE) :
-    (cond_16 && ~cond_1 && cond_2)? (`TRUE) :
-    (cond_17 && ~cond_4 && cond_18)? (`TRUE) :
-    (cond_24 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_27 && ~cond_1 && cond_2)? (`TRUE) :
-    (cond_42 && ~cond_4)? (`TRUE) :
-    (cond_43 && ~cond_4)? (`TRUE) :
-    (cond_53 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_54 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_55 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_57 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_58 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_68 && ~cond_4)? (`TRUE) :
-    (cond_69 && ~cond_1 && cond_2)? (`TRUE) :
-    (cond_71 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_78 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_79 && ~cond_80 && cond_2)? (`TRUE) :
-    (cond_81 && ~cond_82 && cond_2)? (`TRUE) :
-    (cond_83 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_84 && ~cond_4)? (`TRUE) :
-    (cond_85 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_86 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_87 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_90 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_92 && ~cond_1 && cond_2)? (`TRUE) :
-    (cond_99 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_102 && ~cond_1 && cond_2)? (`TRUE) :
-    (cond_107 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_108 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_109 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_111 && ~cond_4 && cond_112)? (`TRUE) :
-    (cond_115 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_116 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_117 && ~cond_4 && cond_118)? (`TRUE) :
-    (cond_119 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_120 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_132 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_133 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_134 && ~cond_4 && cond_2)? (`TRUE) :
-    (cond_137 && ~cond_4)? (`TRUE) :
-    (cond_138 && ~cond_4)? (`TRUE) :
-    (cond_139 && ~cond_4)? (`TRUE) :
-    (cond_140 && ~cond_4)? (`TRUE) :
-    (cond_141 && ~cond_4)? (`TRUE) :
-    1'd0;
-assign dec_cmdex =
-    (cond_5 && ~cond_4 && cond_6)? ( `CMDEX_CALL_Jv_STEP_0) :
-    (cond_5 && ~cond_4 && ~cond_6)? ( `CMDEX_CALL_Ap_STEP_0) :
-    (cond_7 && ~cond_8 && cond_9)? ( `CMDEX_CALL_Ev_STEP_0) :
-    (cond_7 && ~cond_8 && ~cond_9)? ( `CMDEX_CALL_Ep_STEP_0) :
-    (cond_10 && ~cond_4)? ( `CMDEX_PUSH_MOV_SEG_implicit | { 1'b0, decoder[5:3] }) :
-    (cond_11 && ~cond_12)? ( `CMDEX_PUSH_MOV_SEG_modregrm | { 1'b0, decoder[13:11] }) :
-    (cond_13 && ~cond_14)? ( `CMDEX_PUSH_MOV_SEG_modregrm_LDT) :
-    (cond_15 && ~cond_14)? ( `CMDEX_PUSH_MOV_SEG_modregrm_TR) :
-    (cond_20 && ~cond_4)? ( `CMDEX_INVD_STEP_0) :
-    (cond_21 && ~cond_22)? ( `CMDEX_INVLPG_STEP_0) :
-    (cond_23 && ~cond_4)? ( `CMDEX_HLT_STEP_0) :
-    (cond_24 && ~cond_4)? ( `CMDEX_SCAS_STEP_0) :
-    (cond_26 && ~cond_4)? ( `CMDEX_INC_DEC_increment_implicit | { 3'd0, decoder[3] }) :
-    (cond_27 && ~cond_1)? ( `CMDEX_INC_DEC_increment_modregrm | { 3'd0, decoder[11] }) :
-    (cond_28 && ~cond_4 && cond_2)? ( `CMDEX_RET_near_imm) :
-    (cond_28 && ~cond_4 && ~cond_2)? ( `CMDEX_RET_near) :
-    (cond_31 && ~cond_22)? ( `CMDEX_LxS_STEP_1) :
-    (cond_32 && ~cond_33)? ( `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1) :
-    (cond_34 && ~cond_14)? ( `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1) :
-    (cond_35 && ~cond_14)? ( `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1) :
-    (cond_44 && ~cond_4)? ( `CMDEX_POP_seg_STEP_1) :
-    (cond_45 && ~cond_4 && cond_2)? ( `CMDEX_BTx_modregrm_imm) :
-    (cond_45 && ~cond_4 && ~cond_2)? ( `CMDEX_BTx_modregrm) :
-    (cond_46 && ~cond_1 && cond_2)? ( `CMDEX_BTx_modregrm_imm) :
-    (cond_46 && ~cond_1 && ~cond_2)? ( `CMDEX_BTx_modregrm) :
-    (cond_47 && ~cond_1 && cond_2)? ( `CMDEX_BTx_modregrm_imm) :
-    (cond_47 && ~cond_1 && ~cond_2)? ( `CMDEX_BTx_modregrm) :
-    (cond_48 && ~cond_1 && cond_2)? ( `CMDEX_BTx_modregrm_imm) :
-    (cond_48 && ~cond_1 && ~cond_2)? ( `CMDEX_BTx_modregrm) :
-    (cond_49 && ~cond_4 && cond_50)? ( `CMDEX_IRET_real_v86_STEP_0) :
-    (cond_49 && ~cond_4 && ~cond_50)? ( `CMDEX_IRET_protected_STEP_0) :
-    (cond_51 && ~cond_4)? ( `CMDEX_POP_implicit) :
-    (cond_52 && ~cond_4)? ( `CMDEX_POP_modregrm_STEP_0) :
-    (cond_55 && ~cond_4 && cond_56)? ( `CMDEX_Shift_implicit) :
-    (cond_55 && ~cond_4 && ~cond_56)? ( `CMDEX_Shift_modregrm) :
-    (cond_57 && ~cond_4)? ( `CMDEX_Shift_modregrm_imm) :
-    (cond_58 && ~cond_4)? (`CMDEX_CMPS_FIRST) :
-    (cond_59 && ~cond_4)? ( `CMDEX_control_reg_SMSW_STEP_0) :
-    (cond_60 && ~cond_4)? ( `CMDEX_control_reg_LMSW_STEP_0) :
-    (cond_61 && ~cond_62 && cond_56)? ( `CMDEX_control_reg_MOV_load_STEP_0) :
-    (cond_61 && ~cond_62 && ~cond_56)? ( `CMDEX_control_reg_MOV_store_STEP_0) :
-    (cond_63 && ~cond_22)? ( `CMDEX_LGDT_LIDT_STEP_1) :
-    (cond_64 && ~cond_22)? ( `CMDEX_LGDT_LIDT_STEP_1) :
-    (cond_65 && ~cond_4)? ( `CMDEX_PUSHA_STEP_0) :
-    (cond_66 && ~cond_4)? ( `CMDEX_WAIT_STEP_0) :
-    (cond_67 && ~cond_4)? ( `CMDEX_ESC_STEP_0) :
-    (cond_70 && ~cond_4)? ( `CMDEX_ENTER_FIRST) :
-    (cond_71 && ~cond_4)? ( `CMDEX_IMUL_modregrm) :
-    (cond_72 && ~cond_4)? ( `CMDEX_IMUL_modregrm_imm) :
-    (cond_74 && ~cond_4 && cond_75)? ( `CMDEX_SHxD_implicit) :
-    (cond_74 && ~cond_4 && ~cond_75)? ( `CMDEX_SHxD_modregrm_imm) :
-    (cond_76 && ~cond_4 && cond_75)? ( `CMDEX_SHxD_implicit) :
-    (cond_76 && ~cond_4 && ~cond_75)? ( `CMDEX_SHxD_modregrm_imm) :
-    (cond_77 && ~cond_4)? ( `CMDEX_WBINVD_STEP_0) :
-    (cond_78 && ~cond_4)? ( `CMDEX_Arith_immediate) :
-    (cond_79 && ~cond_80)? ( `CMDEX_Arith_modregrm) :
-    (cond_81 && ~cond_82)? ( `CMDEX_Arith_modregrm_imm) :
-    (cond_84 && ~cond_4)? ( (decoder[1:0] == 2'b00)? `CMDEX_LOOP_NE : (decoder[1:0] == 2'b01)? `CMDEX_LOOP_E : `CMDEX_LOOP) :
-    (cond_85 && ~cond_4)? ( `CMDEX_TEST_immediate) :
-    (cond_86 && ~cond_4)? ( `CMDEX_TEST_modregrm) :
-    (cond_87 && ~cond_4)? ( `CMDEX_TEST_modregrm_imm) :
-    (cond_88 && ~cond_4)? (`CMDEX_CLTS_STEP_FIRST) :
-    (cond_89 && ~cond_4)? ( `CMDEX_RET_far_STEP_1) :
-    (cond_90 && ~cond_4)? ( `CMDEX_LODS_STEP_0) :
-    (cond_91 && ~cond_4)? ( `CMDEX_XCHG_implicit) :
-    (cond_92 && ~cond_1)? ( `CMDEX_XCHG_modregrm) :
-    (cond_93 && ~cond_4)? ( `CMDEX_PUSH_implicit) :
-    (cond_94 && ~cond_4 && cond_56)? ( `CMDEX_PUSH_immediate_se) :
-    (cond_94 && ~cond_4 && ~cond_56)? ( `CMDEX_PUSH_immediate) :
-    (cond_95 && ~cond_4)? ( `CMDEX_PUSH_modregrm) :
-    (cond_96 && ~cond_4)? ( (decoder[2:0] == 3'b100)? `CMDEX_INT_INTO_INT3_STEP_0 : (decoder[2:0] == 3'b101)? `CMDEX_INT_INTO_INT_STEP_0 : (decoder[2:0] == 3'b110)? `CMDEX_INT_INTO_INTO_STEP_0 : `CMDEX_INT_INTO_INT1_STEP_0) :
-    (cond_98 && ~cond_4)? ( `CMDEX_CPUID_STEP_LAST) :
-    (cond_99 && ~cond_4 && cond_100)? ( `CMDEX_IN_dx) :
-    (cond_99 && ~cond_4 && ~cond_100)? ( `CMDEX_IN_imm) :
-    (cond_103 && ~cond_14)? ( `CMDEX_LAR_LSL_VERR_VERW_STEP_1) :
-    (cond_104 && ~cond_14)? ( `CMDEX_LAR_LSL_VERR_VERW_STEP_1) :
-    (cond_105 && ~cond_14)? (`CMDEX_LAR_LSL_VERR_VERW_STEP_1) :
-    (cond_106 && ~cond_14)? ( `CMDEX_LAR_LSL_VERR_VERW_STEP_1) :
-    (cond_107 && ~cond_4)? ( `CMDEX_STOS_STEP_0) :
-    (cond_108 && ~cond_4)? ( `CMDEX_INS_real_1) :
-    (cond_109 && ~cond_4)? ( `CMDEX_OUTS_first) :
-    (cond_111 && ~cond_4 && cond_2)? ( `CMDEX_JMP_Ap_STEP_0) :
-    (cond_111 && ~cond_4 && ~cond_2)? ( `CMDEX_JMP_Jv_STEP_0) :
-    (cond_113 && ~cond_114 && cond_9)? ( `CMDEX_JMP_Ev_STEP_0) :
-    (cond_113 && ~cond_114 && ~cond_9)? ( `CMDEX_JMP_Ep_STEP_0) :
-    (cond_115 && ~cond_4 && cond_100)? ( `CMDEX_OUT_dx) :
-    (cond_115 && ~cond_4 && ~cond_100)? ( `CMDEX_OUT_imm) :
-    (cond_116 && ~cond_4)? ( `CMDEX_MOV_memoffset) :
-    (cond_117 && ~cond_4)? ( `CMDEX_MOV_immediate) :
-    (cond_119 && ~cond_4)? ( `CMDEX_MOV_modregrm) :
-    (cond_120 && ~cond_4)? ( `CMDEX_MOV_modregrm_imm) :
-    (cond_124 && ~cond_4)? ( `CMDEX_POPF_STEP_0) :
-    (cond_127 && ~cond_22)? ( `CMDEX_BOUND_STEP_FIRST) :
-    (cond_128 && ~cond_4)? ( `CMDEX_SALC_STEP_0) :
-    (cond_130 && ~cond_22)? ( `CMDEX_SGDT_SIDT_STEP_1) :
-    (cond_131 && ~cond_22)? ( `CMDEX_SGDT_SIDT_STEP_1) :
-    (cond_132 && ~cond_4)? ( `CMDEX_MOVS_STEP_0) :
-    (cond_135 && ~cond_4)? ( `CMDEX_POPA_STEP_0) :
-    (cond_136 && ~cond_4 && cond_56)? ( `CMDEX_debug_reg_MOV_load_STEP_0) :
-    (cond_136 && ~cond_4 && ~cond_56)? ( `CMDEX_debug_reg_MOV_store_STEP_0) :
-    4'd0;
+
+
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire cond_12;
+wire cond_13;
+wire cond_14;
+wire cond_15;
+wire cond_16;
+wire cond_17;
+wire cond_18;
+wire cond_19;
+wire cond_20;
+wire cond_21;
+wire cond_22;
+wire cond_23;
+wire cond_24;
+wire cond_25;
+wire cond_26;
+wire cond_27;
+wire cond_28;
+wire cond_29;
+wire cond_30;
+wire cond_31;
+wire cond_32;
+wire cond_33;
+wire cond_34;
+wire cond_35;
+wire cond_36;
+wire cond_37;
+wire cond_38;
+wire cond_39;
+wire cond_40;
+wire cond_41;
+wire cond_42;
+wire cond_43;
+wire cond_44;
+wire cond_45;
+wire cond_46;
+wire cond_47;
+wire cond_48;
+wire cond_49;
+wire cond_50;
+wire cond_51;
+wire cond_52;
+wire cond_53;
+wire cond_54;
+wire cond_55;
+wire cond_56;
+wire cond_57;
+wire cond_58;
+wire cond_59;
+wire cond_60;
+wire cond_61;
+wire cond_62;
+wire cond_63;
+wire cond_64;
+wire cond_65;
+wire cond_66;
+wire cond_67;
+wire cond_68;
+wire cond_69;
+wire cond_70;
+wire cond_71;
+wire cond_72;
+wire cond_73;
+wire cond_74;
+wire cond_75;
+wire cond_76;
+wire cond_77;
+wire cond_78;
+wire cond_79;
+wire cond_80;
+wire cond_81;
+wire cond_82;
+wire cond_83;
+wire cond_84;
+wire cond_85;
+wire cond_86;
+wire cond_87;
+wire cond_88;
+wire cond_89;
+wire cond_90;
+wire cond_91;
+wire cond_92;
+wire cond_93;
+wire cond_94;
+wire cond_95;
+wire cond_96;
+wire cond_97;
+wire cond_98;
+wire cond_99;
+wire cond_100;
+wire cond_101;
+wire cond_102;
+wire cond_103;
+wire cond_104;
+wire cond_105;
+wire cond_106;
+wire cond_107;
+wire cond_108;
+wire cond_109;
+wire cond_110;
+wire cond_111;
+wire cond_112;
+wire cond_113;
+wire cond_114;
+wire cond_115;
+wire cond_116;
+wire cond_117;
+wire cond_118;
+wire cond_119;
+wire cond_120;
+wire cond_121;
+wire cond_122;
+wire cond_123;
+wire cond_124;
+wire cond_125;
+wire cond_126;
+wire cond_127;
+wire cond_128;
+wire cond_129;
+wire cond_130;
+wire cond_131;
+wire cond_132;
+wire cond_133;
+wire cond_134;
+wire cond_135;
+wire cond_136;
+wire cond_137;
+wire cond_138;
+wire cond_139;
+wire cond_140;
+wire cond_141;
+wire cond_142;
+wire cond_143;
+
+//======================================================== conditions
+ assign cond_0 = dec_ready_2byte_modregrm && { decoder[7:1], 1'b0 } == 8'hC0;
+ assign cond_1 = prefix_group_1_lock  && `DEC_MODREGRM_IS_MOD_11;
+ assign cond_2 = decoder[0] == 1'b0;
+ assign cond_3 = dec_ready_one_one && decoder[7:0] == 8'hE3;
+ assign cond_4 = prefix_group_1_lock ;
+ assign cond_5 = dec_ready_call_jmp_imm && (decoder[7:0] == 8'h9A || decoder[7:0] == 8'hE8);
+ assign cond_6 = decoder[1] == 1'b0;
+ assign cond_7 = dec_ready_modregrm_one && decoder[7:0] == 8'hFF && (decoder[13:11] == 3'd2 || decoder[13:11] == 3'd3);
+ assign cond_8 = prefix_group_1_lock  || (decoder[13:11] == 3'd3 && `DEC_MODREGRM_IS_MOD_11);
+ assign cond_9 = decoder[11] == 1'b0;
+ assign cond_10 = (dec_ready_one && (decoder[7:0] == 8'h06 || decoder[7:0] == 8'h16 || decoder[7:0] == 8'h0E || decoder[7:0] == 8'h1E)) || (dec_ready_2byte_one && (decoder[7:0] == 8'hA0 || decoder[7:0] == 8'hA8));
+ assign cond_11 = dec_ready_modregrm_one && decoder[7:0] == 8'h8C;
+ assign cond_12 = prefix_group_1_lock  || decoder[13:11] >= 3'd6;
+ assign cond_13 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd0;
+ assign cond_14 = prefix_group_1_lock  || ~(protected_mode);
+ assign cond_15 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd1;
+ assign cond_16 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd3;
+ assign cond_17 = (dec_ready_one_one && decoder[7:4] == 4'h7) || (dec_ready_2byte_imm && decoder[7:4] == 4'h8);
+ assign cond_18 = ~(dec_prefix_2byte);
+ assign cond_19 = dec_prefix_2byte;
+ assign cond_20 = dec_ready_2byte_one && decoder[7:0] == 8'h08;
+ assign cond_21 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd7;
+ assign cond_22 = prefix_group_1_lock  || `DEC_MODREGRM_IS_MOD_11;
+ assign cond_23 = dec_ready_one && decoder[7:0] == 8'hF4;
+ assign cond_24 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'hAE;
+ assign cond_25 = dec_prefix_group_1_rep != 2'd0;
+ assign cond_26 = dec_ready_one && decoder[7:4] == 4'h4;
+ assign cond_27 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hFE && { decoder[13:12], 1'b0 } == 3'b000;
+ assign cond_28 = (dec_ready_one && decoder[7:0] == 8'hC3) || (dec_ready_one_two && decoder[7:0] == 8'hC2);
+ assign cond_29 = dec_ready_modregrm_one && decoder[7:0] == 8'h63;
+ assign cond_30 = dec_ready_2byte_one && { decoder[7:3], 3'b000 } == 8'hC8;
+ assign cond_31 = (dec_ready_modregrm_one && (decoder[7:0] == 8'hC4 || decoder[7:0] == 8'hC5)) || (dec_ready_2byte_modregrm && (decoder[7:0] == 8'hB2 || decoder[7:0] == 8'hB4 || decoder[7:0] == 8'hB5));
+ assign cond_32 = dec_ready_modregrm_one && decoder[7:0] == 8'h8E;
+ assign cond_33 = prefix_group_1_lock  || decoder[13:11] >= 3'd6 || decoder[13:11] == 3'd1;
+ assign cond_34 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd2;
+ assign cond_35 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd3;
+ assign cond_36 = dec_ready_one && decoder[7:0] == 8'hF8;
+ assign cond_37 = dec_ready_one && decoder[7:0] == 8'hFC;
+ assign cond_38 = dec_ready_one && decoder[7:0] == 8'hF5;
+ assign cond_39 = dec_ready_one && decoder[7:0] == 8'hF9;
+ assign cond_40 = dec_ready_one && decoder[7:0] == 8'hFD;
+ assign cond_41 = dec_ready_one && decoder[7:0] == 8'h9E;
+ assign cond_42 = dec_ready_one_one && decoder[7:0] == 8'hD5;
+ assign cond_43 = dec_ready_one_one && decoder[7:0] == 8'hD4;
+ assign cond_44 = (dec_ready_one && (decoder[7:0] == 8'h07 || decoder[7:0] == 8'h17 || decoder[7:0] == 8'h1F)) || (dec_ready_2byte_one && (decoder[7:0] == 8'hA1 || decoder[7:0] == 8'hA9));
+ assign cond_45 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hA3) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hBA && decoder[13:11] == 3'd4);
+ assign cond_46 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hB3) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hBA && decoder[13:11] == 3'd6);
+ assign cond_47 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hAB) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hBA && decoder[13:11] == 3'd5);
+ assign cond_48 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hBB) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hBA && decoder[13:11] == 3'd7);
+ assign cond_49 = dec_ready_one && decoder[7:0] == 8'hCF;
+ assign cond_50 = ~(protected_mode);
+ assign cond_51 = dec_ready_one && { decoder[7:3], 3'b0 } == 8'h58;
+ assign cond_52 = dec_ready_modregrm_one && decoder[7:0] == 8'h8F && decoder[13:11] == 3'd0;
+ assign cond_53 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd6;
+ assign cond_54 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd7;
+ assign cond_55 = dec_ready_modregrm_one && { decoder[7:2], 2'b0 } == 8'hD0;
+ assign cond_56 = decoder[1];
+ assign cond_57 = dec_ready_modregrm_imm && { decoder[7:1], 1'b0 } == 8'hC0;
+ assign cond_58 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'hA6;
+ assign cond_59 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd4;
+ assign cond_60 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd6;
+ assign cond_61 = dec_ready_2byte_modregrm && { decoder[7:2], 1'b0, decoder[0] } == 8'h20;
+ assign cond_62 = prefix_group_1_lock  || (decoder[13:11] != 3'd0 && decoder[13:11] != 3'd2 && decoder[13:11] != 3'd3);
+ assign cond_63 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd2;
+ assign cond_64 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd3;
+ assign cond_65 = dec_ready_one && decoder[7:0] == 8'h60;
+ assign cond_66 = dec_ready_one && decoder[7:0] == 8'h9B;
+ assign cond_67 = dec_ready_modregrm_one && { decoder[7:3], 3'b0 } == 8'hD8;
+ assign cond_68 = dec_ready_2byte_modregrm && decoder[7:4] == 4'h9;
+ assign cond_69 = dec_ready_2byte_modregrm && { decoder[7:1], 1'b0 } == 8'hB0;
+ assign cond_70 = dec_ready_one_three && decoder[7:0] == 8'hC8;
+ assign cond_71 = (dec_ready_modregrm_one && ({ decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd5)) || (dec_ready_2byte_modregrm && decoder[7:0] == 8'hAF);
+ assign cond_72 = dec_ready_modregrm_imm && (decoder[7:0] == 8'h69 || decoder[7:0] == 8'h6B);
+ assign cond_73 = dec_ready_one && decoder[7:0] == 8'hC9;
+ assign cond_74 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hA5) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hA4);
+ assign cond_75 = decoder[0];
+ assign cond_76 = (dec_ready_2byte_modregrm && decoder[7:0] == 8'hAD) || (dec_ready_2byte_modregrm_imm && decoder[7:0] == 8'hAC);
+ assign cond_77 = dec_ready_2byte_one && decoder[7:0] == 8'h09;
+ assign cond_78 = dec_ready_one_imm && decoder[7:6] == 2'b00 && decoder[2:1] == 2'b10;
+ assign cond_79 = dec_ready_modregrm_one && decoder[7:6] == 2'b00 && decoder[2] == 1'b0;
+ assign cond_80 = prefix_group_1_lock  && (decoder[1] == 1'b1 || `DEC_MODREGRM_IS_MOD_11 || decoder[5:3] == 3'b111);
+ assign cond_81 = dec_ready_modregrm_imm && { decoder[7:2], 2'b00 } == 8'h80;
+ assign cond_82 = prefix_group_1_lock  && (decoder[13:11] == 3'b111 || `DEC_MODREGRM_IS_MOD_11);
+ assign cond_83 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd4;
+ assign cond_84 = dec_ready_one_one && (decoder[7:0] == 8'hE0 || decoder[7:0] == 8'hE1 || decoder[7:0] == 8'hE2);
+ assign cond_85 = dec_ready_one_imm && { decoder[7:1], 1'b0 } == 8'hA8;
+ assign cond_86 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'h84;
+ assign cond_87 = dec_ready_modregrm_imm && { decoder[7:1], 1'b0 } == 8'hF6 && { decoder[13:12], 1'b0 } == 3'd0;
+ assign cond_88 = dec_ready_2byte_one && decoder[7:0] == 8'h06;
+ assign cond_89 = (dec_ready_one && decoder[7:0] == 8'hCB) || (dec_ready_one_two && decoder[7:0] == 8'hCA);
+ assign cond_90 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'hAC;
+ assign cond_91 = dec_ready_one && { decoder[7:3], 3'b0 } == 8'h90;
+ assign cond_92 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'h86;
+ assign cond_93 = dec_ready_one && { decoder[7:3], 3'b0 } == 8'h50;
+ assign cond_94 = dec_ready_one_imm && (decoder[7:0] == 8'h6A || decoder[7:0] == 8'h68);
+ assign cond_95 = dec_ready_modregrm_one && decoder[7:0] == 8'hFF && decoder[13:11] == 3'd6;
+ assign cond_96 = (dec_ready_one && (decoder[7:0] == 8'hCC || decoder[7:0] == 8'hCE || decoder[7:0] == 8'hF1)) || (dec_ready_one_one && decoder[7:0] == 8'hCD);
+ assign cond_97 = (decoder[0] ^ decoder[2]) == 1'b1;
+ assign cond_98 = dec_ready_2byte_one && decoder[7:0] == 8'hA2;
+ assign cond_99 = (dec_ready_one && { decoder[7:1], 1'b0 } == 8'hEC) || (dec_ready_one_one && { decoder[7:1], 1'b0 } == 8'hE4);
+ assign cond_100 = decoder[3];
+ assign cond_101 = decoder[3] == 1'b1;
+ assign cond_102 = dec_ready_modregrm_one && { decoder[7:1], 1'b0 } == 8'hF6 && decoder[13:11] == 3'd2;
+ assign cond_103 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd4;
+ assign cond_104 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h00 && decoder[13:11] == 3'd5;
+ assign cond_105 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h02;
+ assign cond_106 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h03;
+ assign cond_107 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'hAA;
+ assign cond_108 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'h6C;
+ assign cond_109 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'h6E;
+ assign cond_110 = dec_ready_one && decoder[7:0] == 8'h9C;
+ assign cond_111 = dec_ready_call_jmp_imm && (decoder[7:0] == 8'hEA || decoder[7:0] == 8'hE9 || decoder[7:0] == 8'hEB);
+ assign cond_112 = decoder[3:0] == 4'hB;
+ assign cond_113 = dec_ready_modregrm_one && decoder[7:0] == 8'hFF && (decoder[13:11] == 3'd4 || decoder[13:11] == 3'd5);
+ assign cond_114 = prefix_group_1_lock  || (decoder[13:11] == 3'd5 && `DEC_MODREGRM_IS_MOD_11);
+ assign cond_115 = (dec_ready_one && { decoder[7:1], 1'b0 } == 8'hEE) || (dec_ready_one_one && { decoder[7:1], 1'b0 } == 8'hE6);
+ assign cond_116 = dec_ready_mem_offset && { decoder[7:2], 2'b0 } == 8'hA0;
+ assign cond_117 = dec_ready_one_imm && decoder[7:4] == 4'hB;
+ assign cond_118 = decoder[3] == 1'b0;
+ assign cond_119 = dec_ready_modregrm_one && { decoder[7:2], 2'b0 } == 8'h88;
+ assign cond_120 = dec_ready_modregrm_imm && { decoder[7:1], 1'b0 } == 8'hC6 && decoder[13:11] == 3'd0;
+ assign cond_121 = dec_ready_one && decoder[7:0] == 8'h9F;
+ assign cond_122 = dec_ready_one && decoder[7:0] == 8'h98;
+ assign cond_123 = dec_ready_one && decoder[7:0] == 8'h99;
+ assign cond_124 = dec_ready_one && decoder[7:0] == 8'h9D;
+ assign cond_125 = dec_ready_one && decoder[7:0] == 8'hFA;
+ assign cond_126 = dec_ready_one && decoder[7:0] == 8'hFB;
+ assign cond_127 = dec_ready_modregrm_one && decoder[7:0] == 8'h62;
+ assign cond_128 = dec_ready_one && decoder[7:0] == 8'hD6;
+ assign cond_129 = dec_ready_modregrm_one && decoder[7:0] == 8'h8D;
+ assign cond_130 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd0;
+ assign cond_131 = dec_ready_2byte_modregrm && decoder[7:0] == 8'h01 && decoder[13:11] == 3'd1;
+ assign cond_132 = dec_ready_one && { decoder[7:1], 1'b0 } == 8'hA4;
+ assign cond_133 = dec_ready_2byte_modregrm && { decoder[7:1], 1'b0 } == 8'hB6;
+ assign cond_134 = dec_ready_2byte_modregrm && { decoder[7:1], 1'b0 } == 8'hBE;
+ assign cond_135 = dec_ready_one && decoder[7:0] == 8'h61;
+ assign cond_136 = dec_ready_2byte_modregrm && { decoder[7:2], 1'b0, decoder[0] } == 8'h21;
+ assign cond_137 = dec_ready_one && decoder[7:0] == 8'hD7;
+ assign cond_138 = dec_ready_one && decoder[7:0] == 8'h37;
+ assign cond_139 = dec_ready_one && decoder[7:0] == 8'h3F;
+ assign cond_140 = dec_ready_one && decoder[7:0] == 8'h27;
+ assign cond_141 = dec_ready_one && decoder[7:0] == 8'h2F;
+ assign cond_142 = dec_ready_2byte_modregrm && decoder[7:0] == 8'hBC;
+ assign cond_143 = dec_ready_2byte_modregrm && decoder[7:0] == 8'hBD;
+//======================================================== saves
+//======================================================== always
+//======================================================== sets
+assign consume_mem_offset =
+    (cond_116 && ~cond_4)? (`TRUE) :
+    1'd0;
+assign dec_cmd =
+    (cond_0 && ~cond_1)? ( `CMD_XADD) :
+    (cond_3 && ~cond_4)? ( `CMD_JCXZ) :
+    (cond_5 && ~cond_4)? ( `CMD_CALL) :
+    (cond_7 && ~cond_8)? ( `CMD_CALL) :
+    (cond_10 && ~cond_4)? ( `CMD_PUSH_MOV_SEG) :
+    (cond_11 && ~cond_12)? ( `CMD_PUSH_MOV_SEG) :
+    (cond_13 && ~cond_14)? ( `CMD_PUSH_MOV_SEG) :
+    (cond_15 && ~cond_14)? ( `CMD_PUSH_MOV_SEG) :
+    (cond_16 && ~cond_1)? ( `CMD_NEG) :
+    (cond_17 && ~cond_4)? ( `CMD_Jcc) :
+    (cond_20 && ~cond_4)? ( `CMD_INVD) :
+    (cond_21 && ~cond_22)? ( `CMD_INVLPG) :
+    (cond_23 && ~cond_4)? ( `CMD_HLT) :
+    (cond_24 && ~cond_4)? ( `CMD_SCAS) :
+    (cond_26 && ~cond_4)? ( `CMD_INC_DEC) :
+    (cond_27 && ~cond_1)? ( `CMD_INC_DEC) :
+    (cond_28 && ~cond_4)? ( `CMD_RET_near) :
+    (cond_29 && ~cond_14)? ( `CMD_ARPL) :
+    (cond_30 && ~cond_4)? ( `CMD_BSWAP) :
+    (cond_31 && ~cond_22)? ( `CMD_LxS) :
+    (cond_32 && ~cond_33)? ( `CMD_MOV_to_seg) :
+    (cond_34 && ~cond_14)? ( `CMD_LLDT) :
+    (cond_35 && ~cond_14)? ( `CMD_LTR) :
+    (cond_36 && ~cond_4)? ( `CMD_CLC) :
+    (cond_37 && ~cond_4)? ( `CMD_CLD) :
+    (cond_38 && ~cond_4)? ( `CMD_CMC) :
+    (cond_39 && ~cond_4)? ( `CMD_STC) :
+    (cond_40 && ~cond_4)? ( `CMD_STD) :
+    (cond_41 && ~cond_4)? ( `CMD_SAHF) :
+    (cond_42 && ~cond_4)? ( `CMD_AAD) :
+    (cond_43 && ~cond_4)? ( `CMD_AAM) :
+    (cond_44 && ~cond_4)? ( `CMD_POP_seg) :
+    (cond_45 && ~cond_4)? ( `CMD_BT) :
+    (cond_46 && ~cond_1)? ( `CMD_BTR) :
+    (cond_47 && ~cond_1)? ( `CMD_BTS) :
+    (cond_48 && ~cond_1)? ( `CMD_BTC) :
+    (cond_49 && ~cond_4)? ( `CMD_IRET) :
+    (cond_51 && ~cond_4)? ( `CMD_POP) :
+    (cond_52 && ~cond_4)? ( `CMD_POP) :
+    (cond_53 && ~cond_4)? ( `CMD_DIV) :
+    (cond_54 && ~cond_4)? ( `CMD_IDIV) :
+    (cond_55 && ~cond_4)? ( `CMD_Shift) :
+    (cond_57 && ~cond_4)? ( `CMD_Shift) :
+    (cond_58 && ~cond_4)? ( `CMD_CMPS) :
+    (cond_59 && ~cond_4)? ( `CMD_control_reg) :
+    (cond_60 && ~cond_4)? ( `CMD_control_reg) :
+    (cond_61 && ~cond_62)? ( `CMD_control_reg) :
+    (cond_63 && ~cond_22)? ( `CMD_LGDT) :
+    (cond_64 && ~cond_22)? ( `CMD_LIDT) :
+    (cond_65 && ~cond_4)? ( `CMD_PUSHA) :
+    (cond_66 && ~cond_4)? ( `CMD_fpu) :
+    (cond_67 && ~cond_4)? ( `CMD_fpu) :
+    (cond_68 && ~cond_4)? ( `CMD_SETcc) :
+    (cond_69 && ~cond_1)? ( `CMD_CMPXCHG) :
+    (cond_70 && ~cond_4)? ( `CMD_ENTER) :
+    (cond_71 && ~cond_4)? ( `CMD_IMUL) :
+    (cond_72 && ~cond_4)? ( `CMD_IMUL) :
+    (cond_73 && ~cond_4)? ( `CMD_LEAVE) :
+    (cond_74 && ~cond_4)? ( `CMD_SHLD) :
+    (cond_76 && ~cond_4)? ( `CMD_SHRD) :
+    (cond_77 && ~cond_4)? ( `CMD_WBINVD) :
+    (cond_78 && ~cond_4)? ( {`CMD_Arith | { 4'd0, decoder[5:3] } }) :
+    (cond_79 && ~cond_80)? ( {`CMD_Arith | { 4'd0, decoder[5:3] } }) :
+    (cond_81 && ~cond_82)? ( {`CMD_Arith | { 4'd0, decoder[13:11] } }) :
+    (cond_83 && ~cond_4)? ( `CMD_MUL) :
+    (cond_84 && ~cond_4)? ( `CMD_LOOP) :
+    (cond_85 && ~cond_4)? ( `CMD_TEST) :
+    (cond_86 && ~cond_4)? ( `CMD_TEST) :
+    (cond_87 && ~cond_4)? ( `CMD_TEST) :
+    (cond_88 && ~cond_4)? ( `CMD_CLTS) :
+    (cond_89 && ~cond_4)? ( `CMD_RET_far) :
+    (cond_90 && ~cond_4)? ( `CMD_LODS) :
+    (cond_91 && ~cond_4)? ( `CMD_XCHG) :
+    (cond_92 && ~cond_1)? ( `CMD_XCHG) :
+    (cond_93 && ~cond_4)? ( `CMD_PUSH) :
+    (cond_94 && ~cond_4)? ( `CMD_PUSH) :
+    (cond_95 && ~cond_4)? ( `CMD_PUSH) :
+    (cond_96 && ~cond_4)? ( `CMD_INT_INTO) :
+    (cond_98 && ~cond_4)? ( `CMD_CPUID) :
+    (cond_99 && ~cond_4)? ( `CMD_IN) :
+    (cond_102 && ~cond_1)? ( `CMD_NOT) :
+    (cond_103 && ~cond_14)? ( `CMD_VERR) :
+    (cond_104 && ~cond_14)? ( `CMD_VERW) :
+    (cond_105 && ~cond_14)? ( `CMD_LAR) :
+    (cond_106 && ~cond_14)? ( `CMD_LSL) :
+    (cond_107 && ~cond_4)? ( `CMD_STOS) :
+    (cond_108 && ~cond_4)? ( `CMD_INS) :
+    (cond_109 && ~cond_4)? ( `CMD_OUTS) :
+    (cond_110 && ~cond_4)? ( `CMD_PUSHF) :
+    (cond_111 && ~cond_4)? ( `CMD_JMP) :
+    (cond_113 && ~cond_114)? ( `CMD_JMP) :
+    (cond_115 && ~cond_4)? ( `CMD_OUT) :
+    (cond_116 && ~cond_4)? ( `CMD_MOV) :
+    (cond_117 && ~cond_4)? ( `CMD_MOV) :
+    (cond_119 && ~cond_4)? ( `CMD_MOV) :
+    (cond_120 && ~cond_4)? ( `CMD_MOV) :
+    (cond_121 && ~cond_4)? ( `CMD_LAHF) :
+    (cond_122 && ~cond_4)? ( `CMD_CBW) :
+    (cond_123 && ~cond_4)? ( `CMD_CWD) :
+    (cond_124 && ~cond_4)? ( `CMD_POPF) :
+    (cond_125 && ~cond_4)? ( `CMD_CLI) :
+    (cond_126 && ~cond_4)? ( `CMD_STI) :
+    (cond_127 && ~cond_22)? ( `CMD_BOUND) :
+    (cond_128 && ~cond_4)? ( `CMD_SALC) :
+    (cond_129 && ~cond_22)? ( `CMD_LEA) :
+    (cond_130 && ~cond_22)? ( `CMD_SGDT) :
+    (cond_131 && ~cond_22)? ( `CMD_SIDT) :
+    (cond_132 && ~cond_4)? ( `CMD_MOVS) :
+    (cond_133 && ~cond_4)? ( `CMD_MOVZX) :
+    (cond_134 && ~cond_4)? ( `CMD_MOVSX) :
+    (cond_135 && ~cond_4)? ( `CMD_POPA) :
+    (cond_136 && ~cond_4)? ( `CMD_debug_reg) :
+    (cond_137 && ~cond_4)? ( `CMD_XLAT) :
+    (cond_138 && ~cond_4)? ( `CMD_AAA) :
+    (cond_139 && ~cond_4)? ( `CMD_AAS) :
+    (cond_140 && ~cond_4)? ( `CMD_DAA) :
+    (cond_141 && ~cond_4)? ( `CMD_DAS) :
+    (cond_142 && ~cond_4)? ( `CMD_BSF) :
+    (cond_143 && ~cond_4)? ( `CMD_BSR) :
+    7'd0;
+assign dec_is_complex =
+    (cond_0 && ~cond_1)? (`TRUE) :
+    (cond_5 && ~cond_4)? (`TRUE) :
+    (cond_7 && ~cond_8)? (`TRUE) :
+    (cond_20 && ~cond_4)? (`TRUE) :
+    (cond_21 && ~cond_22)? (`TRUE) :
+    (cond_23 && ~cond_4)? (`TRUE) :
+    (cond_24 && ~cond_4 && cond_25)? (`TRUE) :
+    (cond_28 && ~cond_4)? (`TRUE) :
+    (cond_31 && ~cond_22)? (`TRUE) :
+    (cond_32 && ~cond_33)? (`TRUE) :
+    (cond_34 && ~cond_14)? (`TRUE) :
+    (cond_35 && ~cond_14)? (`TRUE) :
+    (cond_44 && ~cond_4)? (`TRUE) :
+    (cond_49 && ~cond_4)? (`TRUE) :
+    (cond_52 && ~cond_4)? (`TRUE) :
+    (cond_58 && ~cond_4)? (`TRUE) :
+    (cond_60 && ~cond_4)? (`TRUE) :
+    (cond_61 && ~cond_62 && cond_56)? (`TRUE) :
+    (cond_63 && ~cond_22)? (`TRUE) :
+    (cond_64 && ~cond_22)? (`TRUE) :
+    (cond_65 && ~cond_4)? (`TRUE) :
+    (cond_70 && ~cond_4)? (`TRUE) :
+    (cond_77 && ~cond_4)? (`TRUE) :
+    (cond_88 && ~cond_4)? (`TRUE) :
+    (cond_89 && ~cond_4)? (`TRUE) :
+    (cond_90 && ~cond_4 && cond_25)? (`TRUE) :
+    (cond_92 && ~cond_1)? (`TRUE) :
+    (cond_96 && ~cond_4)? (`TRUE) :
+    (cond_98 && ~cond_4)? (`TRUE) :
+    (cond_99 && ~cond_4)? (`TRUE) :
+    (cond_103 && ~cond_14)? (`TRUE) :
+    (cond_104 && ~cond_14)? (`TRUE) :
+    (cond_105 && ~cond_14)? (`TRUE) :
+    (cond_106 && ~cond_14)? (`TRUE) :
+    (cond_107 && ~cond_4 && cond_25)? (`TRUE) :
+    (cond_108 && ~cond_4)? (`TRUE) :
+    (cond_109 && ~cond_4)? (`TRUE) :
+    (cond_111 && ~cond_4)? (`TRUE) :
+    (cond_113 && ~cond_114)? (`TRUE) :
+    (cond_115 && ~cond_4)? (`TRUE) :
+    (cond_124 && ~cond_4)? (`TRUE) :
+    (cond_127 && ~cond_22)? (`TRUE) :
+    (cond_130 && ~cond_22)? (`TRUE) :
+    (cond_131 && ~cond_22)? (`TRUE) :
+    (cond_132 && ~cond_4 && cond_25)? (`TRUE) :
+    (cond_135 && ~cond_4)? (`TRUE) :
+    (cond_136 && ~cond_4 && cond_56)? (`TRUE) :
+    1'd0;
+assign consume_one_two =
+    (cond_28 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_89 && ~cond_4 && cond_2)? (`TRUE) :
+    1'd0;
+assign consume_modregrm_imm =
+    (cond_45 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_46 && ~cond_1 && cond_2)? (`TRUE) :
+    (cond_47 && ~cond_1 && cond_2)? (`TRUE) :
+    (cond_48 && ~cond_1 && cond_2)? (`TRUE) :
+    (cond_57 && ~cond_4)? (`TRUE) :
+    (cond_72 && ~cond_4)? (`TRUE) :
+    (cond_74 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_76 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_81 && ~cond_82)? (`TRUE) :
+    (cond_87 && ~cond_4)? (`TRUE) :
+    (cond_120 && ~cond_4)? (`TRUE) :
+    1'd0;
+assign consume_one =
+    (cond_10 && ~cond_4)? (`TRUE) :
+    (cond_20 && ~cond_4)? (`TRUE) :
+    (cond_23 && ~cond_4)? (`TRUE) :
+    (cond_24 && ~cond_4)? (`TRUE) :
+    (cond_26 && ~cond_4)? (`TRUE) :
+    (cond_28 && ~cond_4 && ~cond_2)? (`TRUE) :
+    (cond_30 && ~cond_4)? (`TRUE) :
+    (cond_36 && ~cond_4)? (`TRUE) :
+    (cond_37 && ~cond_4)? (`TRUE) :
+    (cond_38 && ~cond_4)? (`TRUE) :
+    (cond_39 && ~cond_4)? (`TRUE) :
+    (cond_40 && ~cond_4)? (`TRUE) :
+    (cond_41 && ~cond_4)? (`TRUE) :
+    (cond_44 && ~cond_4)? (`TRUE) :
+    (cond_49 && ~cond_4)? (`TRUE) :
+    (cond_51 && ~cond_4)? (`TRUE) :
+    (cond_58 && ~cond_4)? (`TRUE) :
+    (cond_65 && ~cond_4)? (`TRUE) :
+    (cond_66 && ~cond_4)? (`TRUE) :
+    (cond_73 && ~cond_4)? (`TRUE) :
+    (cond_77 && ~cond_4)? (`TRUE) :
+    (cond_88 && ~cond_4)? (`TRUE) :
+    (cond_89 && ~cond_4 && ~cond_2)? (`TRUE) :
+    (cond_90 && ~cond_4)? (`TRUE) :
+    (cond_91 && ~cond_4)? (`TRUE) :
+    (cond_93 && ~cond_4)? (`TRUE) :
+    (cond_96 && ~cond_4 && cond_97)? (`TRUE) :
+    (cond_98 && ~cond_4)? (`TRUE) :
+    (cond_99 && ~cond_4 && cond_101)? (`TRUE) :
+    (cond_107 && ~cond_4)? (`TRUE) :
+    (cond_108 && ~cond_4)? (`TRUE) :
+    (cond_109 && ~cond_4)? (`TRUE) :
+    (cond_110 && ~cond_4)? (`TRUE) :
+    (cond_115 && ~cond_4 && cond_101)? (`TRUE) :
+    (cond_121 && ~cond_4)? (`TRUE) :
+    (cond_122 && ~cond_4)? (`TRUE) :
+    (cond_123 && ~cond_4)? (`TRUE) :
+    (cond_124 && ~cond_4)? (`TRUE) :
+    (cond_125 && ~cond_4)? (`TRUE) :
+    (cond_126 && ~cond_4)? (`TRUE) :
+    (cond_128 && ~cond_4)? (`TRUE) :
+    (cond_132 && ~cond_4)? (`TRUE) :
+    (cond_135 && ~cond_4)? (`TRUE) :
+    (cond_137 && ~cond_4)? (`TRUE) :
+    (cond_138 && ~cond_4)? (`TRUE) :
+    (cond_139 && ~cond_4)? (`TRUE) :
+    (cond_140 && ~cond_4)? (`TRUE) :
+    (cond_141 && ~cond_4)? (`TRUE) :
+    1'd0;
+assign consume_one_one =
+    (cond_3 && ~cond_4)? (`TRUE) :
+    (cond_17 && ~cond_4 && ~cond_19)? (`TRUE) :
+    (cond_42 && ~cond_4)? (`TRUE) :
+    (cond_43 && ~cond_4)? (`TRUE) :
+    (cond_84 && ~cond_4)? (`TRUE) :
+    (cond_96 && ~cond_4 && ~cond_97)? (`TRUE) :
+    (cond_99 && ~cond_4 && ~cond_101)? (`TRUE) :
+    (cond_115 && ~cond_4 && ~cond_101)? (`TRUE) :
+    1'd0;
+assign exception_ud =
+    (cond_0 && cond_1)? (`TRUE) :
+    (cond_3 && cond_4)? (`TRUE) :
+    (cond_5 && cond_4)? (`TRUE) :
+    (cond_7 && cond_8)? (`TRUE) :
+    (cond_10 && cond_4)? (`TRUE) :
+    (cond_11 && cond_12)? (`TRUE) :
+    (cond_13 && cond_14)? (`TRUE) :
+    (cond_15 && cond_14)? (`TRUE) :
+    (cond_16 && cond_1)? (`TRUE) :
+    (cond_17 && cond_4)? (`TRUE) :
+    (cond_20 && cond_4)? (`TRUE) :
+    (cond_21 && cond_22)? (`TRUE) :
+    (cond_23 && cond_4)? (`TRUE) :
+    (cond_24 && cond_4)? (`TRUE) :
+    (cond_26 && cond_4)? (`TRUE) :
+    (cond_27 && cond_1)? (`TRUE) :
+    (cond_28 && cond_4)? (`TRUE) :
+    (cond_29 && cond_14)? (`TRUE) :
+    (cond_30 && cond_4)? (`TRUE) :
+    (cond_31 && cond_22)? (`TRUE) :
+    (cond_32 && cond_33)? (`TRUE) :
+    (cond_34 && cond_14)? (`TRUE) :
+    (cond_35 && cond_14)? (`TRUE) :
+    (cond_36 && cond_4)? (`TRUE) :
+    (cond_37 && cond_4)? (`TRUE) :
+    (cond_38 && cond_4)? (`TRUE) :
+    (cond_39 && cond_4)? (`TRUE) :
+    (cond_40 && cond_4)? (`TRUE) :
+    (cond_41 && cond_4)? (`TRUE) :
+    (cond_42 && cond_4)? (`TRUE) :
+    (cond_43 && cond_4)? (`TRUE) :
+    (cond_44 && cond_4)? (`TRUE) :
+    (cond_45 && cond_4)? (`TRUE) :
+    (cond_46 && cond_1)? (`TRUE) :
+    (cond_47 && cond_1)? (`TRUE) :
+    (cond_48 && cond_1)? (`TRUE) :
+    (cond_49 && cond_4)? (`TRUE) :
+    (cond_51 && cond_4)? (`TRUE) :
+    (cond_52 && cond_4)? (`TRUE) :
+    (cond_53 && cond_4)? (`TRUE) :
+    (cond_54 && cond_4)? (`TRUE) :
+    (cond_55 && cond_4)? (`TRUE) :
+    (cond_57 && cond_4)? (`TRUE) :
+    (cond_58 && cond_4)? (`TRUE) :
+    (cond_59 && cond_4)? (`TRUE) :
+    (cond_60 && cond_4)? (`TRUE) :
+    (cond_61 && cond_62)? (`TRUE) :
+    (cond_63 && cond_22)? (`TRUE) :
+    (cond_64 && cond_22)? (`TRUE) :
+    (cond_65 && cond_4)? (`TRUE) :
+    (cond_66 && cond_4)? (`TRUE) :
+    (cond_67 && cond_4)? (`TRUE) :
+    (cond_68 && cond_4)? (`TRUE) :
+    (cond_69 && cond_1)? (`TRUE) :
+    (cond_70 && cond_4)? (`TRUE) :
+    (cond_71 && cond_4)? (`TRUE) :
+    (cond_72 && cond_4)? (`TRUE) :
+    (cond_73 && cond_4)? (`TRUE) :
+    (cond_74 && cond_4)? (`TRUE) :
+    (cond_76 && cond_4)? (`TRUE) :
+    (cond_77 && cond_4)? (`TRUE) :
+    (cond_78 && cond_4)? (`TRUE) :
+    (cond_79 && cond_80)? (`TRUE) :
+    (cond_81 && cond_82)? (`TRUE) :
+    (cond_83 && cond_4)? (`TRUE) :
+    (cond_84 && cond_4)? (`TRUE) :
+    (cond_85 && cond_4)? (`TRUE) :
+    (cond_86 && cond_4)? (`TRUE) :
+    (cond_87 && cond_4)? (`TRUE) :
+    (cond_88 && cond_4)? (`TRUE) :
+    (cond_89 && cond_4)? (`TRUE) :
+    (cond_90 && cond_4)? (`TRUE) :
+    (cond_91 && cond_4)? (`TRUE) :
+    (cond_92 && cond_1)? (`TRUE) :
+    (cond_93 && cond_4)? (`TRUE) :
+    (cond_94 && cond_4)? (`TRUE) :
+    (cond_95 && cond_4)? (`TRUE) :
+    (cond_96 && cond_4)? (`TRUE) :
+    (cond_98 && cond_4)? (`TRUE) :
+    (cond_99 && cond_4)? (`TRUE) :
+    (cond_102 && cond_1)? (`TRUE) :
+    (cond_103 && cond_14)? (`TRUE) :
+    (cond_104 && cond_14)? (`TRUE) :
+    (cond_105 && cond_14)? (`TRUE) :
+    (cond_106 && cond_14)? (`TRUE) :
+    (cond_107 && cond_4)? (`TRUE) :
+    (cond_108 && cond_4)? (`TRUE) :
+    (cond_109 && cond_4)? (`TRUE) :
+    (cond_110 && cond_4)? (`TRUE) :
+    (cond_111 && cond_4)? (`TRUE) :
+    (cond_113 && cond_114)? (`TRUE) :
+    (cond_115 && cond_4)? (`TRUE) :
+    (cond_116 && cond_4)? (`TRUE) :
+    (cond_117 && cond_4)? (`TRUE) :
+    (cond_119 && cond_4)? (`TRUE) :
+    (cond_120 && cond_4)? (`TRUE) :
+    (cond_121 && cond_4)? (`TRUE) :
+    (cond_122 && cond_4)? (`TRUE) :
+    (cond_123 && cond_4)? (`TRUE) :
+    (cond_124 && cond_4)? (`TRUE) :
+    (cond_125 && cond_4)? (`TRUE) :
+    (cond_126 && cond_4)? (`TRUE) :
+    (cond_127 && cond_22)? (`TRUE) :
+    (cond_128 && cond_4)? (`TRUE) :
+    (cond_129 && cond_22)? (`TRUE) :
+    (cond_130 && cond_22)? (`TRUE) :
+    (cond_131 && cond_22)? (`TRUE) :
+    (cond_132 && cond_4)? (`TRUE) :
+    (cond_133 && cond_4)? (`TRUE) :
+    (cond_134 && cond_4)? (`TRUE) :
+    (cond_135 && cond_4)? (`TRUE) :
+    (cond_136 && cond_4)? (`TRUE) :
+    (cond_137 && cond_4)? (`TRUE) :
+    (cond_138 && cond_4)? (`TRUE) :
+    (cond_139 && cond_4)? (`TRUE) :
+    (cond_140 && cond_4)? (`TRUE) :
+    (cond_141 && cond_4)? (`TRUE) :
+    (cond_142 && cond_4)? (`TRUE) :
+    (cond_143 && cond_4)? (`TRUE) :
+    1'd0;
+assign consume_one_imm =
+    (cond_17 && ~cond_4 && cond_19)? (`TRUE) :
+    (cond_78 && ~cond_4)? (`TRUE) :
+    (cond_85 && ~cond_4)? (`TRUE) :
+    (cond_94 && ~cond_4)? (`TRUE) :
+    (cond_117 && ~cond_4)? (`TRUE) :
+    1'd0;
+assign consume_call_jmp_imm =
+    (cond_5 && ~cond_4)? (`TRUE) :
+    (cond_111 && ~cond_4)? (`TRUE) :
+    1'd0;
+assign consume_modregrm_one =
+    (cond_0 && ~cond_1)? (`TRUE) :
+    (cond_7 && ~cond_8)? (`TRUE) :
+    (cond_11 && ~cond_12)? (`TRUE) :
+    (cond_13 && ~cond_14)? (`TRUE) :
+    (cond_15 && ~cond_14)? (`TRUE) :
+    (cond_16 && ~cond_1)? (`TRUE) :
+    (cond_21 && ~cond_22)? (`TRUE) :
+    (cond_27 && ~cond_1)? (`TRUE) :
+    (cond_29 && ~cond_14)? (`TRUE) :
+    (cond_31 && ~cond_22)? (`TRUE) :
+    (cond_32 && ~cond_33)? (`TRUE) :
+    (cond_34 && ~cond_14)? (`TRUE) :
+    (cond_35 && ~cond_14)? (`TRUE) :
+    (cond_45 && ~cond_4 && ~cond_2)? (`TRUE) :
+    (cond_46 && ~cond_1 && ~cond_2)? (`TRUE) :
+    (cond_47 && ~cond_1 && ~cond_2)? (`TRUE) :
+    (cond_48 && ~cond_1 && ~cond_2)? (`TRUE) :
+    (cond_52 && ~cond_4)? (`TRUE) :
+    (cond_53 && ~cond_4)? (`TRUE) :
+    (cond_54 && ~cond_4)? (`TRUE) :
+    (cond_55 && ~cond_4)? (`TRUE) :
+    (cond_59 && ~cond_4)? (`TRUE) :
+    (cond_60 && ~cond_4)? (`TRUE) :
+    (cond_61 && ~cond_62)? (`TRUE) :
+    (cond_63 && ~cond_22)? (`TRUE) :
+    (cond_64 && ~cond_22)? (`TRUE) :
+    (cond_67 && ~cond_4)? (`TRUE) :
+    (cond_68 && ~cond_4)? (`TRUE) :
+    (cond_69 && ~cond_1)? (`TRUE) :
+    (cond_71 && ~cond_4)? (`TRUE) :
+    (cond_74 && ~cond_4 && ~cond_2)? (`TRUE) :
+    (cond_76 && ~cond_4 && ~cond_2)? (`TRUE) :
+    (cond_79 && ~cond_80)? (`TRUE) :
+    (cond_83 && ~cond_4)? (`TRUE) :
+    (cond_86 && ~cond_4)? (`TRUE) :
+    (cond_92 && ~cond_1)? (`TRUE) :
+    (cond_95 && ~cond_4)? (`TRUE) :
+    (cond_102 && ~cond_1)? (`TRUE) :
+    (cond_103 && ~cond_14)? (`TRUE) :
+    (cond_104 && ~cond_14)? (`TRUE) :
+    (cond_105 && ~cond_14)? (`TRUE) :
+    (cond_106 && ~cond_14)? (`TRUE) :
+    (cond_113 && ~cond_114)? (`TRUE) :
+    (cond_119 && ~cond_4)? (`TRUE) :
+    (cond_127 && ~cond_22)? (`TRUE) :
+    (cond_129 && ~cond_22)? (`TRUE) :
+    (cond_130 && ~cond_22)? (`TRUE) :
+    (cond_131 && ~cond_22)? (`TRUE) :
+    (cond_133 && ~cond_4)? (`TRUE) :
+    (cond_134 && ~cond_4)? (`TRUE) :
+    (cond_136 && ~cond_4)? (`TRUE) :
+    (cond_142 && ~cond_4)? (`TRUE) :
+    (cond_143 && ~cond_4)? (`TRUE) :
+    1'd0;
+assign consume_one_three =
+    (cond_70 && ~cond_4)? (`TRUE) :
+    1'd0;
+assign dec_is_8bit =
+    (cond_0 && ~cond_1 && cond_2)? (`TRUE) :
+    (cond_3 && ~cond_4)? (`TRUE) :
+    (cond_16 && ~cond_1 && cond_2)? (`TRUE) :
+    (cond_17 && ~cond_4 && cond_18)? (`TRUE) :
+    (cond_24 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_27 && ~cond_1 && cond_2)? (`TRUE) :
+    (cond_42 && ~cond_4)? (`TRUE) :
+    (cond_43 && ~cond_4)? (`TRUE) :
+    (cond_53 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_54 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_55 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_57 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_58 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_68 && ~cond_4)? (`TRUE) :
+    (cond_69 && ~cond_1 && cond_2)? (`TRUE) :
+    (cond_71 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_78 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_79 && ~cond_80 && cond_2)? (`TRUE) :
+    (cond_81 && ~cond_82 && cond_2)? (`TRUE) :
+    (cond_83 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_84 && ~cond_4)? (`TRUE) :
+    (cond_85 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_86 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_87 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_90 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_92 && ~cond_1 && cond_2)? (`TRUE) :
+    (cond_99 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_102 && ~cond_1 && cond_2)? (`TRUE) :
+    (cond_107 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_108 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_109 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_111 && ~cond_4 && cond_112)? (`TRUE) :
+    (cond_115 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_116 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_117 && ~cond_4 && cond_118)? (`TRUE) :
+    (cond_119 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_120 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_132 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_133 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_134 && ~cond_4 && cond_2)? (`TRUE) :
+    (cond_137 && ~cond_4)? (`TRUE) :
+    (cond_138 && ~cond_4)? (`TRUE) :
+    (cond_139 && ~cond_4)? (`TRUE) :
+    (cond_140 && ~cond_4)? (`TRUE) :
+    (cond_141 && ~cond_4)? (`TRUE) :
+    1'd0;
+assign dec_cmdex =
+    (cond_5 && ~cond_4 && cond_6)? ( `CMDEX_CALL_Jv_STEP_0) :
+    (cond_5 && ~cond_4 && ~cond_6)? ( `CMDEX_CALL_Ap_STEP_0) :
+    (cond_7 && ~cond_8 && cond_9)? ( `CMDEX_CALL_Ev_STEP_0) :
+    (cond_7 && ~cond_8 && ~cond_9)? ( `CMDEX_CALL_Ep_STEP_0) :
+    (cond_10 && ~cond_4)? ( `CMDEX_PUSH_MOV_SEG_implicit | { 1'b0, decoder[5:3] }) :
+    (cond_11 && ~cond_12)? ( `CMDEX_PUSH_MOV_SEG_modregrm | { 1'b0, decoder[13:11] }) :
+    (cond_13 && ~cond_14)? ( `CMDEX_PUSH_MOV_SEG_modregrm_LDT) :
+    (cond_15 && ~cond_14)? ( `CMDEX_PUSH_MOV_SEG_modregrm_TR) :
+    (cond_20 && ~cond_4)? ( `CMDEX_INVD_STEP_0) :
+    (cond_21 && ~cond_22)? ( `CMDEX_INVLPG_STEP_0) :
+    (cond_23 && ~cond_4)? ( `CMDEX_HLT_STEP_0) :
+    (cond_24 && ~cond_4)? ( `CMDEX_SCAS_STEP_0) :
+    (cond_26 && ~cond_4)? ( `CMDEX_INC_DEC_increment_implicit | { 3'd0, decoder[3] }) :
+    (cond_27 && ~cond_1)? ( `CMDEX_INC_DEC_increment_modregrm | { 3'd0, decoder[11] }) :
+    (cond_28 && ~cond_4 && cond_2)? ( `CMDEX_RET_near_imm) :
+    (cond_28 && ~cond_4 && ~cond_2)? ( `CMDEX_RET_near) :
+    (cond_31 && ~cond_22)? ( `CMDEX_LxS_STEP_1) :
+    (cond_32 && ~cond_33)? ( `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1) :
+    (cond_34 && ~cond_14)? ( `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1) :
+    (cond_35 && ~cond_14)? ( `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1) :
+    (cond_44 && ~cond_4)? ( `CMDEX_POP_seg_STEP_1) :
+    (cond_45 && ~cond_4 && cond_2)? ( `CMDEX_BTx_modregrm_imm) :
+    (cond_45 && ~cond_4 && ~cond_2)? ( `CMDEX_BTx_modregrm) :
+    (cond_46 && ~cond_1 && cond_2)? ( `CMDEX_BTx_modregrm_imm) :
+    (cond_46 && ~cond_1 && ~cond_2)? ( `CMDEX_BTx_modregrm) :
+    (cond_47 && ~cond_1 && cond_2)? ( `CMDEX_BTx_modregrm_imm) :
+    (cond_47 && ~cond_1 && ~cond_2)? ( `CMDEX_BTx_modregrm) :
+    (cond_48 && ~cond_1 && cond_2)? ( `CMDEX_BTx_modregrm_imm) :
+    (cond_48 && ~cond_1 && ~cond_2)? ( `CMDEX_BTx_modregrm) :
+    (cond_49 && ~cond_4 && cond_50)? ( `CMDEX_IRET_real_v86_STEP_0) :
+    (cond_49 && ~cond_4 && ~cond_50)? ( `CMDEX_IRET_protected_STEP_0) :
+    (cond_51 && ~cond_4)? ( `CMDEX_POP_implicit) :
+    (cond_52 && ~cond_4)? ( `CMDEX_POP_modregrm_STEP_0) :
+    (cond_55 && ~cond_4 && cond_56)? ( `CMDEX_Shift_implicit) :
+    (cond_55 && ~cond_4 && ~cond_56)? ( `CMDEX_Shift_modregrm) :
+    (cond_57 && ~cond_4)? ( `CMDEX_Shift_modregrm_imm) :
+    (cond_58 && ~cond_4)? (`CMDEX_CMPS_FIRST) :
+    (cond_59 && ~cond_4)? ( `CMDEX_control_reg_SMSW_STEP_0) :
+    (cond_60 && ~cond_4)? ( `CMDEX_control_reg_LMSW_STEP_0) :
+    (cond_61 && ~cond_62 && cond_56)? ( `CMDEX_control_reg_MOV_load_STEP_0) :
+    (cond_61 && ~cond_62 && ~cond_56)? ( `CMDEX_control_reg_MOV_store_STEP_0) :
+    (cond_63 && ~cond_22)? ( `CMDEX_LGDT_LIDT_STEP_1) :
+    (cond_64 && ~cond_22)? ( `CMDEX_LGDT_LIDT_STEP_1) :
+    (cond_65 && ~cond_4)? ( `CMDEX_PUSHA_STEP_0) :
+    (cond_66 && ~cond_4)? ( `CMDEX_WAIT_STEP_0) :
+    (cond_67 && ~cond_4)? ( `CMDEX_ESC_STEP_0) :
+    (cond_70 && ~cond_4)? ( `CMDEX_ENTER_FIRST) :
+    (cond_71 && ~cond_4)? ( `CMDEX_IMUL_modregrm) :
+    (cond_72 && ~cond_4)? ( `CMDEX_IMUL_modregrm_imm) :
+    (cond_74 && ~cond_4 && cond_75)? ( `CMDEX_SHxD_implicit) :
+    (cond_74 && ~cond_4 && ~cond_75)? ( `CMDEX_SHxD_modregrm_imm) :
+    (cond_76 && ~cond_4 && cond_75)? ( `CMDEX_SHxD_implicit) :
+    (cond_76 && ~cond_4 && ~cond_75)? ( `CMDEX_SHxD_modregrm_imm) :
+    (cond_77 && ~cond_4)? ( `CMDEX_WBINVD_STEP_0) :
+    (cond_78 && ~cond_4)? ( `CMDEX_Arith_immediate) :
+    (cond_79 && ~cond_80)? ( `CMDEX_Arith_modregrm) :
+    (cond_81 && ~cond_82)? ( `CMDEX_Arith_modregrm_imm) :
+    (cond_84 && ~cond_4)? ( (decoder[1:0] == 2'b00)? `CMDEX_LOOP_NE : (decoder[1:0] == 2'b01)? `CMDEX_LOOP_E : `CMDEX_LOOP) :
+    (cond_85 && ~cond_4)? ( `CMDEX_TEST_immediate) :
+    (cond_86 && ~cond_4)? ( `CMDEX_TEST_modregrm) :
+    (cond_87 && ~cond_4)? ( `CMDEX_TEST_modregrm_imm) :
+    (cond_88 && ~cond_4)? (`CMDEX_CLTS_STEP_FIRST) :
+    (cond_89 && ~cond_4)? ( `CMDEX_RET_far_STEP_1) :
+    (cond_90 && ~cond_4)? ( `CMDEX_LODS_STEP_0) :
+    (cond_91 && ~cond_4)? ( `CMDEX_XCHG_implicit) :
+    (cond_92 && ~cond_1)? ( `CMDEX_XCHG_modregrm) :
+    (cond_93 && ~cond_4)? ( `CMDEX_PUSH_implicit) :
+    (cond_94 && ~cond_4 && cond_56)? ( `CMDEX_PUSH_immediate_se) :
+    (cond_94 && ~cond_4 && ~cond_56)? ( `CMDEX_PUSH_immediate) :
+    (cond_95 && ~cond_4)? ( `CMDEX_PUSH_modregrm) :
+    (cond_96 && ~cond_4)? ( (decoder[2:0] == 3'b100)? `CMDEX_INT_INTO_INT3_STEP_0 : (decoder[2:0] == 3'b101)? `CMDEX_INT_INTO_INT_STEP_0 : (decoder[2:0] == 3'b110)? `CMDEX_INT_INTO_INTO_STEP_0 : `CMDEX_INT_INTO_INT1_STEP_0) :
+    (cond_98 && ~cond_4)? ( `CMDEX_CPUID_STEP_LAST) :
+    (cond_99 && ~cond_4 && cond_100)? ( `CMDEX_IN_dx) :
+    (cond_99 && ~cond_4 && ~cond_100)? ( `CMDEX_IN_imm) :
+    (cond_103 && ~cond_14)? ( `CMDEX_LAR_LSL_VERR_VERW_STEP_1) :
+    (cond_104 && ~cond_14)? ( `CMDEX_LAR_LSL_VERR_VERW_STEP_1) :
+    (cond_105 && ~cond_14)? (`CMDEX_LAR_LSL_VERR_VERW_STEP_1) :
+    (cond_106 && ~cond_14)? ( `CMDEX_LAR_LSL_VERR_VERW_STEP_1) :
+    (cond_107 && ~cond_4)? ( `CMDEX_STOS_STEP_0) :
+    (cond_108 && ~cond_4)? ( `CMDEX_INS_real_1) :
+    (cond_109 && ~cond_4)? ( `CMDEX_OUTS_first) :
+    (cond_111 && ~cond_4 && cond_2)? ( `CMDEX_JMP_Ap_STEP_0) :
+    (cond_111 && ~cond_4 && ~cond_2)? ( `CMDEX_JMP_Jv_STEP_0) :
+    (cond_113 && ~cond_114 && cond_9)? ( `CMDEX_JMP_Ev_STEP_0) :
+    (cond_113 && ~cond_114 && ~cond_9)? ( `CMDEX_JMP_Ep_STEP_0) :
+    (cond_115 && ~cond_4 && cond_100)? ( `CMDEX_OUT_dx) :
+    (cond_115 && ~cond_4 && ~cond_100)? ( `CMDEX_OUT_imm) :
+    (cond_116 && ~cond_4)? ( `CMDEX_MOV_memoffset) :
+    (cond_117 && ~cond_4)? ( `CMDEX_MOV_immediate) :
+    (cond_119 && ~cond_4)? ( `CMDEX_MOV_modregrm) :
+    (cond_120 && ~cond_4)? ( `CMDEX_MOV_modregrm_imm) :
+    (cond_124 && ~cond_4)? ( `CMDEX_POPF_STEP_0) :
+    (cond_127 && ~cond_22)? ( `CMDEX_BOUND_STEP_FIRST) :
+    (cond_128 && ~cond_4)? ( `CMDEX_SALC_STEP_0) :
+    (cond_130 && ~cond_22)? ( `CMDEX_SGDT_SIDT_STEP_1) :
+    (cond_131 && ~cond_22)? ( `CMDEX_SGDT_SIDT_STEP_1) :
+    (cond_132 && ~cond_4)? ( `CMDEX_MOVS_STEP_0) :
+    (cond_135 && ~cond_4)? ( `CMDEX_POPA_STEP_0) :
+    (cond_136 && ~cond_4 && cond_56)? ( `CMDEX_debug_reg_MOV_load_STEP_0) :
+    (cond_136 && ~cond_4 && ~cond_56)? ( `CMDEX_debug_reg_MOV_store_STEP_0) :
+    4'd0;
diff --git a/rtl/ao486/autogen/exception.v b/rtl/ao486/autogen/exception.v
index 1885702..577304c 100644
--- a/rtl/ao486/autogen/exception.v
+++ b/rtl/ao486/autogen/exception.v
@@ -1,60 +1,61 @@
+
 //======================================================== conditions
-wire cond_0 = exception_init || wr_debug_init;
-wire cond_1 = ~(class_trap) && ~(class_abort);
-wire cond_2 = wr_is_esp_speculative;
-wire cond_3 = vector != `EXCEPTION_DB;
-wire cond_4 = vector == `EXCEPTION_DB;
-wire cond_5 = wr_debug_init && ~(wr_string_in_progress_final);
-wire cond_6 = wr_debug_init && wr_string_in_progress_final;
-wire cond_7 = shutdown_start == `FALSE && count > 2'd0 && exception_type != `EXCEPTION_TYPE_DOUBLE_FAULT && (
+ assign cond_0 = exception_init || wr_debug_init;
+ assign cond_1 = ~(class_trap) && ~(class_abort);
+ assign cond_2 = wr_is_esp_speculative;
+ assign cond_3 = vector != `EXCEPTION_DB;
+ assign cond_4 = vector == `EXCEPTION_DB;
+ assign cond_5 = wr_debug_init && ~(wr_string_in_progress_final);
+ assign cond_6 = wr_debug_init && wr_string_in_progress_final;
+ assign cond_7 = shutdown_start == `FALSE && count > 2'd0 && exception_type != `EXCEPTION_TYPE_DOUBLE_FAULT && (
         (last_type == `EXCEPTION_TYPE_CONTRIBUTORY && exception_type == `EXCEPTION_TYPE_CONTRIBUTORY) ||
         (last_type == `EXCEPTION_TYPE_PAGE_FAULT   && exception_type == `EXCEPTION_TYPE_CONTRIBUTORY) ||
         (last_type == `EXCEPTION_TYPE_PAGE_FAULT   && exception_type == `EXCEPTION_TYPE_PAGE_FAULT));
-wire cond_8 = shutdown_start == `FALSE;
-wire cond_9 = shutdown_start;
-wire cond_10 = shutdown;
-wire cond_11 = interrupt_done;
+ assign cond_8 = shutdown_start == `FALSE;
+ assign cond_9 = shutdown_start;
+ assign cond_10 = shutdown;
+ assign cond_11 = interrupt_done;
 //======================================================== saves
-wire  exc_soft_int_to_reg =
+ assign exc_soft_int_to_reg =
     (cond_0 && ~cond_7 && cond_8)? (    `FALSE) :
     (cond_11)? (    `FALSE) :
     exc_soft_int;
-wire  exc_push_error_to_reg =
+ assign exc_push_error_to_reg =
     (cond_0 && ~cond_7 && cond_8)? ( push_error) :
     (cond_11)? ( `FALSE) :
     exc_push_error;
-wire [1:0] count_to_reg =
+ assign count_to_reg =
     (cond_0 && ~cond_7 && cond_8)? (     count + 2'd1) :
     count;
-wire [31:0] exc_eip_to_reg =
+ assign exc_eip_to_reg =
     (cond_0 && ~cond_1)? ( trap_eip) :
     (cond_0 && cond_4 && cond_5)? ( wr_eip) :
     (cond_0 && cond_4 && cond_6)? ( exception_eip_from_wr) :
     (cond_11)? ( (interrupt_string_in_progress)? exception_eip_from_wr : wr_eip) :
     exc_eip;
-wire  external_to_reg =
+ assign external_to_reg =
     (cond_0)? ( `TRUE) :
     (cond_11)? ( `TRUE) :
     external;
-wire [1:0] last_type_to_reg =
+ assign last_type_to_reg =
     (cond_0 && ~cond_7 && cond_8)? ( exception_type) :
     last_type;
-wire [8:0] exc_vector_full_to_reg =
+ assign exc_vector_full_to_reg =
     (cond_0 && cond_7)? ( { 1'b1, `EXCEPTION_DF }) :
     (cond_0 && ~cond_7 && cond_8)? ( { 1'b0, vector }) :
     (cond_0 && cond_9)? ( { 1'b0, vector }) :
     (cond_11)? ( { 1'b0, interrupt_vector }) :
     exc_vector_full;
-wire [15:0] exc_error_code_to_reg =
+ assign exc_error_code_to_reg =
     (cond_0 && cond_7)? ( 16'd0) :
     (cond_0 && ~cond_7 && cond_8)? ( error_code) :
     (cond_11)? ( 16'd0) :
     exc_error_code;
-wire  exc_soft_int_ib_to_reg =
+ assign exc_soft_int_ib_to_reg =
     (cond_0 && ~cond_7 && cond_8)? ( `FALSE) :
     (cond_11)? ( `FALSE) :
     exc_soft_int_ib;
-wire  shutdown_to_reg =
+ assign shutdown_to_reg =
     (cond_0 && cond_9)? ( `TRUE) :
     shutdown;
 //======================================================== always
diff --git a/rtl/ao486/autogen/execute_commands.v b/rtl/ao486/autogen/execute_commands.v
index 0d2a9ab..003c5a7 100644
--- a/rtl/ao486/autogen/execute_commands.v
+++ b/rtl/ao486/autogen/execute_commands.v
@@ -1,94 +1,52 @@
-wire exe_jecxz_condition;
 assign exe_jecxz_condition = (exe_address_16bit)? ecx[15:0] == 16'd0 : ecx == 32'd0;
 
-reg e_invd_code_done;
-reg e_invd_data_done;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0)       e_invd_code_done <= `FALSE; else if(exe_reset)      e_invd_code_done <= `FALSE; else if(exe_ready)      e_invd_code_done <= `FALSE; else if(invdcode_done)  e_invd_code_done <= `TRUE;
+always @(posedge clk) begin if(rst)       e_invd_code_done <= `FALSE; else if(exe_reset)      e_invd_code_done <= `FALSE; else if(exe_ready)      e_invd_code_done <= `FALSE; else if(invdcode_done)  e_invd_code_done <= `TRUE;
 end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0)       e_invd_data_done <= `FALSE; else if(exe_reset)      e_invd_data_done <= `FALSE; else if(exe_ready)      e_invd_data_done <= `FALSE; else if(invddata_done)  e_invd_data_done <= `TRUE;
+always @(posedge clk) begin if(rst)       e_invd_data_done <= `FALSE; else if(exe_reset)      e_invd_data_done <= `FALSE; else if(exe_ready)      e_invd_data_done <= `FALSE; else if(invddata_done)  e_invd_data_done <= `TRUE;
 end
 
-wire [3:0] e_io_allow_bits;
 assign e_io_allow_bits = (glob_param_1[2:0] == 3'd0)?  src[3:0] : (glob_param_1[2:0] == 3'd1)?  src[4:1] : (glob_param_1[2:0] == 3'd2)?  src[5:2] : (glob_param_1[2:0] == 3'd3)?  src[6:3] : (glob_param_1[2:0] == 3'd4)?  src[7:4] : (glob_param_1[2:0] == 3'd5)?  src[8:5] : (glob_param_1[2:0] == 3'd6)?  src[9:6] : src[10:7];
 
-wire exe_int_2_int_trap_same_exception;
 assign exe_int_2_int_trap_same_exception = (v8086_mode && (`DESC_IS_CODE_CONFORMING(exe_descriptor) || exe_descriptor[`DESC_BITS_DPL] != 2'd0));
 
-wire [7:0] e_aad_result;
 assign e_aad_result = mult_result[7:0] + dst[7:0];
 
-wire [1:0] e_cpl_current;
 assign e_cpl_current = (glob_param_1[`MC_PARAM_1_FLAG_CPL_FROM_PARAM_3_BIT])? glob_param_3[`SELECTOR_BITS_RPL] : cpl;
 assign exe_load_seg_gp_fault = exe_cmd == `CMD_load_seg && exe_cmdex == `CMDEX_load_seg_STEP_2 && ( (exe_segment < `SEGMENT_LDT && exe_segment != `SEGMENT_CS) && ( exe_descriptor[`DESC_BIT_SEG] == `FALSE || (exe_segment == `SEGMENT_SS && ( exe_selector[`SELECTOR_BITS_RPL] != e_cpl_current || `DESC_IS_CODE(exe_descriptor) || `DESC_IS_DATA_RO(exe_descriptor) || exe_descriptor[`DESC_BITS_DPL] != e_cpl_current )) || (exe_segment != `SEGMENT_SS && ( `DESC_IS_CODE_EO(exe_descriptor) || ((`DESC_IS_DATA(exe_descriptor) || `DESC_IS_CODE_NON_CONFORMING(exe_descriptor)) && exe_privilege_not_accepted) )) ) || (exe_segment == `SEGMENT_LDT && (exe_descriptor[`DESC_BIT_SEG] || exe_descriptor[`DESC_BITS_TYPE] != `DESC_LDT) ) || (exe_segment == `SEGMENT_TR && (exe_descriptor[`DESC_BIT_SEG] ||  (exe_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_AVAIL_386 && exe_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_AVAIL_286)) ) || (exe_segment == `SEGMENT_CS && ( exe_selector[`SELECTOR_BITS_RPL] < cpl || exe_descriptor[`DESC_BIT_SEG] == `FALSE || `DESC_IS_DATA(exe_descriptor) || (`DESC_IS_CODE_NON_CONFORMING(exe_descriptor) && exe_descriptor[`DESC_BITS_DPL] != exe_selector[`SELECTOR_BITS_RPL]) || (`DESC_IS_CODE_CONFORMING(exe_descriptor) && exe_descriptor[`DESC_BITS_DPL] > exe_selector[`SELECTOR_BITS_RPL]) )) );
 assign exe_load_seg_ss_fault = exe_cmd == `CMD_load_seg && exe_cmdex == `CMDEX_load_seg_STEP_2 && ~(glob_param_1[`MC_PARAM_1_FLAG_NP_NOT_SS_BIT]) && exe_segment == `SEGMENT_SS && exe_descriptor[`DESC_BIT_P] == `FALSE;
 assign exe_load_seg_np_fault = exe_cmd == `CMD_load_seg && exe_cmdex == `CMDEX_load_seg_STEP_2 && (glob_param_1[`MC_PARAM_1_FLAG_NP_NOT_SS_BIT] || exe_segment != `SEGMENT_SS) && exe_descriptor[`DESC_BIT_P] == `FALSE;
 
-wire [4:0]  e_bit_selector;
-wire        e_bit_selected;
-wire        e_bit_value;
-wire [31:0] e_bit_result;
 assign e_bit_selector = (exe_operand_16bit)? { 1'b0, src[3:0] } : src[4:0];
 assign e_bit_selected =  (e_bit_selector == 5'd0)?     dst[0] : (e_bit_selector == 5'd1)?     dst[1] : (e_bit_selector == 5'd2)?     dst[2] : (e_bit_selector == 5'd3)?     dst[3] : (e_bit_selector == 5'd4)?     dst[4] : (e_bit_selector == 5'd5)?     dst[5] : (e_bit_selector == 5'd6)?     dst[6] : (e_bit_selector == 5'd7)?     dst[7] : (e_bit_selector == 5'd8)?     dst[8] : (e_bit_selector == 5'd9)?     dst[9] : (e_bit_selector == 5'd10)?    dst[10] : (e_bit_selector == 5'd11)?    dst[11] : (e_bit_selector == 5'd12)?    dst[12] : (e_bit_selector == 5'd13)?    dst[13] : (e_bit_selector == 5'd14)?    dst[14] : (e_bit_selector == 5'd15)?    dst[15] : (e_bit_selector == 5'd16)?    dst[16] : (e_bit_selector == 5'd17)?    dst[17] : (e_bit_selector == 5'd18)?    dst[18] : (e_bit_selector == 5'd19)?    dst[19] : (e_bit_selector == 5'd20)?    dst[20] : (e_bit_selector == 5'd21)?    dst[21] : (e_bit_selector == 5'd22)?    dst[22] : (e_bit_selector == 5'd23)?    dst[23] : (e_bit_selector == 5'd24)?    dst[24] : (e_bit_selector == 5'd25)?    dst[25] : (e_bit_selector == 5'd26)?    dst[26] : (e_bit_selector == 5'd27)?    dst[27] : (e_bit_selector == 5'd28)?    dst[28] : (e_bit_selector == 5'd29)?    dst[29] : (e_bit_selector == 5'd30)?    dst[30] : dst[31];
 assign e_bit_value = (exe_cmd == `CMD_BTC)?     ~e_bit_selected : (exe_cmd == `CMD_BTR)?     1'b0 : 1'b1;
 assign e_bit_result = (e_bit_selector == 5'd0)?     { dst[31:1],  e_bit_value } : (e_bit_selector == 5'd1)?     { dst[31:2],  e_bit_value, dst[0] } : (e_bit_selector == 5'd2)?     { dst[31:3],  e_bit_value, dst[1:0] } : (e_bit_selector == 5'd3)?     { dst[31:4],  e_bit_value, dst[2:0] } : (e_bit_selector == 5'd4)?     { dst[31:5],  e_bit_value, dst[3:0] } : (e_bit_selector == 5'd5)?     { dst[31:6],  e_bit_value, dst[4:0] } : (e_bit_selector == 5'd6)?     { dst[31:7],  e_bit_value, dst[5:0] } : (e_bit_selector == 5'd7)?     { dst[31:8],  e_bit_value, dst[6:0] } : (e_bit_selector == 5'd8)?     { dst[31:9],  e_bit_value, dst[7:0] } : (e_bit_selector == 5'd9)?     { dst[31:10], e_bit_value, dst[8:0] } : (e_bit_selector == 5'd10)?    { dst[31:11], e_bit_value, dst[9:0] } : (e_bit_selector == 5'd11)?    { dst[31:12], e_bit_value, dst[10:0] } : (e_bit_selector == 5'd12)?    { dst[31:13], e_bit_value, dst[11:0] } : (e_bit_selector == 5'd13)?    { dst[31:14], e_bit_value, dst[12:0] } : (e_bit_selector == 5'd14)?    { dst[31:15], e_bit_value, dst[13:0] } : (e_bit_selector == 5'd15)?    { dst[31:16], e_bit_value, dst[14:0] } : (e_bit_selector == 5'd16)?    { dst[31:17], e_bit_value, dst[15:0] } : (e_bit_selector == 5'd17)?    { dst[31:18], e_bit_value, dst[16:0] } : (e_bit_selector == 5'd18)?    { dst[31:19], e_bit_value, dst[17:0] } : (e_bit_selector == 5'd19)?    { dst[31:20], e_bit_value, dst[18:0] } : (e_bit_selector == 5'd20)?    { dst[31:21], e_bit_value, dst[19:0] } : (e_bit_selector == 5'd21)?    { dst[31:22], e_bit_value, dst[20:0] } : (e_bit_selector == 5'd22)?    { dst[31:23], e_bit_value, dst[21:0] } : (e_bit_selector == 5'd23)?    { dst[31:24], e_bit_value, dst[22:0] } : (e_bit_selector == 5'd24)?    { dst[31:25], e_bit_value, dst[23:0] } : (e_bit_selector == 5'd25)?    { dst[31:26], e_bit_value, dst[24:0] } : (e_bit_selector == 5'd26)?    { dst[31:27], e_bit_value, dst[25:0] } : (e_bit_selector == 5'd27)?    { dst[31:28], e_bit_value, dst[26:0] } : (e_bit_selector == 5'd28)?    { dst[31:29], e_bit_value, dst[27:0] } : (e_bit_selector == 5'd29)?    { dst[31:30], e_bit_value, dst[28:0] } : (e_bit_selector == 5'd30)?    { dst[31],    e_bit_value, dst[29:0] } : { e_bit_value, dst[30:0] };
 
-wire [31:0] e_cr0_reg;
 assign e_cr0_reg = { cr0_pg, cr0_cd, cr0_nw, 10'b0, cr0_am, 1'b0, cr0_wp, 10'b0, cr0_ne, 1'b1, cr0_ts, cr0_em, cr0_mp, cr0_pe };
 
-wire        e_cmpxchg_eq;
-wire [32:0] e_cmpxchg_sub;
-wire [31:0] e_cmpxchg_result;
 assign e_cmpxchg_eq = (exe_is_8bit       && eax[7:0]  == dst[7:0]) || (exe_operand_16bit && eax[15:0] == dst[15:0]) || (exe_operand_32bit && eax[31:0] == dst[31:0]);
 assign e_cmpxchg_sub = eax - dst;
 assign e_cmpxchg_result = (e_cmpxchg_eq)? src : e_cmpxchg_sub[31:0];
 
-reg e_wbinvd_code_done;
-reg e_wbinvd_data_done;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0)       e_wbinvd_code_done <= `FALSE; else if(exe_reset)      e_wbinvd_code_done <= `FALSE; else if(exe_ready)      e_wbinvd_code_done <= `FALSE; else if(invdcode_done)  e_wbinvd_code_done <= `TRUE;
+always @(posedge clk) begin if(rst)       e_wbinvd_code_done <= `FALSE; else if(exe_reset)      e_wbinvd_code_done <= `FALSE; else if(exe_ready)      e_wbinvd_code_done <= `FALSE; else if(invdcode_done)  e_wbinvd_code_done <= `TRUE;
 end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0)         e_wbinvd_data_done <= `FALSE; else if(exe_reset)        e_wbinvd_data_done <= `FALSE; else if(exe_ready)        e_wbinvd_data_done <= `FALSE; else if(wbinvddata_done)  e_wbinvd_data_done <= `TRUE;
+always @(posedge clk) begin if(rst)         e_wbinvd_data_done <= `FALSE; else if(exe_reset)        e_wbinvd_data_done <= `FALSE; else if(exe_ready)        e_wbinvd_data_done <= `FALSE; else if(wbinvddata_done)  e_wbinvd_data_done <= `TRUE;
 end
 
-wire exe_cmd_loop_ecx;
-wire exe_cmd_loop_condition;
 assign exe_cmd_loop_ecx = (exe_address_16bit)? ecx[15:0] != 16'd1 : ecx != 32'd1;
 assign exe_cmd_loop_condition = (exe_cmdex == `CMDEX_LOOP_NE)?  exe_cmd_loop_ecx && zflag == `FALSE : (exe_cmdex == `CMDEX_LOOP_E)?   exe_cmd_loop_ecx && zflag == `TRUE : exe_cmd_loop_ecx;
 
-wire exe_cmd_lar_desc_invalid;
-wire exe_cmd_lsl_desc_invalid;
-wire exe_cmd_verr_desc_invalid;
-wire exe_cmd_verw_desc_invalid;
 assign exe_cmd_lar_desc_invalid = (~(exe_descriptor[`DESC_BIT_SEG]) && (exe_descriptor[`DESC_BITS_TYPE] == 4'd0  || exe_descriptor[`DESC_BITS_TYPE] == 4'd8 || exe_descriptor[`DESC_BITS_TYPE] == 4'd10 || exe_descriptor[`DESC_BITS_TYPE] == 4'd13) ) || (exe_descriptor[`DESC_BIT_SEG] && (`DESC_IS_DATA(exe_descriptor) || `DESC_IS_CODE_NON_CONFORMING(exe_descriptor)) && exe_privilege_not_accepted ) || (~(exe_descriptor[`DESC_BIT_SEG]) && (exe_descriptor[`DESC_BITS_TYPE] == `DESC_INTERRUPT_GATE_386 || exe_descriptor[`DESC_BITS_TYPE] == `DESC_INTERRUPT_GATE_286 || exe_descriptor[`DESC_BITS_TYPE] == `DESC_TRAP_GATE_386      || exe_descriptor[`DESC_BITS_TYPE] == `DESC_TRAP_GATE_286) ) || (~(exe_descriptor[`DESC_BIT_SEG]) && exe_privilege_not_accepted );
 assign exe_cmd_lsl_desc_invalid = (~(exe_descriptor[`DESC_BIT_SEG]) && (exe_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_AVAIL_386 && exe_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_BUSY_386 && exe_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_AVAIL_286 && exe_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_BUSY_286 && exe_descriptor[`DESC_BITS_TYPE] != `DESC_LDT) ) || (~(exe_descriptor[`DESC_BIT_SEG]) && exe_privilege_not_accepted ) || (exe_descriptor[`DESC_BIT_SEG] && (`DESC_IS_DATA(exe_descriptor) || `DESC_IS_CODE_NON_CONFORMING(exe_descriptor)) && exe_privilege_not_accepted );
 assign exe_cmd_verr_desc_invalid = (~(exe_descriptor[`DESC_BIT_SEG]) ) || (`DESC_IS_CODE_EO(exe_descriptor) || (`DESC_IS_CODE_NON_CONFORMING(exe_descriptor) && exe_privilege_not_accepted) ) || (`DESC_IS_DATA(exe_descriptor) && exe_privilege_not_accepted );
 assign exe_cmd_verw_desc_invalid = (~(exe_descriptor[`DESC_BIT_SEG]) ) || (`DESC_IS_CODE(exe_descriptor) ) || (`DESC_IS_DATA_RO(exe_descriptor) || exe_privilege_not_accepted );
 
-wire signed [31:0] e_bound_min;
-wire signed [31:0] e_bound_max;
-wire signed [31:0] e_bound_dst;
 assign e_bound_min = (exe_operand_16bit)? { {16{exe_buffer[15]}}, exe_buffer[15:0] } : exe_buffer;
 assign e_bound_max = (exe_operand_16bit)? { {16{src[15]}},        src[15:0] }        : src;
 assign e_bound_dst = (exe_operand_16bit)? { {16{dst[15]}},        dst[15:0] }        : dst;
 assign exe_bound_fault = exe_cmd == `CMD_BOUND && exe_cmdex == `CMDEX_BOUND_STEP_LAST && (e_bound_dst < e_bound_min || e_bound_dst > e_bound_max);
 
-wire [31:0] exe_new_tss_max;
 assign exe_new_tss_max = (glob_descriptor[`DESC_BITS_TYPE] <= 4'd3)? 32'h2B : 32'h67;
 
-wire e_bcd_condition_cf;
-wire exe_bcd_condition_af;
-wire exe_bcd_condition_cf;
-wire [15:0] e_aaa_sum_ax;
-wire [15:0] e_aaa_result;
-wire [15:0] e_aas_sub_ax;
-wire [15:0] e_aas_result;
-wire [7:0]  e_daa_sum_low;
-wire [7:0]  e_daa_step1;
-wire [7:0]  e_daa_sum_high;
-wire [7:0]  e_daa_result;
-wire [7:0]  e_das_sub_low;
-wire [7:0]  e_das_step1;
-wire [7:0]  e_das_sub_high;
-wire [7:0]  e_das_result;
 assign e_bcd_condition_cf = (dst[7:0] > 8'h99 || cflag);
 assign exe_bcd_condition_af = dst[3:0] > 4'd9 || aflag;
 assign exe_bcd_condition_cf = e_bcd_condition_cf || (exe_bcd_condition_af && (cflag || (exe_cmd == `CMD_DAA)? dst[7:0] > 8'hF9 : dst[7:0] < 8'h06));
@@ -105,318 +63,314 @@ assign e_das_step1    = (exe_bcd_condition_af)? e_das_sub_low : dst[7:0];
 assign e_das_sub_high = e_das_step1 - 8'h60;
 assign e_das_result   = (e_bcd_condition_cf)? e_das_sub_high : e_das_step1;
 
-wire [4:0]  e_bit_scan_forward;
-wire        e_bit_scan_zero;
-wire [31:0] e_src_ze;
-wire [4:0]  e_bit_scan_reverse;
 assign e_bit_scan_forward = (src[0])?  5'd0 : (src[1])?  5'd1 : (src[2])?  5'd2 : (src[3])?  5'd3 : (src[4])?  5'd4 : (src[5])?  5'd5 : (src[6])?  5'd6 : (src[7])?  5'd7 : (src[8])?  5'd8 : (src[9])?  5'd9 : (src[10])? 5'd10 : (src[11])? 5'd11 : (src[12])? 5'd12 : (src[13])? 5'd13 : (src[14])? 5'd14 : (src[15])? 5'd15 : (src[16])? 5'd16 : (src[17])? 5'd17 : (src[18])? 5'd18 : (src[19])? 5'd19 : (src[20])? 5'd20 : (src[21])? 5'd21 : (src[22])? 5'd22 : (src[23])? 5'd23 : (src[24])? 5'd24 : (src[25])? 5'd25 : (src[26])? 5'd26 : (src[27])? 5'd27 : (src[28])? 5'd28 : (src[29])? 5'd29 : (src[30])? 5'd30 : (src[31])? 5'd31 : 5'd0;
 assign e_src_ze = (exe_operand_16bit)? { 16'd0, src[15:0] } : src;
 assign e_bit_scan_reverse = (e_src_ze[31])? 5'd31 : (e_src_ze[30])? 5'd30 : (e_src_ze[29])? 5'd29 : (e_src_ze[28])? 5'd28 : (e_src_ze[27])? 5'd27 : (e_src_ze[26])? 5'd26 : (e_src_ze[25])? 5'd25 : (e_src_ze[24])? 5'd24 : (e_src_ze[23])? 5'd23 : (e_src_ze[22])? 5'd22 : (e_src_ze[21])? 5'd21 : (e_src_ze[20])? 5'd20 : (e_src_ze[19])? 5'd19 : (e_src_ze[18])? 5'd18 : (e_src_ze[17])? 5'd17 : (e_src_ze[16])? 5'd16 : (e_src_ze[15])? 5'd15 : (e_src_ze[14])? 5'd14 : (e_src_ze[13])? 5'd13 : (e_src_ze[12])? 5'd12 : (e_src_ze[11])? 5'd11 : (e_src_ze[10])? 5'd10 : (e_src_ze[9])?  5'd9 : (e_src_ze[8])?  5'd8 : (e_src_ze[7])?  5'd7 : (e_src_ze[6])?  5'd6 : (e_src_ze[5])?  5'd5 : (e_src_ze[4])?  5'd4 : (e_src_ze[3])?  5'd3 : (e_src_ze[2])?  5'd2 : (e_src_ze[1])?  5'd1 : (e_src_ze[0])?  5'd0 : 5'd0;
 assign e_bit_scan_zero = (exe_operand_16bit)? src[15:0] == 16'd0 : src[31:0] == 32'd0;
 
 //======================================================== conditions
-wire cond_0 = exe_cmd == `CMD_XADD && exe_cmdex == `CMDEX_XADD_FIRST;
-wire cond_1 = exe_cmd == `CMD_XADD && exe_cmdex == `CMDEX_XADD_LAST;
-wire cond_2 = exe_cmd == `CMD_JCXZ;
-wire cond_3 = exe_mutex_current[`MUTEX_ECX_BIT];
-wire cond_4 = exe_jecxz_condition && exe_branch_eip > cs_limit;
-wire cond_5 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_protected_STEP_1;
-wire cond_6 = exe_cmd == `CMD_CALL_2  && exe_cmdex == `CMDEX_CALL_2_protected_seg_STEP_3;
-wire cond_7 = glob_param_2 > glob_desc_limit;
-wire cond_8 = exe_cmd == `CMD_CALL && (exe_cmdex == `CMDEX_CALL_Ev_STEP_0 || exe_cmdex == `CMDEX_CALL_Ep_STEP_0 || exe_cmdex == `CMDEX_CALL_Ap_STEP_0);
-wire cond_9 = exe_cmdex == `CMDEX_CALL_Ev_STEP_0;
-wire cond_10 = exe_mutex_current[`MUTEX_ESP_BIT];
-wire cond_11 = exe_operand_32bit;
-wire cond_12 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_Jv_STEP_0;
-wire cond_13 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_Ev_Jv_STEP_1;
-wire cond_14 = glob_param_2 > cs_limit;
-wire cond_15 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_Ep_STEP_1;
-wire cond_16 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_Ap_STEP_1;
-wire cond_17 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_real_v8086_STEP_0;
-wire cond_18 = exe_operand_32bit && glob_param_2 > cs_limit;
-wire cond_19 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_real_v8086_STEP_1;
-wire cond_20 = exe_mutex_current[`MUTEX_ACTIVE_BIT];
-wire cond_21 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_real_v8086_STEP_2;
-wire cond_22 = exe_operand_16bit && glob_param_2 > cs_limit;
-wire cond_23 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_real_v8086_STEP_3;
-wire cond_24 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_protected_seg_STEP_0;
-wire cond_25 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_protected_seg_STEP_1;
-wire cond_26 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_protected_seg_STEP_2;
-wire cond_27 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_protected_seg_STEP_4;
-wire cond_28 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_STEP_0;
-wire cond_29 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_0;
-wire cond_30 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_1;
-wire cond_31 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_2;
-wire cond_32 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_protected_seg_STEP_3;
-wire cond_33 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_3;
-wire cond_34 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_1;
-wire cond_35 = glob_param_3[15:2] == 14'd0;
-wire cond_36 = exe_ready;
-wire cond_37 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_3;
-wire cond_38 = ss_cache[`DESC_BIT_D_B];
-wire cond_39 = exe_cmd == `CMD_CALL_3 && (exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_4 || exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_5);
-wire cond_40 = exe_cmd == `CMD_CALL_3 && exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_6;
-wire cond_41 = exe_cmd == `CMD_CALL_3 && exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_7;
-wire cond_42 = glob_descriptor_2[`DESC_BIT_D_B];
-wire cond_43 = exe_cmd == `CMD_CALL_3 && exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_8;
-wire cond_44 = glob_param_2 > glob_desc_2_limit;
-wire cond_45 = exe_cmd == `CMD_CALL_3 && exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_9;
-wire cond_46 = exe_cmd == `CMD_CALL_3 && exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_10;
-wire cond_47 = exe_cmd == `CMD_PUSH_MOV_SEG && { exe_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_implicit;
-wire cond_48 = exe_cmd == `CMD_PUSH_MOV_SEG && { exe_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_modregrm;
-wire cond_49 = exe_cmd == `CMD_NEG;
-wire cond_50 = exe_cmd == `CMD_Jcc;
-wire cond_51 = exe_mutex_current[`MUTEX_EFLAGS_BIT];
-wire cond_52 = exe_condition && exe_branch_eip > cs_limit;
-wire cond_53 = exe_cmd == `CMD_INVD && exe_cmdex == `CMDEX_INVD_STEP_0;
-wire cond_54 = cpl > 2'd0;
-wire cond_55 = exe_cmd == `CMD_INVD && exe_cmdex == `CMDEX_INVD_STEP_1;
-wire cond_56 = ~(e_invd_code_done && e_invd_data_done);
-wire cond_57 = exe_cmd == `CMD_INVLPG && exe_cmdex == `CMDEX_INVLPG_STEP_0;
-wire cond_58 = exe_cmd == `CMD_INVLPG && exe_cmdex == `CMDEX_INVLPG_STEP_1;
-wire cond_59 = ~(tlbflushsingle_done);
-wire cond_60 = exe_cmd == `CMD_io_allow && exe_cmdex == `CMDEX_io_allow_2;
-wire cond_61 = (  exe_is_8bit                       && e_io_allow_bits[0]   != 1'd0) || (~(exe_is_8bit) && exe_operand_16bit && e_io_allow_bits[1:0] != 2'd0) || (~(exe_is_8bit) && exe_operand_32bit && e_io_allow_bits[3:0] != 4'd0);
-wire cond_62 = exe_cmd == `CMD_HLT && exe_cmdex == `CMDEX_HLT_STEP_0;
-wire cond_63 = exe_cmd == `CMD_SCAS;
-wire cond_64 = exe_cmd == `CMD_INC_DEC;
-wire cond_65 = exe_cmd == `CMD_RET_near && exe_cmdex != `CMDEX_RET_near_LAST;
-wire cond_66 = exe_cmdex == `CMDEX_RET_near;
-wire cond_67 = exe_cmdex == `CMDEX_RET_near_imm;
-wire cond_68 = exe_cmd == `CMD_ARPL;
-wire cond_69 = exe_cmd == `CMD_BSWAP;
-wire cond_70 = exe_cmd == `CMD_LxS;
-wire cond_71 = (exe_cmd == `CMD_LLDT || exe_cmd == `CMD_LTR) && exe_cmdex == `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1;
-wire cond_72 = cpl != 2'd0;
-wire cond_73 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_int_trap_gate_STEP_0;
-wire cond_74 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_1;
-wire cond_75 = v8086_mode && exe_descriptor[`DESC_BITS_DPL] != 2'd0;
-wire cond_76 = ~(exe_trigger_gp_fault) && glob_param_3[15:2] == 14'd0;
-wire cond_77 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_3;
-wire cond_78 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_5;
-wire cond_79 = exe_cmd == `CMD_int_3 && (exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_4 || exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_5);
-wire cond_80 = ~(exe_mutex_current[`MUTEX_ACTIVE_BIT]) && exe_ready;
-wire cond_81 = exe_cmd == `CMD_int_3 && exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_6;
-wire cond_82 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_STEP_0;
-wire cond_83 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_STEP_1;
-wire cond_84 = exc_soft_int_ib && v8086_mode && iopl < 2'd3;
-wire cond_85 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_real_STEP_0;
-wire cond_86 = { 6'd0, exc_vector[7:0], 2'b11 } > idtr_limit;
-wire cond_87 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_real_STEP_1;
-wire cond_88 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_real_STEP_2;
-wire cond_89 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_real_STEP_3;
-wire cond_90 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_real_STEP_5;
-wire cond_91 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_protected_STEP_0;
-wire cond_92 = { 5'd0, exc_vector[7:0], 3'b111 } > idtr_limit;
-wire cond_93 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_protected_STEP_1;
-wire cond_94 = exe_descriptor[`DESC_BIT_SEG] || ( (   exe_descriptor[`DESC_BITS_TYPE] != `DESC_TASK_GATE && exe_descriptor[`DESC_BITS_TYPE] != `DESC_INTERRUPT_GATE_386 && exe_descriptor[`DESC_BITS_TYPE] != `DESC_INTERRUPT_GATE_286 && exe_descriptor[`DESC_BITS_TYPE] != `DESC_TRAP_GATE_386      && exe_descriptor[`DESC_BITS_TYPE] != `DESC_TRAP_GATE_286 ) || (exc_soft_int && exe_descriptor[`DESC_BITS_DPL] < cpl) );
-wire cond_95 = ~(exe_trigger_gp_fault) && exe_descriptor[`DESC_BIT_P] == `FALSE;
-wire cond_96 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_0;
-wire cond_97 = exe_int_2_int_trap_same_exception || (glob_param_2 > glob_desc_limit);
-wire cond_98 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_1;
-wire cond_99 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_2;
-wire cond_100 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_3;
-wire cond_101 = exe_cmd == `CMD_int_2  && exe_cmdex >= `CMDEX_int_2_int_trap_gate_more_STEP_4;
-wire cond_102 = exe_cmd == `CMD_int_3  && exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_0;
-wire cond_103 = exe_cmd == `CMD_int_3  && exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_1;
-wire cond_104 = exe_cmd == `CMD_int_3  && exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_2;
-wire cond_105 = exe_cmd == `CMD_int_3  && exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_3;
-wire cond_106 = exe_cmd == `CMD_AAD;
-wire cond_107 = mult_busy;
-wire cond_108 = exe_cmd == `CMD_AAM;
-wire cond_109 = exe_div_exception || div_busy;
-wire cond_110 = exe_cmd == `CMD_load_seg && exe_cmdex == `CMDEX_load_seg_STEP_1;
-wire cond_111 = protected_mode;
-wire cond_112 = ((glob_param_1[18:16] == `SEGMENT_SS || glob_param_1[18:16] == `SEGMENT_TR || glob_param_1[18:16] == `SEGMENT_CS) && glob_param_1[15:2] == 14'd0) ||  ((glob_param_1[18:16] == `SEGMENT_LDT || glob_param_1[18:16] == `SEGMENT_TR) && glob_param_1[`SELECTOR_BIT_TI] == 1'b1);
-wire cond_113 = exe_cmd == `CMD_load_seg && exe_cmdex == `CMDEX_load_seg_STEP_2;
-wire cond_114 = ~(protected_mode && glob_param_1[15:2] == 14'd0);
-wire cond_115 = exe_load_seg_gp_fault || exe_load_seg_ss_fault || exe_load_seg_np_fault;
-wire cond_116 = exe_cmd == `CMD_POP_seg;
-wire cond_117 = { exe_cmd[6:2], 2'd0 } == `CMD_BTx;
-wire cond_118 = exe_cmd == `CMD_IRET_2 && exe_cmdex == `CMDEX_IRET_2_protected_same_STEP_0;
-wire cond_119 = exe_cmd == `CMD_IRET_2 && exe_cmdex == `CMDEX_IRET_2_protected_same_STEP_1;
-wire cond_120 = exe_cmd == `CMD_IRET_2  && exe_cmdex == `CMDEX_IRET_2_protected_outer_STEP_3;
-wire cond_121 = exe_cmd == `CMD_IRET_2  && exe_cmdex == `CMDEX_IRET_2_protected_outer_STEP_5;
-wire cond_122 = exe_cmd == `CMD_IRET_2 && exe_cmdex == `CMDEX_IRET_2_protected_outer_STEP_6;
-wire cond_123 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_real_v86_STEP_0;
-wire cond_124 = v8086_mode && iopl < 2'd3;
-wire cond_125 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_real_v86_STEP_1;
-wire cond_126 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_real_v86_STEP_2;
-wire cond_127 = ~(v8086_mode) && glob_param_2 > cs_limit;
-wire cond_128 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_real_v86_STEP_3;
-wire cond_129 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_task_switch_STEP_0;
-wire cond_130 = glob_param_1[`SELECTOR_BIT_TI];
-wire cond_131 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_task_switch_STEP_1;
-wire cond_132 = glob_param_2[1] || exe_descriptor[`DESC_BIT_SEG] || (exe_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_BUSY_386 && exe_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_BUSY_286);
-wire cond_133 = glob_param_2[1] == 1'b0 && ~(exe_trigger_ts_fault) && ~(exe_descriptor[`DESC_BIT_P]);
-wire cond_134 = exe_cmd == `CMD_IRET && exe_cmdex >= `CMDEX_IRET_protected_to_v86_STEP_0;
-wire cond_135 = exe_cmd == `CMD_IRET_2 && exe_cmdex == `CMDEX_IRET_2_protected_to_v86_STEP_6;
-wire cond_136 = exe_cmd == `CMD_IRET_2 && exe_cmdex == `CMDEX_IRET_2_protected_outer_STEP_0;
-wire cond_137 = glob_param_1[`SELECTOR_BITS_RPL] != glob_param_3[`SELECTOR_BITS_RPL];
-wire cond_138 = exe_cmd == `CMD_POP && exe_cmdex == `CMDEX_POP_implicit;
-wire cond_139 = exe_cmd == `CMD_POP && exe_cmdex == `CMDEX_POP_modregrm_STEP_0;
-wire cond_140 = exe_cmd == `CMD_POP && exe_cmdex == `CMDEX_POP_modregrm_STEP_1;
-wire cond_141 = exe_cmd == `CMD_IDIV || exe_cmd == `CMD_DIV;
-wire cond_142 = exe_cmd == `CMD_Shift && exe_decoder[13:12] == 2'b01;
-wire cond_143 = exe_cmd == `CMD_Shift && exe_decoder[13:12] != 2'b01;
-wire cond_144 = exe_cmd == `CMD_CMPS;
-wire cond_145 = exe_cmd == `CMD_control_reg && exe_cmdex == `CMDEX_control_reg_LMSW_STEP_0;
-wire cond_146 = exe_cmd == `CMD_control_reg && exe_cmdex == `CMDEX_control_reg_MOV_store_STEP_0;
-wire cond_147 = exe_modregrm_reg == 3'd0;
-wire cond_148 = exe_modregrm_reg == 3'd2;
-wire cond_149 = exe_modregrm_reg == 3'd3;
-wire cond_150 = exe_cmd == `CMD_control_reg && exe_cmdex == `CMDEX_control_reg_MOV_load_STEP_0;
-wire cond_151 = cpl > 2'd0 || (exe_modregrm_reg == 3'd0 && ((src[31] && ~(src[0])) || (src[29] && ~(src[30]))));
-wire cond_152 = exe_cmd == `CMD_control_reg && exe_cmdex == `CMDEX_control_reg_SMSW_STEP_0;
-wire cond_153 = exe_cmd == `CMD_LGDT || exe_cmd == `CMD_LIDT;
-wire cond_154 = exe_cmd == `CMD_PUSHA;
-wire cond_155 = exe_cmdex[2:0] == 3'd4;
-wire cond_156 = exe_cmd == `CMD_fpu && exe_cmdex == `CMDEX_ESC_STEP_0;
-wire cond_157 = cr0_em || cr0_ts;
-wire cond_158 = exe_cmd == `CMD_SETcc;
-wire cond_159 = exe_condition;
-wire cond_160 = exe_cmd == `CMD_CMPXCHG;
-wire cond_161 = exe_mutex_current[`MUTEX_EAX_BIT];
-wire cond_162 = exe_cmd == `CMD_ENTER && exe_cmdex == `CMDEX_ENTER_FIRST;
-wire cond_163 = exe_cmd == `CMD_ENTER && exe_cmdex == `CMDEX_ENTER_LAST;
-wire cond_164 = exe_cmd == `CMD_ENTER && (exe_cmdex == `CMDEX_ENTER_PUSH || exe_cmdex == `CMDEX_ENTER_LOOP);
-wire cond_165 = exe_cmdex == `CMDEX_ENTER_PUSH;
-wire cond_166 = exe_cmd == `CMD_IMUL;
-wire cond_167 = exe_cmd == `CMD_LEAVE;
-wire cond_168 = { exe_cmd[6:1], 1'd0 } == `CMD_SHxD;
-wire cond_169 = exe_cmd == `CMD_WBINVD && exe_cmdex == `CMDEX_WBINVD_STEP_0;
-wire cond_170 = exe_cmd == `CMD_WBINVD && exe_cmdex == `CMDEX_WBINVD_STEP_1;
-wire cond_171 = ~(e_wbinvd_code_done && e_wbinvd_data_done);
-wire cond_172 = { exe_cmd[6:3], 3'd0 } == `CMD_Arith;
-wire cond_173 = exe_cmd[2:1] == 2'b01 && exe_mutex_current[`MUTEX_EFLAGS_BIT];
-wire cond_174 = exe_cmd == `CMD_MUL;
-wire cond_175 = exe_cmd == `CMD_LOOP;
-wire cond_176 = exe_mutex_current[`MUTEX_ECX_BIT] || (exe_mutex_current[`MUTEX_EFLAGS_BIT] && (exe_cmdex == `CMDEX_LOOP_NE || exe_cmdex == `CMDEX_LOOP_E));
-wire cond_177 = exe_cmd_loop_condition && exe_branch_eip > cs_limit;
-wire cond_178 = exe_cmd == `CMD_TEST;
-wire cond_179 = exe_cmd == `CMD_CLTS;
-wire cond_180 = exe_cmd == `CMD_RET_far  && exe_cmdex == `CMDEX_RET_far_STEP_1;
-wire cond_181 = exe_cmd == `CMD_RET_far && exe_cmdex == `CMDEX_RET_far_STEP_2;
-wire cond_182 = (v8086_mode || real_mode) && glob_param_2 > cs_limit;
-wire cond_183 = exe_cmd == `CMD_RET_far && exe_cmdex == `CMDEX_RET_far_same_STEP_3;
-wire cond_184 = exe_cmd == `CMD_RET_far && exe_cmdex == `CMDEX_RET_far_outer_STEP_5;
-wire cond_185 = exe_cmd == `CMD_RET_far && exe_cmdex == `CMDEX_RET_far_outer_STEP_6;
-wire cond_186 = exe_cmd == `CMD_RET_far && exe_cmdex == `CMDEX_RET_far_outer_STEP_7;
-wire cond_187 = exe_cmd == `CMD_RET_far && (exe_cmdex == `CMDEX_RET_far_real_STEP_3 || exe_cmdex == `CMDEX_RET_far_same_STEP_4);
-wire cond_188 = exe_cmdex == `CMDEX_RET_far_real_STEP_3;
-wire cond_189 = exe_cmd == `CMD_LODS;
-wire cond_190 = exe_cmd == `CMD_XCHG && exe_cmdex == `CMDEX_XCHG_implicit;
-wire cond_191 = exe_cmd == `CMD_XCHG && exe_cmdex == `CMDEX_XCHG_modregrm;
-wire cond_192 = exe_cmd == `CMD_XCHG && exe_cmdex == `CMDEX_XCHG_modregrm_LAST;
-wire cond_193 = exe_cmd == `CMD_PUSH;
-wire cond_194 = exe_cmdex == `CMDEX_PUSH_immediate_se;
-wire cond_195 = exe_cmd == `CMD_IN && exe_cmdex == `CMDEX_IN_protected;
-wire cond_196 = exe_cmd == `CMD_IN && (exe_cmdex == `CMDEX_IN_dx || exe_cmdex == `CMDEX_IN_imm);
-wire cond_197 = exe_cmdex == `CMDEX_IN_dx && exe_mutex_current[`MUTEX_EDX_BIT];
-wire cond_198 = exe_cmd == `CMD_NOT;
-wire cond_199 = (exe_cmd == `CMD_LAR || exe_cmd == `CMD_LSL) && exe_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_LAST;
-wire cond_200 = (exe_cmd == `CMD_LAR || exe_cmd == `CMD_LSL || exe_cmd == `CMD_VERR || exe_cmd == `CMD_VERW) && exe_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_2;
-wire cond_201 = (exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_protected_STEP_0) || (exe_cmd == `CMD_JMP  && exe_cmdex == `CMDEX_JMP_protected_STEP_0);
-wire cond_202 = glob_param_1[15:2] == 14'd0 || (exe_descriptor[`DESC_BIT_SEG] == `FALSE && ( exe_descriptor[`DESC_BITS_DPL] < cpl || exe_descriptor[`DESC_BITS_DPL] < exe_selector[`SELECTOR_BITS_RPL] || ((exe_descriptor[`DESC_BITS_TYPE] == 4'd1 || exe_descriptor[`DESC_BITS_TYPE] == 4'd9) && exe_selector[`SELECTOR_BIT_TI]) ||  exe_descriptor[`DESC_BITS_TYPE] == 4'd0  || exe_descriptor[`DESC_BITS_TYPE] == 4'd8  || exe_descriptor[`DESC_BITS_TYPE] == 4'd10 || exe_descriptor[`DESC_BITS_TYPE] == 4'd13 ||  exe_descriptor[`DESC_BITS_TYPE] == 4'd2  || exe_descriptor[`DESC_BITS_TYPE] == 4'd3  || exe_descriptor[`DESC_BITS_TYPE] == 4'd6  || exe_descriptor[`DESC_BITS_TYPE] == 4'd7  || exe_descriptor[`DESC_BITS_TYPE] == 4'd11 || exe_descriptor[`DESC_BITS_TYPE] == 4'd14 || exe_descriptor[`DESC_BITS_TYPE] == 4'd15)  ) || (exe_descriptor[`DESC_BIT_SEG] && ( `DESC_IS_DATA(exe_descriptor) || (`DESC_IS_CODE_NON_CONFORMING(exe_descriptor) && (exe_descriptor[`DESC_BITS_DPL] != cpl || exe_selector[`SELECTOR_BITS_RPL] > cpl)) || (`DESC_IS_CODE_CONFORMING(exe_descriptor)     &&  exe_descriptor[`DESC_BITS_DPL] > cpl))  ) ;
-wire cond_203 = ~(exe_trigger_gp_fault) && exe_descriptor[`DESC_BIT_P] == `FALSE &&  (exe_descriptor[`DESC_BIT_SEG] || exe_descriptor[`DESC_BITS_TYPE] == 4'd1 || exe_descriptor[`DESC_BITS_TYPE] == 4'd9 ||  exe_descriptor[`DESC_BITS_TYPE] == 4'd4 || exe_descriptor[`DESC_BITS_TYPE] == 4'd12 ||  exe_descriptor[`DESC_BITS_TYPE] == 4'd5)  ;
-wire cond_204 = (exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_task_switch_STEP_0) || (exe_cmd == `CMD_JMP    && exe_cmdex == `CMDEX_JMP_task_switch_STEP_0);
-wire cond_205 = exe_cmd == `CMD_CALL_2;
-wire cond_206 = exe_cmd == `CMD_JMP;
-wire cond_207 = (exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_task_gate_STEP_1) || (exe_cmd == `CMD_JMP    && exe_cmdex == `CMDEX_JMP_task_gate_STEP_1) || (exe_cmd == `CMD_int    && exe_cmdex == `CMDEX_int_task_gate_STEP_1);
-wire cond_208 = glob_param_1[`SELECTOR_BIT_TI] || glob_descriptor[`DESC_BIT_SEG] || (glob_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_AVAIL_386 && glob_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_AVAIL_286);
-wire cond_209 = exe_cmd == `CMD_int;
-wire cond_210 = exe_cmd != `CMD_int;
-wire cond_211 = (exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_STEP_1) || (exe_cmd == `CMD_int    && exe_cmdex == `CMDEX_int_int_trap_gate_STEP_1);
-wire cond_212 = glob_param_1[15:2] == 14'd0 || glob_descriptor[`DESC_BIT_SEG] == `FALSE ||  `DESC_IS_DATA(glob_descriptor) || glob_descriptor[`DESC_BITS_DPL] > cpl;
-wire cond_213 = (exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_2) || (exe_cmd == `CMD_int_2  && exe_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_2);
-wire cond_214 = glob_param_5[0] || glob_param_1[`SELECTOR_BITS_RPL] != glob_descriptor_2[`DESC_BITS_DPL] ||  glob_descriptor[`DESC_BITS_DPL] != glob_descriptor_2[`DESC_BITS_DPL] || glob_descriptor[`DESC_BIT_SEG] == `FALSE || `DESC_IS_CODE(glob_descriptor) || `DESC_IS_DATA_RO(glob_descriptor);
-wire cond_215 = glob_param_5[0] == 1'b0 && ~(exe_trigger_ts_fault) && ~(glob_descriptor[`DESC_BIT_P]);
-wire cond_216 = exe_cmd == `CMD_STOS;
-wire cond_217 = exe_cmd == `CMD_INS;
-wire cond_218 = exe_mutex_current[`MUTEX_EDX_BIT];
-wire cond_219 = exe_cmd == `CMD_OUTS;
-wire cond_220 = exe_cmd == `CMD_PUSHF;
-wire cond_221 = exe_mutex_current[`MUTEX_ESP_BIT] || exe_mutex_current[`MUTEX_EFLAGS_BIT];
-wire cond_222 = exe_cmd == `CMD_JMP  && (exe_cmdex == `CMDEX_JMP_Ev_STEP_0  || exe_cmdex == `CMDEX_JMP_Ep_STEP_0  || exe_cmdex == `CMDEX_JMP_Ap_STEP_0);
-wire cond_223 = exe_cmd == `CMD_JMP  && exe_cmdex == `CMDEX_JMP_Jv_STEP_0;
-wire cond_224 = exe_cmd == `CMD_CALL && exe_mutex_current[`MUTEX_ESP_BIT];
-wire cond_225 = exe_cmd == `CMD_JMP  && exe_cmdex == `CMDEX_JMP_Ev_Jv_STEP_1;
-wire cond_226 = exe_cmd == `CMD_JMP  && exe_cmdex == `CMDEX_JMP_Ep_STEP_1;
-wire cond_227 = exe_cmd == `CMD_JMP  && exe_cmdex == `CMDEX_JMP_Ap_STEP_1;
-wire cond_228 = exe_cmd == `CMD_JMP && exe_cmdex == `CMDEX_JMP_real_v8086_STEP_0;
-wire cond_229 = exe_cmd == `CMD_JMP && exe_cmdex == `CMDEX_JMP_real_v8086_STEP_1;
-wire cond_230 = exe_cmd == `CMD_JMP && exe_cmdex == `CMDEX_JMP_protected_seg_STEP_0;
-wire cond_231 = exe_cmd == `CMD_JMP && exe_cmdex == `CMDEX_JMP_protected_seg_STEP_1;
-wire cond_232 = exe_cmd == `CMD_JMP_2 && exe_cmdex == `CMDEX_JMP_2_call_gate_STEP_1;
-wire cond_233 = glob_param_1[15:2] == 14'd0 || glob_descriptor[`DESC_BIT_SEG] == `FALSE || `DESC_IS_DATA(glob_descriptor) || (`DESC_IS_CODE_NON_CONFORMING(exe_descriptor) && exe_descriptor[`DESC_BITS_DPL] != cpl) || (`DESC_IS_CODE_CONFORMING(exe_descriptor)     && exe_descriptor[`DESC_BITS_DPL] > cpl);
-wire cond_234 = exe_cmd == `CMD_JMP_2 && exe_cmdex == `CMDEX_JMP_2_call_gate_STEP_2;
-wire cond_235 = exe_cmd == `CMD_JMP_2 && exe_cmdex == `CMDEX_JMP_2_call_gate_STEP_3;
-wire cond_236 = exe_cmd == `CMD_OUT && (exe_cmdex == `CMDEX_OUT_dx || exe_cmdex == `CMDEX_OUT_imm);
-wire cond_237 = exe_cmdex == `CMDEX_OUT_dx && exe_mutex_current[`MUTEX_EDX_BIT];
-wire cond_238 = exe_cmd == `CMD_OUT && exe_cmdex == `CMDEX_OUT_protected;
-wire cond_239 = exe_cmd == `CMD_MOV;
-wire cond_240 = exe_cmd == `CMD_POPF && exe_cmdex == `CMDEX_POPF_STEP_0;
-wire cond_241 = exe_cmd == `CMD_CLI || exe_cmd == `CMD_STI;
-wire cond_242 = (protected_mode && iopl < cpl) || (v8086_mode && iopl != 2'd3);
-wire cond_243 = exe_cmd == `CMD_BOUND && exe_cmdex == `CMDEX_BOUND_STEP_FIRST;
-wire cond_244 = exe_cmd == `CMD_BOUND && exe_cmdex == `CMDEX_BOUND_STEP_LAST;
-wire cond_245 = exe_bound_fault;
-wire cond_246 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_1;
-wire cond_247 = glob_desc_limit < exe_new_tss_max;
-wire cond_248 = tr_limit < ((tr_cache[`DESC_BITS_TYPE] <= 4'd3)? 32'h29 : 32'h5F);
-wire cond_249 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_2;
-wire cond_250 = ~(tlbcheck_done) && ~(tlbcheck_page_fault);
-wire cond_251 = tlbcheck_page_fault;
-wire cond_252 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_3;
-wire cond_253 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_4;
-wire cond_254 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_5;
-wire cond_255 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_7;
-wire cond_256 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_8;
-wire cond_257 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_10;
-wire cond_258 = exe_cmd == `CMD_task_switch && exe_cmdex >= `CMDEX_task_switch_STEP_12 && exe_cmdex <= `CMDEX_task_switch_STEP_14;
-wire cond_259 = exe_cmd == `CMD_task_switch_2;
-wire cond_260 = exe_cmdex <= `CMDEX_task_switch_2_STEP_7;
-wire cond_261 = exe_cmdex > `CMDEX_task_switch_2_STEP_7;
-wire cond_262 = exe_cmd == `CMD_task_switch_3;
-wire cond_263 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_0;
-wire cond_264 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_2;
-wire cond_265 = glob_param_2[2] || glob_param_2[2:0] == 3'b010 || ( glob_param_2[2:0] == 3'b000 && ( exe_descriptor[`DESC_BIT_SEG] || exe_descriptor[`DESC_BITS_TYPE] != `DESC_LDT ||  exe_descriptor[`DESC_BIT_P] == `FALSE ) );
-wire cond_266 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_3;
-wire cond_267 = ~(v8086_mode);
-wire cond_268 = glob_param_2[1:0] != 2'b00 || ( exe_descriptor[`DESC_BIT_SEG] == 1'b0 || `DESC_IS_CODE(exe_descriptor) || `DESC_IS_DATA_RO(exe_descriptor) || (exe_descriptor[`DESC_BIT_P] && ( exe_descriptor[`DESC_BITS_DPL] != wr_task_rpl || exe_descriptor[`DESC_BITS_DPL] != exe_selector[`SELECTOR_BITS_RPL] ) ) );
-wire cond_269 = glob_param_2[1:0] == 2'b00 && exe_descriptor[`DESC_BIT_SEG] && `DESC_IS_DATA_RW(exe_descriptor) && ~(exe_descriptor[`DESC_BIT_P]);
-wire cond_270 = exe_cmd == `CMD_task_switch_4 && exe_cmdex >= `CMDEX_task_switch_4_STEP_4 && exe_cmdex <= `CMDEX_task_switch_4_STEP_7;
-wire cond_271 = glob_param_2[1:0] == 2'b10 || (glob_param_2[1:0] == 2'b00 && ( exe_descriptor[`DESC_BIT_SEG] == 1'b0 || `DESC_IS_CODE_EO(exe_descriptor) || ((`DESC_IS_DATA(exe_descriptor) || `DESC_IS_CODE_NON_CONFORMING(exe_descriptor)) && exe_privilege_not_accepted) ));
-wire cond_272 = glob_param_2[1:0] == 2'b00 && ~(exe_trigger_ts_fault) && ~(exe_descriptor[`DESC_BIT_P]);
-wire cond_273 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_8;
-wire cond_274 = glob_param_2[1:0] != 2'b00 || ( exe_descriptor[`DESC_BIT_SEG] == 1'b0 || `DESC_IS_DATA(exe_descriptor) || (`DESC_IS_CODE_NON_CONFORMING(exe_descriptor) && exe_descriptor[`DESC_BITS_DPL] != exe_selector[`SELECTOR_BITS_RPL]) || (`DESC_IS_CODE_CONFORMING(exe_descriptor)     && exe_descriptor[`DESC_BITS_DPL] >  exe_selector[`SELECTOR_BITS_RPL]) );
-wire cond_275 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_9;
-wire cond_276 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_10;
-wire cond_277 = exe_eip > cs_limit;
-wire cond_278 = exe_cmd == `CMD_LEA;
-wire cond_279 = exe_cmd == `CMD_SGDT;
-wire cond_280 = exe_cmdex == `CMDEX_SGDT_SIDT_STEP_1;
-wire cond_281 = exe_cmdex == `CMDEX_SGDT_SIDT_STEP_2;
-wire cond_282 = exe_cmd == `CMD_SIDT;
-wire cond_283 = exe_cmd == `CMD_MOVS;
-wire cond_284 = exe_cmd == `CMD_MOVSX || exe_cmd == `CMD_MOVZX;
-wire cond_285 = exe_cmd == `CMD_POPA;
-wire cond_286 = exe_cmd == `CMD_debug_reg && (exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 || exe_cmdex == `CMDEX_debug_reg_MOV_load_STEP_0);
-wire cond_287 = exe_cmdex == `CMDEX_debug_reg_MOV_load_STEP_0;
-wire cond_288 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && exe_modregrm_reg == 3'd0;
-wire cond_289 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && exe_modregrm_reg == 3'd1;
-wire cond_290 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && exe_modregrm_reg == 3'd2;
-wire cond_291 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && exe_modregrm_reg == 3'd3;
-wire cond_292 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && (exe_modregrm_reg == 3'd4 || exe_modregrm_reg == 3'd6);
-wire cond_293 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && (exe_modregrm_reg == 3'd5 || exe_modregrm_reg == 3'd7);
-wire cond_294 = dr7[`DR7_BIT_GD];
-wire cond_295 = exe_cmd == `CMD_XLAT;
-wire cond_296 = exe_cmd == `CMD_AAA || exe_cmd == `CMD_AAS || exe_cmd == `CMD_DAA || exe_cmd == `CMD_DAS;
-wire cond_297 = { exe_cmd[6:1], 1'd0 } == `CMD_BSx;
-wire cond_298 = exe_cmd == `CMD_BSF;
-wire cond_299 = exe_cmd == `CMD_BSR;
+ assign cond_0 = exe_cmd == `CMD_XADD && exe_cmdex == `CMDEX_XADD_FIRST;
+ assign cond_1 = exe_cmd == `CMD_XADD && exe_cmdex == `CMDEX_XADD_LAST;
+ assign cond_2 = exe_cmd == `CMD_JCXZ;
+ assign cond_3 = exe_mutex_current[`MUTEX_ECX_BIT];
+ assign cond_4 = exe_jecxz_condition && exe_branch_eip > cs_limit;
+ assign cond_5 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_protected_STEP_1;
+ assign cond_6 = exe_cmd == `CMD_CALL_2  && exe_cmdex == `CMDEX_CALL_2_protected_seg_STEP_3;
+ assign cond_7 = glob_param_2 > glob_desc_limit;
+ assign cond_8 = exe_cmd == `CMD_CALL && (exe_cmdex == `CMDEX_CALL_Ev_STEP_0 || exe_cmdex == `CMDEX_CALL_Ep_STEP_0 || exe_cmdex == `CMDEX_CALL_Ap_STEP_0);
+ assign cond_9 = exe_cmdex == `CMDEX_CALL_Ev_STEP_0;
+ assign cond_10 = exe_mutex_current[`MUTEX_ESP_BIT];
+ assign cond_11 = exe_operand_32bit;
+ assign cond_12 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_Jv_STEP_0;
+ assign cond_13 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_Ev_Jv_STEP_1;
+ assign cond_14 = glob_param_2 > cs_limit;
+ assign cond_15 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_Ep_STEP_1;
+ assign cond_16 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_Ap_STEP_1;
+ assign cond_17 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_real_v8086_STEP_0;
+ assign cond_18 = exe_operand_32bit && glob_param_2 > cs_limit;
+ assign cond_19 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_real_v8086_STEP_1;
+ assign cond_20 = exe_mutex_current[`MUTEX_ACTIVE_BIT];
+ assign cond_21 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_real_v8086_STEP_2;
+ assign cond_22 = exe_operand_16bit && glob_param_2 > cs_limit;
+ assign cond_23 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_real_v8086_STEP_3;
+ assign cond_24 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_protected_seg_STEP_0;
+ assign cond_25 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_protected_seg_STEP_1;
+ assign cond_26 = exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_protected_seg_STEP_2;
+ assign cond_27 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_protected_seg_STEP_4;
+ assign cond_28 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_STEP_0;
+ assign cond_29 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_0;
+ assign cond_30 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_1;
+ assign cond_31 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_2;
+ assign cond_32 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_protected_seg_STEP_3;
+ assign cond_33 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_3;
+ assign cond_34 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_1;
+ assign cond_35 = glob_param_3[15:2] == 14'd0;
+ assign cond_36 = exe_ready;
+ assign cond_37 = exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_3;
+ assign cond_38 = ss_cache[`DESC_BIT_D_B];
+ assign cond_39 = exe_cmd == `CMD_CALL_3 && (exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_4 || exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_5);
+ assign cond_40 = exe_cmd == `CMD_CALL_3 && exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_6;
+ assign cond_41 = exe_cmd == `CMD_CALL_3 && exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_7;
+ assign cond_42 = glob_descriptor_2[`DESC_BIT_D_B];
+ assign cond_43 = exe_cmd == `CMD_CALL_3 && exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_8;
+ assign cond_44 = glob_param_2 > glob_desc_2_limit;
+ assign cond_45 = exe_cmd == `CMD_CALL_3 && exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_9;
+ assign cond_46 = exe_cmd == `CMD_CALL_3 && exe_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_10;
+ assign cond_47 = exe_cmd == `CMD_PUSH_MOV_SEG && { exe_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_implicit;
+ assign cond_48 = exe_cmd == `CMD_PUSH_MOV_SEG && { exe_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_modregrm;
+ assign cond_49 = exe_cmd == `CMD_NEG;
+ assign cond_50 = exe_cmd == `CMD_Jcc;
+ assign cond_51 = exe_mutex_current[`MUTEX_EFLAGS_BIT];
+ assign cond_52 = exe_condition && exe_branch_eip > cs_limit;
+ assign cond_53 = exe_cmd == `CMD_INVD && exe_cmdex == `CMDEX_INVD_STEP_0;
+ assign cond_54 = cpl > 2'd0;
+ assign cond_55 = exe_cmd == `CMD_INVD && exe_cmdex == `CMDEX_INVD_STEP_1;
+ assign cond_56 = ~(e_invd_code_done && e_invd_data_done);
+ assign cond_57 = exe_cmd == `CMD_INVLPG && exe_cmdex == `CMDEX_INVLPG_STEP_0;
+ assign cond_58 = exe_cmd == `CMD_INVLPG && exe_cmdex == `CMDEX_INVLPG_STEP_1;
+ assign cond_59 = ~(tlbflushsingle_done);
+ assign cond_60 = exe_cmd == `CMD_io_allow && exe_cmdex == `CMDEX_io_allow_2;
+ assign cond_61 = (  exe_is_8bit                       && e_io_allow_bits[0]   != 1'd0) || (~(exe_is_8bit) && exe_operand_16bit && e_io_allow_bits[1:0] != 2'd0) || (~(exe_is_8bit) && exe_operand_32bit && e_io_allow_bits[3:0] != 4'd0);
+ assign cond_62 = exe_cmd == `CMD_HLT && exe_cmdex == `CMDEX_HLT_STEP_0;
+ assign cond_63 = exe_cmd == `CMD_SCAS;
+ assign cond_64 = exe_cmd == `CMD_INC_DEC;
+ assign cond_65 = exe_cmd == `CMD_RET_near && exe_cmdex != `CMDEX_RET_near_LAST;
+ assign cond_66 = exe_cmdex == `CMDEX_RET_near;
+ assign cond_67 = exe_cmdex == `CMDEX_RET_near_imm;
+ assign cond_68 = exe_cmd == `CMD_ARPL;
+ assign cond_69 = exe_cmd == `CMD_BSWAP;
+ assign cond_70 = exe_cmd == `CMD_LxS;
+ assign cond_71 = (exe_cmd == `CMD_LLDT || exe_cmd == `CMD_LTR) && exe_cmdex == `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1;
+ assign cond_72 = cpl != 2'd0;
+ assign cond_73 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_int_trap_gate_STEP_0;
+ assign cond_74 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_1;
+ assign cond_75 = v8086_mode && exe_descriptor[`DESC_BITS_DPL] != 2'd0;
+ assign cond_76 = ~(exe_trigger_gp_fault) && glob_param_3[15:2] == 14'd0;
+ assign cond_77 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_3;
+ assign cond_78 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_5;
+ assign cond_79 = exe_cmd == `CMD_int_3 && (exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_4 || exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_5);
+ assign cond_80 = ~(exe_mutex_current[`MUTEX_ACTIVE_BIT]) && exe_ready;
+ assign cond_81 = exe_cmd == `CMD_int_3 && exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_6;
+ assign cond_82 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_STEP_0;
+ assign cond_83 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_STEP_1;
+ assign cond_84 = exc_soft_int_ib && v8086_mode && iopl < 2'd3;
+ assign cond_85 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_real_STEP_0;
+ assign cond_86 = { 6'd0, exc_vector[7:0], 2'b11 } > idtr_limit;
+ assign cond_87 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_real_STEP_1;
+ assign cond_88 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_real_STEP_2;
+ assign cond_89 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_real_STEP_3;
+ assign cond_90 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_real_STEP_5;
+ assign cond_91 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_protected_STEP_0;
+ assign cond_92 = { 5'd0, exc_vector[7:0], 3'b111 } > idtr_limit;
+ assign cond_93 = exe_cmd == `CMD_int && exe_cmdex == `CMDEX_int_protected_STEP_1;
+ assign cond_94 = exe_descriptor[`DESC_BIT_SEG] || ( (   exe_descriptor[`DESC_BITS_TYPE] != `DESC_TASK_GATE && exe_descriptor[`DESC_BITS_TYPE] != `DESC_INTERRUPT_GATE_386 && exe_descriptor[`DESC_BITS_TYPE] != `DESC_INTERRUPT_GATE_286 && exe_descriptor[`DESC_BITS_TYPE] != `DESC_TRAP_GATE_386      && exe_descriptor[`DESC_BITS_TYPE] != `DESC_TRAP_GATE_286 ) || (exc_soft_int && exe_descriptor[`DESC_BITS_DPL] < cpl) );
+ assign cond_95 = ~(exe_trigger_gp_fault) && exe_descriptor[`DESC_BIT_P] == `FALSE;
+ assign cond_96 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_0;
+ assign cond_97 = exe_int_2_int_trap_same_exception || (glob_param_2 > glob_desc_limit);
+ assign cond_98 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_1;
+ assign cond_99 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_2;
+ assign cond_100 = exe_cmd == `CMD_int_2 && exe_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_3;
+ assign cond_101 = exe_cmd == `CMD_int_2  && exe_cmdex >= `CMDEX_int_2_int_trap_gate_more_STEP_4;
+ assign cond_102 = exe_cmd == `CMD_int_3  && exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_0;
+ assign cond_103 = exe_cmd == `CMD_int_3  && exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_1;
+ assign cond_104 = exe_cmd == `CMD_int_3  && exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_2;
+ assign cond_105 = exe_cmd == `CMD_int_3  && exe_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_3;
+ assign cond_106 = exe_cmd == `CMD_AAD;
+ assign cond_107 = mult_busy;
+ assign cond_108 = exe_cmd == `CMD_AAM;
+ assign cond_109 = exe_div_exception || div_busy;
+ assign cond_110 = exe_cmd == `CMD_load_seg && exe_cmdex == `CMDEX_load_seg_STEP_1;
+ assign cond_111 = protected_mode;
+ assign cond_112 = ((glob_param_1[18:16] == `SEGMENT_SS || glob_param_1[18:16] == `SEGMENT_TR || glob_param_1[18:16] == `SEGMENT_CS) && glob_param_1[15:2] == 14'd0) ||  ((glob_param_1[18:16] == `SEGMENT_LDT || glob_param_1[18:16] == `SEGMENT_TR) && glob_param_1[`SELECTOR_BIT_TI] == 1'b1);
+ assign cond_113 = exe_cmd == `CMD_load_seg && exe_cmdex == `CMDEX_load_seg_STEP_2;
+ assign cond_114 = ~(protected_mode && glob_param_1[15:2] == 14'd0);
+ assign cond_115 = exe_load_seg_gp_fault || exe_load_seg_ss_fault || exe_load_seg_np_fault;
+ assign cond_116 = exe_cmd == `CMD_POP_seg;
+ assign cond_117 = { exe_cmd[6:2], 2'd0 } == `CMD_BTx;
+ assign cond_118 = exe_cmd == `CMD_IRET_2 && exe_cmdex == `CMDEX_IRET_2_protected_same_STEP_0;
+ assign cond_119 = exe_cmd == `CMD_IRET_2 && exe_cmdex == `CMDEX_IRET_2_protected_same_STEP_1;
+ assign cond_120 = exe_cmd == `CMD_IRET_2  && exe_cmdex == `CMDEX_IRET_2_protected_outer_STEP_3;
+ assign cond_121 = exe_cmd == `CMD_IRET_2  && exe_cmdex == `CMDEX_IRET_2_protected_outer_STEP_5;
+ assign cond_122 = exe_cmd == `CMD_IRET_2 && exe_cmdex == `CMDEX_IRET_2_protected_outer_STEP_6;
+ assign cond_123 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_real_v86_STEP_0;
+ assign cond_124 = v8086_mode && iopl < 2'd3;
+ assign cond_125 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_real_v86_STEP_1;
+ assign cond_126 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_real_v86_STEP_2;
+ assign cond_127 = ~(v8086_mode) && glob_param_2 > cs_limit;
+ assign cond_128 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_real_v86_STEP_3;
+ assign cond_129 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_task_switch_STEP_0;
+ assign cond_130 = glob_param_1[`SELECTOR_BIT_TI];
+ assign cond_131 = exe_cmd == `CMD_IRET && exe_cmdex == `CMDEX_IRET_task_switch_STEP_1;
+ assign cond_132 = glob_param_2[1] || exe_descriptor[`DESC_BIT_SEG] || (exe_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_BUSY_386 && exe_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_BUSY_286);
+ assign cond_133 = glob_param_2[1] == 1'b0 && ~(exe_trigger_ts_fault) && ~(exe_descriptor[`DESC_BIT_P]);
+ assign cond_134 = exe_cmd == `CMD_IRET && exe_cmdex >= `CMDEX_IRET_protected_to_v86_STEP_0;
+ assign cond_135 = exe_cmd == `CMD_IRET_2 && exe_cmdex == `CMDEX_IRET_2_protected_to_v86_STEP_6;
+ assign cond_136 = exe_cmd == `CMD_IRET_2 && exe_cmdex == `CMDEX_IRET_2_protected_outer_STEP_0;
+ assign cond_137 = glob_param_1[`SELECTOR_BITS_RPL] != glob_param_3[`SELECTOR_BITS_RPL];
+ assign cond_138 = exe_cmd == `CMD_POP && exe_cmdex == `CMDEX_POP_implicit;
+ assign cond_139 = exe_cmd == `CMD_POP && exe_cmdex == `CMDEX_POP_modregrm_STEP_0;
+ assign cond_140 = exe_cmd == `CMD_POP && exe_cmdex == `CMDEX_POP_modregrm_STEP_1;
+ assign cond_141 = exe_cmd == `CMD_IDIV || exe_cmd == `CMD_DIV;
+ assign cond_142 = exe_cmd == `CMD_Shift && exe_decoder[13:12] == 2'b01;
+ assign cond_143 = exe_cmd == `CMD_Shift && exe_decoder[13:12] != 2'b01;
+ assign cond_144 = exe_cmd == `CMD_CMPS;
+ assign cond_145 = exe_cmd == `CMD_control_reg && exe_cmdex == `CMDEX_control_reg_LMSW_STEP_0;
+ assign cond_146 = exe_cmd == `CMD_control_reg && exe_cmdex == `CMDEX_control_reg_MOV_store_STEP_0;
+ assign cond_147 = exe_modregrm_reg == 3'd0;
+ assign cond_148 = exe_modregrm_reg == 3'd2;
+ assign cond_149 = exe_modregrm_reg == 3'd3;
+ assign cond_150 = exe_cmd == `CMD_control_reg && exe_cmdex == `CMDEX_control_reg_MOV_load_STEP_0;
+ assign cond_151 = cpl > 2'd0 || (exe_modregrm_reg == 3'd0 && ((src[31] && ~(src[0])) || (src[29] && ~(src[30]))));
+ assign cond_152 = exe_cmd == `CMD_control_reg && exe_cmdex == `CMDEX_control_reg_SMSW_STEP_0;
+ assign cond_153 = exe_cmd == `CMD_LGDT || exe_cmd == `CMD_LIDT;
+ assign cond_154 = exe_cmd == `CMD_PUSHA;
+ assign cond_155 = exe_cmdex[2:0] == 3'd4;
+ assign cond_156 = exe_cmd == `CMD_fpu && exe_cmdex == `CMDEX_ESC_STEP_0;
+ assign cond_157 = cr0_em || cr0_ts;
+ assign cond_158 = exe_cmd == `CMD_SETcc;
+ assign cond_159 = exe_condition;
+ assign cond_160 = exe_cmd == `CMD_CMPXCHG;
+ assign cond_161 = exe_mutex_current[`MUTEX_EAX_BIT];
+ assign cond_162 = exe_cmd == `CMD_ENTER && exe_cmdex == `CMDEX_ENTER_FIRST;
+ assign cond_163 = exe_cmd == `CMD_ENTER && exe_cmdex == `CMDEX_ENTER_LAST;
+ assign cond_164 = exe_cmd == `CMD_ENTER && (exe_cmdex == `CMDEX_ENTER_PUSH || exe_cmdex == `CMDEX_ENTER_LOOP);
+ assign cond_165 = exe_cmdex == `CMDEX_ENTER_PUSH;
+ assign cond_166 = exe_cmd == `CMD_IMUL;
+ assign cond_167 = exe_cmd == `CMD_LEAVE;
+ assign cond_168 = { exe_cmd[6:1], 1'd0 } == `CMD_SHxD;
+ assign cond_169 = exe_cmd == `CMD_WBINVD && exe_cmdex == `CMDEX_WBINVD_STEP_0;
+ assign cond_170 = exe_cmd == `CMD_WBINVD && exe_cmdex == `CMDEX_WBINVD_STEP_1;
+ assign cond_171 = ~(e_wbinvd_code_done && e_wbinvd_data_done);
+ assign cond_172 = { exe_cmd[6:3], 3'd0 } == `CMD_Arith;
+ assign cond_173 = exe_cmd[2:1] == 2'b01 && exe_mutex_current[`MUTEX_EFLAGS_BIT];
+ assign cond_174 = exe_cmd == `CMD_MUL;
+ assign cond_175 = exe_cmd == `CMD_LOOP;
+ assign cond_176 = exe_mutex_current[`MUTEX_ECX_BIT] || (exe_mutex_current[`MUTEX_EFLAGS_BIT] && (exe_cmdex == `CMDEX_LOOP_NE || exe_cmdex == `CMDEX_LOOP_E));
+ assign cond_177 = exe_cmd_loop_condition && exe_branch_eip > cs_limit;
+ assign cond_178 = exe_cmd == `CMD_TEST;
+ assign cond_179 = exe_cmd == `CMD_CLTS;
+ assign cond_180 = exe_cmd == `CMD_RET_far  && exe_cmdex == `CMDEX_RET_far_STEP_1;
+ assign cond_181 = exe_cmd == `CMD_RET_far && exe_cmdex == `CMDEX_RET_far_STEP_2;
+ assign cond_182 = (v8086_mode || real_mode) && glob_param_2 > cs_limit;
+ assign cond_183 = exe_cmd == `CMD_RET_far && exe_cmdex == `CMDEX_RET_far_same_STEP_3;
+ assign cond_184 = exe_cmd == `CMD_RET_far && exe_cmdex == `CMDEX_RET_far_outer_STEP_5;
+ assign cond_185 = exe_cmd == `CMD_RET_far && exe_cmdex == `CMDEX_RET_far_outer_STEP_6;
+ assign cond_186 = exe_cmd == `CMD_RET_far && exe_cmdex == `CMDEX_RET_far_outer_STEP_7;
+ assign cond_187 = exe_cmd == `CMD_RET_far && (exe_cmdex == `CMDEX_RET_far_real_STEP_3 || exe_cmdex == `CMDEX_RET_far_same_STEP_4);
+ assign cond_188 = exe_cmdex == `CMDEX_RET_far_real_STEP_3;
+ assign cond_189 = exe_cmd == `CMD_LODS;
+ assign cond_190 = exe_cmd == `CMD_XCHG && exe_cmdex == `CMDEX_XCHG_implicit;
+ assign cond_191 = exe_cmd == `CMD_XCHG && exe_cmdex == `CMDEX_XCHG_modregrm;
+ assign cond_192 = exe_cmd == `CMD_XCHG && exe_cmdex == `CMDEX_XCHG_modregrm_LAST;
+ assign cond_193 = exe_cmd == `CMD_PUSH;
+ assign cond_194 = exe_cmdex == `CMDEX_PUSH_immediate_se;
+ assign cond_195 = exe_cmd == `CMD_IN && exe_cmdex == `CMDEX_IN_protected;
+ assign cond_196 = exe_cmd == `CMD_IN && (exe_cmdex == `CMDEX_IN_dx || exe_cmdex == `CMDEX_IN_imm);
+ assign cond_197 = exe_cmdex == `CMDEX_IN_dx && exe_mutex_current[`MUTEX_EDX_BIT];
+ assign cond_198 = exe_cmd == `CMD_NOT;
+ assign cond_199 = (exe_cmd == `CMD_LAR || exe_cmd == `CMD_LSL) && exe_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_LAST;
+ assign cond_200 = (exe_cmd == `CMD_LAR || exe_cmd == `CMD_LSL || exe_cmd == `CMD_VERR || exe_cmd == `CMD_VERW) && exe_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_2;
+ assign cond_201 = (exe_cmd == `CMD_CALL && exe_cmdex == `CMDEX_CALL_protected_STEP_0) || (exe_cmd == `CMD_JMP  && exe_cmdex == `CMDEX_JMP_protected_STEP_0);
+ assign cond_202 = glob_param_1[15:2] == 14'd0 || (exe_descriptor[`DESC_BIT_SEG] == `FALSE && ( exe_descriptor[`DESC_BITS_DPL] < cpl || exe_descriptor[`DESC_BITS_DPL] < exe_selector[`SELECTOR_BITS_RPL] || ((exe_descriptor[`DESC_BITS_TYPE] == 4'd1 || exe_descriptor[`DESC_BITS_TYPE] == 4'd9) && exe_selector[`SELECTOR_BIT_TI]) ||  exe_descriptor[`DESC_BITS_TYPE] == 4'd0  || exe_descriptor[`DESC_BITS_TYPE] == 4'd8  || exe_descriptor[`DESC_BITS_TYPE] == 4'd10 || exe_descriptor[`DESC_BITS_TYPE] == 4'd13 ||  exe_descriptor[`DESC_BITS_TYPE] == 4'd2  || exe_descriptor[`DESC_BITS_TYPE] == 4'd3  || exe_descriptor[`DESC_BITS_TYPE] == 4'd6  || exe_descriptor[`DESC_BITS_TYPE] == 4'd7  || exe_descriptor[`DESC_BITS_TYPE] == 4'd11 || exe_descriptor[`DESC_BITS_TYPE] == 4'd14 || exe_descriptor[`DESC_BITS_TYPE] == 4'd15)  ) || (exe_descriptor[`DESC_BIT_SEG] && ( `DESC_IS_DATA(exe_descriptor) || (`DESC_IS_CODE_NON_CONFORMING(exe_descriptor) && (exe_descriptor[`DESC_BITS_DPL] != cpl || exe_selector[`SELECTOR_BITS_RPL] > cpl)) || (`DESC_IS_CODE_CONFORMING(exe_descriptor)     &&  exe_descriptor[`DESC_BITS_DPL] > cpl))  ) ;
+ assign cond_203 = ~(exe_trigger_gp_fault) && exe_descriptor[`DESC_BIT_P] == `FALSE &&  (exe_descriptor[`DESC_BIT_SEG] || exe_descriptor[`DESC_BITS_TYPE] == 4'd1 || exe_descriptor[`DESC_BITS_TYPE] == 4'd9 ||  exe_descriptor[`DESC_BITS_TYPE] == 4'd4 || exe_descriptor[`DESC_BITS_TYPE] == 4'd12 ||  exe_descriptor[`DESC_BITS_TYPE] == 4'd5)  ;
+ assign cond_204 = (exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_task_switch_STEP_0) || (exe_cmd == `CMD_JMP    && exe_cmdex == `CMDEX_JMP_task_switch_STEP_0);
+ assign cond_205 = exe_cmd == `CMD_CALL_2;
+ assign cond_206 = exe_cmd == `CMD_JMP;
+ assign cond_207 = (exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_task_gate_STEP_1) || (exe_cmd == `CMD_JMP    && exe_cmdex == `CMDEX_JMP_task_gate_STEP_1) || (exe_cmd == `CMD_int    && exe_cmdex == `CMDEX_int_task_gate_STEP_1);
+ assign cond_208 = glob_param_1[`SELECTOR_BIT_TI] || glob_descriptor[`DESC_BIT_SEG] || (glob_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_AVAIL_386 && glob_descriptor[`DESC_BITS_TYPE] != `DESC_TSS_AVAIL_286);
+ assign cond_209 = exe_cmd == `CMD_int;
+ assign cond_210 = exe_cmd != `CMD_int;
+ assign cond_211 = (exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_STEP_1) || (exe_cmd == `CMD_int    && exe_cmdex == `CMDEX_int_int_trap_gate_STEP_1);
+ assign cond_212 = glob_param_1[15:2] == 14'd0 || glob_descriptor[`DESC_BIT_SEG] == `FALSE ||  `DESC_IS_DATA(glob_descriptor) || glob_descriptor[`DESC_BITS_DPL] > cpl;
+ assign cond_213 = (exe_cmd == `CMD_CALL_2 && exe_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_2) || (exe_cmd == `CMD_int_2  && exe_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_2);
+ assign cond_214 = glob_param_5[0] || glob_param_1[`SELECTOR_BITS_RPL] != glob_descriptor_2[`DESC_BITS_DPL] ||  glob_descriptor[`DESC_BITS_DPL] != glob_descriptor_2[`DESC_BITS_DPL] || glob_descriptor[`DESC_BIT_SEG] == `FALSE || `DESC_IS_CODE(glob_descriptor) || `DESC_IS_DATA_RO(glob_descriptor);
+ assign cond_215 = glob_param_5[0] == 1'b0 && ~(exe_trigger_ts_fault) && ~(glob_descriptor[`DESC_BIT_P]);
+ assign cond_216 = exe_cmd == `CMD_STOS;
+ assign cond_217 = exe_cmd == `CMD_INS;
+ assign cond_218 = exe_mutex_current[`MUTEX_EDX_BIT];
+ assign cond_219 = exe_cmd == `CMD_OUTS;
+ assign cond_220 = exe_cmd == `CMD_PUSHF;
+ assign cond_221 = exe_mutex_current[`MUTEX_ESP_BIT] || exe_mutex_current[`MUTEX_EFLAGS_BIT];
+ assign cond_222 = exe_cmd == `CMD_JMP  && (exe_cmdex == `CMDEX_JMP_Ev_STEP_0  || exe_cmdex == `CMDEX_JMP_Ep_STEP_0  || exe_cmdex == `CMDEX_JMP_Ap_STEP_0);
+ assign cond_223 = exe_cmd == `CMD_JMP  && exe_cmdex == `CMDEX_JMP_Jv_STEP_0;
+ assign cond_224 = exe_cmd == `CMD_CALL && exe_mutex_current[`MUTEX_ESP_BIT];
+ assign cond_225 = exe_cmd == `CMD_JMP  && exe_cmdex == `CMDEX_JMP_Ev_Jv_STEP_1;
+ assign cond_226 = exe_cmd == `CMD_JMP  && exe_cmdex == `CMDEX_JMP_Ep_STEP_1;
+ assign cond_227 = exe_cmd == `CMD_JMP  && exe_cmdex == `CMDEX_JMP_Ap_STEP_1;
+ assign cond_228 = exe_cmd == `CMD_JMP && exe_cmdex == `CMDEX_JMP_real_v8086_STEP_0;
+ assign cond_229 = exe_cmd == `CMD_JMP && exe_cmdex == `CMDEX_JMP_real_v8086_STEP_1;
+ assign cond_230 = exe_cmd == `CMD_JMP && exe_cmdex == `CMDEX_JMP_protected_seg_STEP_0;
+ assign cond_231 = exe_cmd == `CMD_JMP && exe_cmdex == `CMDEX_JMP_protected_seg_STEP_1;
+ assign cond_232 = exe_cmd == `CMD_JMP_2 && exe_cmdex == `CMDEX_JMP_2_call_gate_STEP_1;
+ assign cond_233 = glob_param_1[15:2] == 14'd0 || glob_descriptor[`DESC_BIT_SEG] == `FALSE || `DESC_IS_DATA(glob_descriptor) || (`DESC_IS_CODE_NON_CONFORMING(exe_descriptor) && exe_descriptor[`DESC_BITS_DPL] != cpl) || (`DESC_IS_CODE_CONFORMING(exe_descriptor)     && exe_descriptor[`DESC_BITS_DPL] > cpl);
+ assign cond_234 = exe_cmd == `CMD_JMP_2 && exe_cmdex == `CMDEX_JMP_2_call_gate_STEP_2;
+ assign cond_235 = exe_cmd == `CMD_JMP_2 && exe_cmdex == `CMDEX_JMP_2_call_gate_STEP_3;
+ assign cond_236 = exe_cmd == `CMD_OUT && (exe_cmdex == `CMDEX_OUT_dx || exe_cmdex == `CMDEX_OUT_imm);
+ assign cond_237 = exe_cmdex == `CMDEX_OUT_dx && exe_mutex_current[`MUTEX_EDX_BIT];
+ assign cond_238 = exe_cmd == `CMD_OUT && exe_cmdex == `CMDEX_OUT_protected;
+ assign cond_239 = exe_cmd == `CMD_MOV;
+ assign cond_240 = exe_cmd == `CMD_POPF && exe_cmdex == `CMDEX_POPF_STEP_0;
+ assign cond_241 = exe_cmd == `CMD_CLI || exe_cmd == `CMD_STI;
+ assign cond_242 = (protected_mode && iopl < cpl) || (v8086_mode && iopl != 2'd3);
+ assign cond_243 = exe_cmd == `CMD_BOUND && exe_cmdex == `CMDEX_BOUND_STEP_FIRST;
+ assign cond_244 = exe_cmd == `CMD_BOUND && exe_cmdex == `CMDEX_BOUND_STEP_LAST;
+ assign cond_245 = exe_bound_fault;
+ assign cond_246 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_1;
+ assign cond_247 = glob_desc_limit < exe_new_tss_max;
+ assign cond_248 = tr_limit < ((tr_cache[`DESC_BITS_TYPE] <= 4'd3)? 32'h29 : 32'h5F);
+ assign cond_249 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_2;
+ assign cond_250 = ~(tlbcheck_done) && ~(tlbcheck_page_fault);
+ assign cond_251 = tlbcheck_page_fault;
+ assign cond_252 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_3;
+ assign cond_253 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_4;
+ assign cond_254 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_5;
+ assign cond_255 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_7;
+ assign cond_256 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_8;
+ assign cond_257 = exe_cmd == `CMD_task_switch && exe_cmdex == `CMDEX_task_switch_STEP_10;
+ assign cond_258 = exe_cmd == `CMD_task_switch && exe_cmdex >= `CMDEX_task_switch_STEP_12 && exe_cmdex <= `CMDEX_task_switch_STEP_14;
+ assign cond_259 = exe_cmd == `CMD_task_switch_2;
+ assign cond_260 = exe_cmdex <= `CMDEX_task_switch_2_STEP_7;
+ assign cond_261 = exe_cmdex > `CMDEX_task_switch_2_STEP_7;
+ assign cond_262 = exe_cmd == `CMD_task_switch_3;
+ assign cond_263 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_0;
+ assign cond_264 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_2;
+ assign cond_265 = glob_param_2[2] || glob_param_2[2:0] == 3'b010 || ( glob_param_2[2:0] == 3'b000 && ( exe_descriptor[`DESC_BIT_SEG] || exe_descriptor[`DESC_BITS_TYPE] != `DESC_LDT ||  exe_descriptor[`DESC_BIT_P] == `FALSE ) );
+ assign cond_266 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_3;
+ assign cond_267 = ~(v8086_mode);
+ assign cond_268 = glob_param_2[1:0] != 2'b00 || ( exe_descriptor[`DESC_BIT_SEG] == 1'b0 || `DESC_IS_CODE(exe_descriptor) || `DESC_IS_DATA_RO(exe_descriptor) || (exe_descriptor[`DESC_BIT_P] && ( exe_descriptor[`DESC_BITS_DPL] != wr_task_rpl || exe_descriptor[`DESC_BITS_DPL] != exe_selector[`SELECTOR_BITS_RPL] ) ) );
+ assign cond_269 = glob_param_2[1:0] == 2'b00 && exe_descriptor[`DESC_BIT_SEG] && `DESC_IS_DATA_RW(exe_descriptor) && ~(exe_descriptor[`DESC_BIT_P]);
+ assign cond_270 = exe_cmd == `CMD_task_switch_4 && exe_cmdex >= `CMDEX_task_switch_4_STEP_4 && exe_cmdex <= `CMDEX_task_switch_4_STEP_7;
+ assign cond_271 = glob_param_2[1:0] == 2'b10 || (glob_param_2[1:0] == 2'b00 && ( exe_descriptor[`DESC_BIT_SEG] == 1'b0 || `DESC_IS_CODE_EO(exe_descriptor) || ((`DESC_IS_DATA(exe_descriptor) || `DESC_IS_CODE_NON_CONFORMING(exe_descriptor)) && exe_privilege_not_accepted) ));
+ assign cond_272 = glob_param_2[1:0] == 2'b00 && ~(exe_trigger_ts_fault) && ~(exe_descriptor[`DESC_BIT_P]);
+ assign cond_273 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_8;
+ assign cond_274 = glob_param_2[1:0] != 2'b00 || ( exe_descriptor[`DESC_BIT_SEG] == 1'b0 || `DESC_IS_DATA(exe_descriptor) || (`DESC_IS_CODE_NON_CONFORMING(exe_descriptor) && exe_descriptor[`DESC_BITS_DPL] != exe_selector[`SELECTOR_BITS_RPL]) || (`DESC_IS_CODE_CONFORMING(exe_descriptor)     && exe_descriptor[`DESC_BITS_DPL] >  exe_selector[`SELECTOR_BITS_RPL]) );
+ assign cond_275 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_9;
+ assign cond_276 = exe_cmd == `CMD_task_switch_4 && exe_cmdex == `CMDEX_task_switch_4_STEP_10;
+ assign cond_277 = exe_eip > cs_limit;
+ assign cond_278 = exe_cmd == `CMD_LEA;
+ assign cond_279 = exe_cmd == `CMD_SGDT;
+ assign cond_280 = exe_cmdex == `CMDEX_SGDT_SIDT_STEP_1;
+ assign cond_281 = exe_cmdex == `CMDEX_SGDT_SIDT_STEP_2;
+ assign cond_282 = exe_cmd == `CMD_SIDT;
+ assign cond_283 = exe_cmd == `CMD_MOVS;
+ assign cond_284 = exe_cmd == `CMD_MOVSX || exe_cmd == `CMD_MOVZX;
+ assign cond_285 = exe_cmd == `CMD_POPA;
+ assign cond_286 = exe_cmd == `CMD_debug_reg && (exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 || exe_cmdex == `CMDEX_debug_reg_MOV_load_STEP_0);
+ assign cond_287 = exe_cmdex == `CMDEX_debug_reg_MOV_load_STEP_0;
+ assign cond_288 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && exe_modregrm_reg == 3'd0;
+ assign cond_289 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && exe_modregrm_reg == 3'd1;
+ assign cond_290 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && exe_modregrm_reg == 3'd2;
+ assign cond_291 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && exe_modregrm_reg == 3'd3;
+ assign cond_292 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && (exe_modregrm_reg == 3'd4 || exe_modregrm_reg == 3'd6);
+ assign cond_293 = exe_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0 && (exe_modregrm_reg == 3'd5 || exe_modregrm_reg == 3'd7);
+ assign cond_294 = dr7[`DR7_BIT_GD];
+ assign cond_295 = exe_cmd == `CMD_XLAT;
+ assign cond_296 = exe_cmd == `CMD_AAA || exe_cmd == `CMD_AAS || exe_cmd == `CMD_DAA || exe_cmd == `CMD_DAS;
+ assign cond_297 = { exe_cmd[6:1], 1'd0 } == `CMD_BSx;
+ assign cond_298 = exe_cmd == `CMD_BSF;
+ assign cond_299 = exe_cmd == `CMD_BSR;
 //======================================================== saves
-wire [31:0] exe_buffer_to_reg =
+ assign exe_buffer_to_reg =
     (cond_0)? ( dst) :
     (cond_134 && cond_36)? ( src) :
     (cond_139)? ( src) :
@@ -428,8 +382,8 @@ wire [31:0] exe_buffer_to_reg =
     (cond_285 && cond_36)? ( src) :
     exe_buffer;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) exe_buffer <= 32'd0;
+always @(posedge clk) begin
+    if(rst) exe_buffer <= 32'd0;
     else              exe_buffer <= exe_buffer_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/icache.v b/rtl/ao486/autogen/icache.v
index 5aa0945..c2fc4e9 100644
--- a/rtl/ao486/autogen/icache.v
+++ b/rtl/ao486/autogen/icache.v
@@ -1,30 +1,56 @@
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire cond_12;
+wire cond_13;
+wire cond_14;
+wire cond_15;
+wire cond_16;
+wire cond_17;
+wire cond_18;
+wire cond_19;
+wire [31:0] address_to_reg ;
+wire [1:0] state_to_reg ;
+wire [4:0] length_to_reg ;
+wire cache_disable_to_reg;
+wire [11:0] partial_length_to_reg ;
+
 //======================================================== conditions
-wire cond_0 = state == STATE_IDLE;
-wire cond_1 = invdcode_do;
-wire cond_2 = ~(dcachetoicache_accept_empty);
-wire cond_3 = ~(pr_reset) && icacheread_do && icacheread_length > 5'd0;
-wire cond_4 = icacheread_do && icacheread_cache_disable;
-wire cond_5 = icacheread_do && ~(icacheread_cache_disable);
-wire cond_6 = state == STATE_INVALIDATE_WRITE;
-wire cond_7 = state == STATE_CHECK;
-wire cond_8 = matched;
-wire cond_9 = pr_reset == `FALSE && reset_waiting == `FALSE;
-wire cond_10 = ~(cache_disable);
-wire cond_11 = state == STATE_READ;
-wire cond_12 = readcode_partial_done || readcode_done;
-wire cond_13 = partial_length[2:0] > 3'd0 && length > 5'd0;
-wire cond_14 = readcode_done && ~(cache_disable);
-wire cond_15 = plru_index[1:0] == 2'd0;
-wire cond_16 = plru_index[1:0] == 2'd1;
-wire cond_17 = plru_index[1:0] == 2'd2;
-wire cond_18 = plru_index[1:0] == 2'd3;
-wire cond_19 = readcode_done;
+ assign cond_0 = state == STATE_IDLE;
+ assign cond_1 = invdcode_do;
+ assign cond_2 = ~(dcachetoicache_accept_empty);
+ assign cond_3 = ~(pr_reset) && icacheread_do && icacheread_length > 5'd0;
+ assign cond_4 = icacheread_do && icacheread_cache_disable;
+ assign cond_5 = icacheread_do && ~(icacheread_cache_disable);
+ assign cond_6 = state == STATE_INVALIDATE_WRITE;
+ assign cond_7 = state == STATE_CHECK;
+ assign cond_8 = matched;
+ assign cond_9 = pr_reset == `FALSE && reset_waiting == `FALSE;
+ assign cond_10 = ~(cache_disable);
+ assign cond_11 = state == STATE_READ;
+ assign cond_12 = readcode_partial_done || readcode_done;
+ assign cond_13 = partial_length[2:0] > 3'd0 && length > 5'd0;
+ assign cond_14 = readcode_done && ~(cache_disable);
+ assign cond_15 = plru_index[1:0] == 2'd0;
+ assign cond_16 = plru_index[1:0] == 2'd1;
+ assign cond_17 = plru_index[1:0] == 2'd2;
+ assign cond_18 = plru_index[1:0] == 2'd3;
+ assign cond_19 = readcode_done;
 //======================================================== saves
-wire [31:0] address_to_reg =
+ assign address_to_reg =
     (cond_0 && ~cond_1 && cond_2)? ( dcachetoicache_accept_address) :
     (cond_0 && ~cond_1 && ~cond_2 && cond_3)? ( icacheread_address) :
     address;
-wire [1:0] state_to_reg =
+ assign state_to_reg =
     (cond_0 && ~cond_1 && cond_2)? ( STATE_INVALIDATE_WRITE) :
     (cond_0 && ~cond_1 && ~cond_2 && cond_3 && cond_4)? ( STATE_CHECK) :
     (cond_0 && ~cond_1 && ~cond_2 && cond_3 && cond_5)? ( STATE_CHECK) :
@@ -34,37 +60,37 @@ wire [1:0] state_to_reg =
     (cond_7 && ~cond_8 && ~cond_10)? ( STATE_READ) :
     (cond_11 && cond_19)? ( STATE_IDLE) :
     state;
-wire [4:0] length_to_reg =
+ assign length_to_reg =
     (cond_0)? (          icacheread_length) :
     (cond_11 && cond_9 && cond_12 && cond_13)? ( length - partial_length_current) :
     length;
-wire  cache_disable_to_reg =
+ assign cache_disable_to_reg =
     (cond_0)? (   icacheread_cache_disable) :
     cache_disable;
-wire [11:0] partial_length_to_reg =
+ assign partial_length_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && cond_3 && cond_4)? ( length_burst) :
     (cond_0 && ~cond_1 && ~cond_2 && cond_3 && cond_5)? ( length_line) :
     (cond_11 && cond_9 && cond_12)? ( { 3'd0, partial_length[11:3] }) :
     partial_length;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) address <= 32'd0;
+always @(posedge clk) begin
+    if(rst) address <= 32'd0;
     else              address <= address_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) state <= 2'd0;
+always @(posedge clk) begin
+    if(rst) state <= 2'd0;
     else              state <= state_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) length <= 5'd0;
+always @(posedge clk) begin
+    if(rst) length <= 5'd0;
     else              length <= length_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) cache_disable <= 1'd0;
+always @(posedge clk) begin
+    if(rst) cache_disable <= 1'd0;
     else              cache_disable <= cache_disable_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) partial_length <= 12'd0;
+always @(posedge clk) begin
+    if(rst) partial_length <= 12'd0;
     else              partial_length <= partial_length_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/icache_control_ram.v b/rtl/ao486/autogen/icache_control_ram.v
index da310b7..65edcdd 100644
--- a/rtl/ao486/autogen/icache_control_ram.v
+++ b/rtl/ao486/autogen/icache_control_ram.v
@@ -1,41 +1,51 @@
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire after_invalidate_to_reg;
+wire [7:0] invd_counter_to_reg ;
+wire state_to_reg;
+wire init_done_to_reg;
+
 //======================================================== conditions
-wire cond_0 = init_done == `FALSE;
-wire cond_1 = invd_counter == 8'd255;
-wire cond_2 = state == STATE_IDLE;
-wire cond_3 = init_done && invdcode_do;
-wire cond_4 = state == STATE_INVD;
+ assign cond_0 = init_done == `FALSE;
+ assign cond_1 = invd_counter == 8'd255;
+ assign cond_2 = state == STATE_IDLE;
+ assign cond_3 = init_done && invdcode_do;
+ assign cond_4 = state == STATE_INVD;
 //======================================================== saves
-wire  after_invalidate_to_reg =
+ assign after_invalidate_to_reg =
     (cond_0 && cond_1)? ( `TRUE) :
     (cond_2)? ( `FALSE) :
     (cond_4 && cond_1)? ( `TRUE) :
     after_invalidate;
-wire [7:0] invd_counter_to_reg =
+ assign invd_counter_to_reg =
     (cond_0)? ( invd_counter + 8'd1) :
     (cond_4)? ( invd_counter + 8'd1) :
     invd_counter;
-wire  state_to_reg =
+ assign state_to_reg =
     (cond_2 && cond_3)? ( STATE_INVD) :
     (cond_4 && cond_1)? ( STATE_IDLE) :
     state;
-wire  init_done_to_reg =
+ assign init_done_to_reg =
     (cond_0 && cond_1)? ( `TRUE) :
     init_done;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) after_invalidate <= 1'd0;
+always @(posedge clk) begin
+    if(rst) after_invalidate <= 1'd0;
     else              after_invalidate <= after_invalidate_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) invd_counter <= 8'd0;
+always @(posedge clk) begin
+    if(rst) invd_counter <= 8'd0;
     else              invd_counter <= invd_counter_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) state <= 1'd0;
+always @(posedge clk) begin
+    if(rst) state <= 1'd0;
     else              state <= state_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) init_done <= 1'd0;
+always @(posedge clk) begin
+    if(rst) init_done <= 1'd0;
     else              init_done <= init_done_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/memory_read.v b/rtl/ao486/autogen/memory_read.v
index 96867ed..f1c948d 100644
--- a/rtl/ao486/autogen/memory_read.v
+++ b/rtl/ao486/autogen/memory_read.v
@@ -1,63 +1,80 @@
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire [55:0] buffer_to_reg ;
+wire [31:0] address_2_reg_to_reg ;
+wire [3:0] length_2_reg_to_reg ;
+wire [63:0] read_data_to_reg ;
+wire [1:0] state_to_reg ;
+wire read_done_to_reg;
+
 //======================================================== conditions
-wire cond_0 = state == STATE_IDLE;
-wire cond_1 = read_do && ~(read_done) && ~(rd_reset) && ~(read_page_fault) && ~(read_ac_fault);
-wire cond_2 = state == STATE_FIRST_WAIT;
-wire cond_3 = tlbread_page_fault || tlbread_ac_fault || (tlbread_retry && reset_waiting);
-wire cond_4 = tlbread_done && length_2_reg != 4'd0;
-wire cond_5 = tlbread_done;
-wire cond_6 = rd_reset == `FALSE && reset_waiting == `FALSE;
-wire cond_7 = state == STATE_SECOND;
-wire cond_8 = tlbread_page_fault || tlbread_ac_fault || tlbread_done || (tlbread_retry && reset_waiting);
-wire cond_9 = tlbread_done && rd_reset == `FALSE && reset_waiting == `FALSE;
+ assign cond_0 = state == STATE_IDLE;
+ assign cond_1 = read_do && ~(read_done) && ~(rd_reset) && ~(read_page_fault) && ~(read_ac_fault);
+ assign cond_2 = state == STATE_FIRST_WAIT;
+ assign cond_3 = tlbread_page_fault || tlbread_ac_fault || (tlbread_retry && reset_waiting);
+ assign cond_4 = tlbread_done && length_2_reg != 4'd0;
+ assign cond_5 = tlbread_done;
+ assign cond_6 = rd_reset == `FALSE && reset_waiting == `FALSE;
+ assign cond_7 = state == STATE_SECOND;
+ assign cond_8 = tlbread_page_fault || tlbread_ac_fault || tlbread_done || (tlbread_retry && reset_waiting);
+ assign cond_9 = tlbread_done && rd_reset == `FALSE && reset_waiting == `FALSE;
 //======================================================== saves
-wire [55:0] buffer_to_reg =
+ assign buffer_to_reg =
     (cond_2 && ~cond_3 && cond_4)? ( tlbread_data[55:0]) :
     buffer;
-wire [31:0] address_2_reg_to_reg =
+ assign address_2_reg_to_reg =
     (cond_0)? ( { address_2[31:4], 4'd0 }) :
     address_2_reg;
-wire [3:0] length_2_reg_to_reg =
+ assign length_2_reg_to_reg =
     (cond_0)? (  length_2) :
     length_2_reg;
-wire [63:0] read_data_to_reg =
+ assign read_data_to_reg =
     (cond_2 && ~cond_3 && ~cond_4 && cond_5 && cond_6)? ( tlbread_data) :
     (cond_7 && cond_9)? ( merged) :
     read_data;
-wire [1:0] state_to_reg =
+ assign state_to_reg =
     (cond_0 && cond_1)? ( STATE_FIRST_WAIT) :
     (cond_2 && cond_3)? ( STATE_IDLE) :
     (cond_2 && ~cond_3 && cond_4)? ( STATE_SECOND) :
     (cond_2 && ~cond_3 && ~cond_4 && cond_5)? ( STATE_IDLE) :
     (cond_7 && cond_8)? ( STATE_IDLE) :
     state;
-wire  read_done_to_reg =
+ assign read_done_to_reg =
     (cond_0)? ( `FALSE) :
     (cond_2 && ~cond_3 && ~cond_4 && cond_5 && cond_6)? ( `TRUE) :
     (cond_7 && cond_9)? ( `TRUE) :
     read_done;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) buffer <= 56'd0;
+always @(posedge clk) begin
+    if(rst) buffer <= 56'd0;
     else              buffer <= buffer_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) address_2_reg <= 32'd0;
+always @(posedge clk) begin
+    if(rst) address_2_reg <= 32'd0;
     else              address_2_reg <= address_2_reg_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) length_2_reg <= 4'd0;
+always @(posedge clk) begin
+    if(rst) length_2_reg <= 4'd0;
     else              length_2_reg <= length_2_reg_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) read_data <= 64'd0;
+always @(posedge clk) begin
+    if(rst) read_data <= 64'd0;
     else              read_data <= read_data_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) state <= 2'd0;
+always @(posedge clk) begin
+    if(rst) state <= 2'd0;
     else              state <= state_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) read_done <= 1'd0;
+always @(posedge clk) begin
+    if(rst) read_done <= 1'd0;
     else              read_done <= read_done_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/memory_write.v b/rtl/ao486/autogen/memory_write.v
index 9903caf..0de0067 100644
--- a/rtl/ao486/autogen/memory_write.v
+++ b/rtl/ao486/autogen/memory_write.v
@@ -1,29 +1,46 @@
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire [23:0] buffer_to_reg ;
+wire [31:0] address_2_reg_to_reg ;
+wire [2:0] length_2_reg_to_reg ;
+wire [1:0] state_to_reg ;
+
 //======================================================== conditions
-wire cond_0 = state == STATE_IDLE;
-wire cond_1 = length_1 == 3'd1;
-wire cond_2 = length_1 == 3'd2;
-wire cond_3 = write_do && ~(wr_reset) && ~(write_page_fault) && ~(write_ac_fault);
-wire cond_4 = state == STATE_FIRST_WAIT;
-wire cond_5 = tlbwrite_page_fault || tlbwrite_ac_fault;
-wire cond_6 = tlbwrite_done && length_2_reg != 3'd0;
-wire cond_7 = tlbwrite_done;
-wire cond_8 = reset_waiting == `FALSE;
-wire cond_9 = state == STATE_SECOND;
-wire cond_10 = tlbwrite_page_fault || tlbwrite_ac_fault || tlbwrite_done;
-wire cond_11 = tlbwrite_done && reset_waiting == `FALSE;
+ assign cond_0 = state == STATE_IDLE;
+ assign cond_1 = length_1 == 3'd1;
+ assign cond_2 = length_1 == 3'd2;
+ assign cond_3 = write_do && ~(wr_reset) && ~(write_page_fault) && ~(write_ac_fault);
+ assign cond_4 = state == STATE_FIRST_WAIT;
+ assign cond_5 = tlbwrite_page_fault || tlbwrite_ac_fault;
+ assign cond_6 = tlbwrite_done && length_2_reg != 3'd0;
+ assign cond_7 = tlbwrite_done;
+ assign cond_8 = reset_waiting == `FALSE;
+ assign cond_9 = state == STATE_SECOND;
+ assign cond_10 = tlbwrite_page_fault || tlbwrite_ac_fault || tlbwrite_done;
+ assign cond_11 = tlbwrite_done && reset_waiting == `FALSE;
 //======================================================== saves
-wire [23:0] buffer_to_reg =
+ assign buffer_to_reg =
     (cond_0 && cond_1)? ( write_data[31:8]) :
     (cond_0 && ~cond_1 && cond_2)? ( { 8'd0,  write_data[31:16] }) :
     (cond_0 && ~cond_1 && ~cond_2)? ( { 16'd0, write_data[31:24] }) :
     buffer;
-wire [31:0] address_2_reg_to_reg =
+ assign address_2_reg_to_reg =
     (cond_0)? ( { address_2[31:4], 4'd0 }) :
     address_2_reg;
-wire [2:0] length_2_reg_to_reg =
+ assign length_2_reg_to_reg =
     (cond_0)? (  length_2) :
     length_2_reg;
-wire [1:0] state_to_reg =
+ assign state_to_reg =
     (cond_0 && cond_3)? ( STATE_FIRST_WAIT) :
     (cond_4 && cond_5)? ( STATE_IDLE) :
     (cond_4 && ~cond_5 && cond_6)? ( STATE_SECOND) :
@@ -31,20 +48,20 @@ wire [1:0] state_to_reg =
     (cond_9 && cond_10)? ( STATE_IDLE) :
     state;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) buffer <= 24'd0;
+always @(posedge clk) begin
+    if(rst) buffer <= 24'd0;
     else              buffer <= buffer_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) address_2_reg <= 32'd0;
+always @(posedge clk) begin
+    if(rst) address_2_reg <= 32'd0;
     else              address_2_reg <= address_2_reg_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) length_2_reg <= 3'd0;
+always @(posedge clk) begin
+    if(rst) length_2_reg <= 3'd0;
     else              length_2_reg <= length_2_reg_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) state <= 2'd0;
+always @(posedge clk) begin
+    if(rst) state <= 2'd0;
     else              state <= state_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/microcode_commands.v b/rtl/ao486/autogen/microcode_commands.v
index dd433d1..1621563 100644
--- a/rtl/ao486/autogen/microcode_commands.v
+++ b/rtl/ao486/autogen/microcode_commands.v
@@ -1,216 +1,431 @@
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire cond_12;
+wire cond_13;
+wire cond_14;
+wire cond_15;
+wire cond_16;
+wire cond_17;
+wire cond_18;
+wire cond_19;
+wire cond_20;
+wire cond_21;
+wire cond_22;
+wire cond_23;
+wire cond_24;
+wire cond_25;
+wire cond_26;
+wire cond_27;
+wire cond_28;
+wire cond_29;
+wire cond_30;
+wire cond_31;
+wire cond_32;
+wire cond_33;
+wire cond_34;
+wire cond_35;
+wire cond_36;
+wire cond_37;
+wire cond_38;
+wire cond_39;
+wire cond_40;
+wire cond_41;
+wire cond_42;
+wire cond_43;
+wire cond_44;
+wire cond_45;
+wire cond_46;
+wire cond_47;
+wire cond_48;
+wire cond_49;
+wire cond_50;
+wire cond_51;
+wire cond_52;
+wire cond_53;
+wire cond_54;
+wire cond_55;
+wire cond_56;
+wire cond_57;
+wire cond_58;
+wire cond_59;
+wire cond_60;
+wire cond_61;
+wire cond_62;
+wire cond_63;
+wire cond_64;
+wire cond_65;
+wire cond_66;
+wire cond_67;
+wire cond_68;
+wire cond_69;
+wire cond_70;
+wire cond_71;
+wire cond_72;
+wire cond_73;
+wire cond_74;
+wire cond_75;
+wire cond_76;
+wire cond_77;
+wire cond_78;
+wire cond_79;
+wire cond_80;
+wire cond_81;
+wire cond_82;
+wire cond_83;
+wire cond_84;
+wire cond_85;
+wire cond_86;
+wire cond_87;
+wire cond_88;
+wire cond_89;
+wire cond_90;
+wire cond_91;
+wire cond_92;
+wire cond_93;
+wire cond_94;
+wire cond_95;
+wire cond_96;
+wire cond_97;
+wire cond_98;
+wire cond_99;
+wire cond_100;
+wire cond_101;
+wire cond_102;
+wire cond_103;
+wire cond_104;
+wire cond_105;
+wire cond_106;
+wire cond_107;
+wire cond_108;
+wire cond_109;
+wire cond_110;
+wire cond_111;
+wire cond_112;
+wire cond_113;
+wire cond_114;
+wire cond_115;
+wire cond_116;
+wire cond_117;
+wire cond_118;
+wire cond_119;
+wire cond_120;
+wire cond_121;
+wire cond_122;
+wire cond_123;
+wire cond_124;
+wire cond_125;
+wire cond_126;
+wire cond_127;
+wire cond_128;
+wire cond_129;
+wire cond_130;
+wire cond_131;
+wire cond_132;
+wire cond_133;
+wire cond_134;
+wire cond_135;
+wire cond_136;
+wire cond_137;
+wire cond_138;
+wire cond_139;
+wire cond_140;
+wire cond_141;
+wire cond_142;
+wire cond_143;
+wire cond_144;
+wire cond_145;
+wire cond_146;
+wire cond_147;
+wire cond_148;
+wire cond_149;
+wire cond_150;
+wire cond_151;
+wire cond_152;
+wire cond_153;
+wire cond_154;
+wire cond_155;
+wire cond_156;
+wire cond_157;
+wire cond_158;
+wire cond_159;
+wire cond_160;
+wire cond_161;
+wire cond_162;
+wire cond_163;
+wire cond_164;
+wire cond_165;
+wire cond_166;
+wire cond_167;
+wire cond_168;
+wire cond_169;
+wire cond_170;
+wire cond_171;
+wire cond_172;
+wire cond_173;
+wire cond_174;
+wire cond_175;
+wire cond_176;
+wire cond_177;
+wire cond_178;
+wire cond_179;
+wire cond_180;
+wire cond_181;
+wire cond_182;
+wire cond_183;
+wire cond_184;
+wire cond_185;
+wire cond_186;
+wire cond_187;
+wire cond_188;
+wire cond_189;
+wire cond_190;
+wire cond_191;
+wire cond_192;
+wire cond_193;
+wire cond_194;
+wire cond_195;
+wire cond_196;
+wire cond_197;
+wire cond_198;
+wire cond_199;
+wire cond_200;
+wire cond_201;
+wire cond_202;
+wire cond_203;
+wire cond_204;
+wire cond_205;
+wire cond_206;
+wire cond_207;
+wire cond_208;
+wire cond_209;
+wire cond_210;
+wire cond_211;
+wire [6:0] mc_saved_command_to_reg ;
+wire [3:0] mc_saved_cmdex_to_reg ;
+
 //======================================================== conditions
-wire cond_0 = mc_cmd == `CMD_XADD && mc_cmdex_last == `CMDEX_XADD_FIRST;
-wire cond_1 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_Ev_STEP_0;
-wire cond_2 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_Jv_STEP_0;
-wire cond_3 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_Ep_STEP_0;
-wire cond_4 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_Ap_STEP_0;
-wire cond_5 = mc_cmd == `CMD_CALL && (mc_cmdex_last == `CMDEX_CALL_Ep_STEP_1 || mc_cmdex_last == `CMDEX_CALL_Ap_STEP_1) && (real_mode || v8086_mode);
-wire cond_6 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_real_v8086_STEP_0;
-wire cond_7 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_real_v8086_STEP_1;
-wire cond_8 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_real_v8086_STEP_2;
-wire cond_9 = mc_cmd == `CMD_CALL && (mc_cmdex_last == `CMDEX_CALL_Ep_STEP_1 || mc_cmdex_last == `CMDEX_CALL_Ap_STEP_1) && (protected_mode);
-wire cond_10 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_STEP_0;
-wire cond_11 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG];
-wire cond_12 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_seg_STEP_0;
-wire cond_13 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_seg_STEP_1;
-wire cond_14 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_seg_STEP_2;
-wire cond_15 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_protected_seg_STEP_3;
-wire cond_16 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && (glob_descriptor[`DESC_BITS_TYPE] == `DESC_TSS_AVAIL_386 || glob_descriptor[`DESC_BITS_TYPE] == `DESC_TSS_AVAIL_286);
-wire cond_17 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_task_switch_STEP_0 && glob_param_3[21:18] == 4'd0;
-wire cond_18 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_task_switch_STEP_0 && glob_param_3[21:18] != 4'd0;
-wire cond_19 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && glob_descriptor[`DESC_BITS_TYPE] == `DESC_TASK_GATE;
-wire cond_20 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_task_gate_STEP_0;
-wire cond_21 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_task_gate_STEP_1;
-wire cond_22 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && (glob_descriptor[`DESC_BITS_TYPE] == `DESC_CALL_GATE_386 || glob_descriptor[`DESC_BITS_TYPE] == `DESC_CALL_GATE_286);
-wire cond_23 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_STEP_0;
-wire cond_24 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_STEP_1;
-wire cond_25 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_STEP_2 && `DESC_IS_CODE_NON_CONFORMING(glob_descriptor) && glob_descriptor[`DESC_BITS_DPL] < cpl;
-wire cond_26 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_more_STEP_0;
-wire cond_27 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_more_STEP_1;
-wire cond_28 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_more_STEP_2;
-wire cond_29 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_more_STEP_3 && glob_param_3[24:20] != 5'd0;
-wire cond_30 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_4 && glob_param_3[24:20] == 5'd1;
-wire cond_31 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_4 && glob_param_3[24:20] != 5'd1;
-wire cond_32 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_5 && glob_param_3[24:20] == 5'd1;
-wire cond_33 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_5 && glob_param_3[24:20] != 5'd1;
-wire cond_34 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_more_STEP_3 && glob_param_3[24:20] == 5'd0;
-wire cond_35 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_6;
-wire cond_36 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_7;
-wire cond_37 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_8;
-wire cond_38 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_9;
-wire cond_39 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_STEP_2 && ~(`DESC_IS_CODE_NON_CONFORMING(glob_descriptor) && glob_descriptor[`DESC_BITS_DPL] < cpl);
-wire cond_40 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_same_STEP_0;
-wire cond_41 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_same_STEP_1;
-wire cond_42 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_same_STEP_2;
-wire cond_43 = mc_cmd == `CMD_INVD && mc_cmdex_last == `CMDEX_INVD_STEP_0;
-wire cond_44 = mc_cmd == `CMD_INVD && mc_cmdex_last == `CMDEX_INVD_STEP_1;
-wire cond_45 = mc_cmd == `CMD_INVLPG && mc_cmdex_last == `CMDEX_INVLPG_STEP_0;
-wire cond_46 = mc_cmd == `CMD_INVLPG && mc_cmdex_last == `CMDEX_INVLPG_STEP_1;
-wire cond_47 = mc_cmd == `CMD_io_allow && mc_cmdex_last == `CMDEX_io_allow_1;
-wire cond_48 = mc_cmd == `CMD_io_allow && mc_cmdex_last == `CMDEX_io_allow_2;
-wire cond_49 = mc_cmd == `CMD_RET_near && mc_cmdex_last == `CMDEX_RET_near_imm;
-wire cond_50 = mc_cmd == `CMD_RET_near && mc_cmdex_last == `CMDEX_RET_near;
-wire cond_51 = mc_cmd == `CMD_LxS && mc_cmdex_last == `CMDEX_LxS_STEP_1;
-wire cond_52 = mc_cmd == `CMD_LxS && mc_cmdex_last == `CMDEX_LxS_STEP_2;
-wire cond_53 = mc_cmd == `CMD_LxS && mc_cmdex_last == `CMDEX_LxS_STEP_3;
-wire cond_54 = (mc_cmd == `CMD_MOV_to_seg || mc_cmd == `CMD_LLDT || mc_cmd == `CMD_LTR) && mc_cmdex_last != `CMDEX_MOV_to_seg_LLDT_LTR_STEP_LAST;
-wire cond_55 = (mc_cmd == `CMD_MOV_to_seg || mc_cmd == `CMD_LLDT || mc_cmd == `CMD_LTR) && mc_cmdex_last == `CMDEX_MOV_to_seg_LLDT_LTR_STEP_LAST;
-wire cond_56 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_STEP_0;
-wire cond_57 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_STEP_1 && real_mode;
-wire cond_58 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_real_STEP_0;
-wire cond_59 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_real_STEP_1;
-wire cond_60 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_real_STEP_2;
-wire cond_61 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_real_STEP_3;
-wire cond_62 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_real_STEP_4;
-wire cond_63 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_STEP_1 && ~(real_mode);
-wire cond_64 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_protected_STEP_0;
-wire cond_65 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_protected_STEP_1;
-wire cond_66 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_protected_STEP_2 && glob_descriptor[`DESC_BITS_TYPE] == `DESC_TASK_GATE;
-wire cond_67 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_task_gate_STEP_0;
-wire cond_68 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_task_gate_STEP_1;
-wire cond_69 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_protected_STEP_2 && glob_descriptor[`DESC_BITS_TYPE] != `DESC_TASK_GATE;
-wire cond_70 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_int_trap_gate_STEP_0;
-wire cond_71 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_int_trap_gate_STEP_1;
-wire cond_72 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_int_trap_gate_STEP_2 && `DESC_IS_CODE_NON_CONFORMING(glob_descriptor) && glob_descriptor[`DESC_BITS_DPL] < cpl;
-wire cond_73 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_0;
-wire cond_74 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_1;
-wire cond_75 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_2;
-wire cond_76 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_3 && v8086_mode;
-wire cond_77 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_4;
-wire cond_78 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_5;
-wire cond_79 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_6;
-wire cond_80 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_7;
-wire cond_81 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_3 && ~(v8086_mode);
-wire cond_82 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_8;
-wire cond_83 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_9;
-wire cond_84 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_0;
-wire cond_85 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_1;
-wire cond_86 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_2 && exc_push_error;
-wire cond_87 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_3;
-wire cond_88 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_2 && ~(exc_push_error);
-wire cond_89 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_4;
-wire cond_90 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_5;
-wire cond_91 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_int_trap_gate_STEP_2 && ~(`DESC_IS_CODE_NON_CONFORMING(glob_descriptor) && glob_descriptor[`DESC_BITS_DPL] < cpl);
-wire cond_92 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_0;
-wire cond_93 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_1;
-wire cond_94 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_2 && exc_push_error;
-wire cond_95 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_3;
-wire cond_96 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_2 && ~(exc_push_error);
-wire cond_97 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_4;
-wire cond_98 = mc_cmd == `CMD_load_seg && (~(protected_mode) || (protected_mode && mc_cmdex_last == `CMDEX_load_seg_STEP_2));
-wire cond_99 = mc_cmd == `CMD_load_seg && protected_mode && mc_cmdex_last == `CMDEX_load_seg_STEP_1;
-wire cond_100 = mc_cmd == `CMD_POP_seg && mc_cmdex_last == `CMDEX_POP_seg_STEP_1;
-wire cond_101 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_real_v86_STEP_0;
-wire cond_102 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_real_v86_STEP_1;
-wire cond_103 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_real_v86_STEP_2;
-wire cond_104 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_0 && ntflag;
-wire cond_105 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_task_switch_STEP_0;
-wire cond_106 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_task_switch_STEP_1;
-wire cond_107 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_0 && ~(ntflag);
-wire cond_108 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_1;
-wire cond_109 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_2;
-wire cond_110 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_3 && mc_operand_32bit && glob_param_3[`EFLAGS_BIT_VM] && cpl == 2'd0;
-wire cond_111 = mc_cmd == `CMD_IRET && mc_cmdex_last >= `CMDEX_IRET_protected_to_v86_STEP_0 && mc_cmdex_last < `CMDEX_IRET_protected_to_v86_STEP_5;
-wire cond_112 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_to_v86_STEP_5;
-wire cond_113 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last == `CMDEX_IRET_2_protected_to_v86_STEP_6;
-wire cond_114 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_3 && ~(mc_operand_32bit && glob_param_3[`EFLAGS_BIT_VM] && cpl == 2'd0);
-wire cond_115 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last == `CMDEX_IRET_2_protected_same_STEP_0;
-wire cond_116 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last == `CMDEX_IRET_2_protected_same_STEP_1;
-wire cond_117 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last == `CMDEX_IRET_2_protected_outer_STEP_0;
-wire cond_118 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last >= `CMDEX_IRET_2_protected_outer_STEP_1 && mc_cmdex_last < `CMDEX_IRET_2_protected_outer_STEP_6;
-wire cond_119 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last == `CMDEX_IRET_2_protected_outer_STEP_6;
-wire cond_120 = mc_cmd == `CMD_POP && mc_cmdex_last == `CMDEX_POP_modregrm_STEP_0;
-wire cond_121 = mc_cmd == `CMD_CMPS && mc_cmdex_last == `CMDEX_CMPS_FIRST;
-wire cond_122 = mc_cmd == `CMD_CMPS && mc_cmdex_last == `CMDEX_CMPS_LAST;
-wire cond_123 = mc_cmd == `CMD_control_reg && mc_cmdex_last == `CMDEX_control_reg_LMSW_STEP_0;
-wire cond_124 = mc_cmd == `CMD_control_reg && mc_cmdex_last == `CMDEX_control_reg_MOV_load_STEP_0;
-wire cond_125 = (mc_cmd == `CMD_LGDT || mc_cmd == `CMD_LIDT) && mc_cmdex_last == `CMDEX_LGDT_LIDT_STEP_1;
-wire cond_126 = (mc_cmd == `CMD_LGDT || mc_cmd == `CMD_LIDT) && mc_cmdex_last == `CMDEX_LGDT_LIDT_STEP_2;
-wire cond_127 = (mc_cmd == `CMD_LGDT || mc_cmd == `CMD_LIDT) && mc_cmdex_last == `CMDEX_LGDT_LIDT_STEP_LAST;
-wire cond_128 = mc_cmd == `CMD_PUSHA && mc_step < 6'd7;
-wire cond_129 = mc_cmd == `CMD_PUSHA && mc_step == 6'd7;
-wire cond_130 = mc_cmd == `CMD_ENTER && ((mc_step == 6'd1 && mc_decoder[28:24] == 5'd0) || (mc_step == 6'd2 && mc_decoder[28:24] == 5'd1) || (mc_step > { 1'b0, mc_decoder[28:24] } && mc_decoder[28:24] > 5'd1));
-wire cond_131 = mc_cmd == `CMD_ENTER && ((mc_step == 6'd1 && mc_decoder[28:24] == 5'd1) || (mc_step == { 1'b0, mc_decoder[28:24] } && mc_decoder[28:24] > 5'd1));
-wire cond_132 = mc_cmd == `CMD_ENTER && (mc_step < { 1'b0, mc_decoder[28:24] } && mc_decoder[28:24] > 5'd1);
-wire cond_133 = mc_cmd == `CMD_WBINVD && mc_cmdex_last == `CMDEX_WBINVD_STEP_0;
-wire cond_134 = mc_cmd == `CMD_WBINVD && mc_cmdex_last == `CMDEX_WBINVD_STEP_1;
-wire cond_135 = mc_cmd == `CMD_CLTS && mc_cmdex_last == `CMDEX_CLTS_STEP_FIRST;
-wire cond_136 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_STEP_1;
-wire cond_137 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_STEP_2;
-wire cond_138 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_real_STEP_3;
-wire cond_139 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_same_STEP_3;
-wire cond_140 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_outer_STEP_3;
-wire cond_141 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_outer_STEP_4;
-wire cond_142 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_outer_STEP_5;
-wire cond_143 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_outer_STEP_6;
-wire cond_144 = mc_cmd == `CMD_XCHG && mc_cmdex_last == `CMDEX_XCHG_modregrm;
-wire cond_145 = mc_cmd == `CMD_INT_INTO && (mc_cmdex_last == `CMDEX_INT_INTO_INT_STEP_0 || mc_cmdex_last == `CMDEX_INT_INTO_INT3_STEP_0 || mc_cmdex_last == `CMDEX_INT_INTO_INT1_STEP_0);
-wire cond_146 = mc_cmd == `CMD_INT_INTO && mc_cmdex_last == `CMDEX_INT_INTO_INTO_STEP_0 && oflag;
-wire cond_147 = mc_cmd == `CMD_INT_INTO && mc_cmdex_last == `CMDEX_INT_INTO_INTO_STEP_0 && ~(oflag);
-wire cond_148 = mc_cmd == `CMD_IN && (mc_cmdex_last == `CMDEX_IN_imm || mc_cmdex_last == `CMDEX_IN_dx) && ~(io_allow_check_needed);
-wire cond_149 = mc_cmd == `CMD_IN && (mc_cmdex_last == `CMDEX_IN_imm || mc_cmdex_last == `CMDEX_IN_dx) && io_allow_check_needed;
-wire cond_150 = mc_cmd == `CMD_IN && mc_cmdex_last == `CMDEX_IN_protected;
-wire cond_151 = (mc_cmd == `CMD_LAR || mc_cmd == `CMD_LSL || mc_cmd == `CMD_VERR || mc_cmd == `CMD_VERW) && mc_cmdex_last == `CMDEX_LAR_LSL_VERR_VERW_STEP_1;
-wire cond_152 = (mc_cmd == `CMD_LAR || mc_cmd == `CMD_LSL || mc_cmd == `CMD_VERR || mc_cmd == `CMD_VERW) && mc_cmdex_last == `CMDEX_LAR_LSL_VERR_VERW_STEP_2;
-wire cond_153 = mc_cmd == `CMD_INS && mc_cmdex_last == `CMDEX_INS_real_1 && ~(io_allow_check_needed);
-wire cond_154 = mc_cmd == `CMD_INS && mc_cmdex_last == `CMDEX_INS_real_2;
-wire cond_155 = mc_cmd == `CMD_INS && mc_cmdex_last == `CMDEX_INS_real_1 && io_allow_check_needed;
-wire cond_156 = mc_cmd == `CMD_INS && mc_cmdex_last == `CMDEX_INS_protected_1;
-wire cond_157 = mc_cmd == `CMD_INS && mc_cmdex_last == `CMDEX_INS_protected_2;
-wire cond_158 = mc_cmd == `CMD_OUTS && mc_cmdex_last == `CMDEX_OUTS_first && ~(io_allow_check_needed);
-wire cond_159 = mc_cmd == `CMD_OUTS && mc_cmdex_last == `CMDEX_OUTS_first && io_allow_check_needed;
-wire cond_160 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_Jv_STEP_0;
-wire cond_161 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_Ev_STEP_0;
-wire cond_162 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_Ep_STEP_0;
-wire cond_163 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_Ap_STEP_0;
-wire cond_164 = mc_cmd == `CMD_JMP && (mc_cmdex_last == `CMDEX_JMP_Ep_STEP_1 || mc_cmdex_last == `CMDEX_JMP_Ap_STEP_1) && (real_mode || v8086_mode);
-wire cond_165 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_real_v8086_STEP_0;
-wire cond_166 = mc_cmd == `CMD_JMP && (mc_cmdex_last == `CMDEX_JMP_Ep_STEP_1 || mc_cmdex_last == `CMDEX_JMP_Ap_STEP_1) && (protected_mode);
-wire cond_167 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_STEP_0;
-wire cond_168 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG];
-wire cond_169 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_seg_STEP_0;
-wire cond_170 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && (glob_descriptor[`DESC_BITS_TYPE] == `DESC_TSS_AVAIL_386 || glob_descriptor[`DESC_BITS_TYPE] == `DESC_TSS_AVAIL_286);
-wire cond_171 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_task_switch_STEP_0 && glob_param_3[21:18] == 4'd0;
-wire cond_172 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_task_switch_STEP_0 && glob_param_3[21:18] != 4'd0;
-wire cond_173 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && glob_descriptor[`DESC_BITS_TYPE] == `DESC_TASK_GATE;
-wire cond_174 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_task_gate_STEP_0;
-wire cond_175 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_task_gate_STEP_1;
-wire cond_176 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && (glob_descriptor[`DESC_BITS_TYPE] == `DESC_CALL_GATE_386 || glob_descriptor[`DESC_BITS_TYPE] == `DESC_CALL_GATE_286);
-wire cond_177 = mc_cmd == `CMD_JMP_2 && mc_cmdex_last == `CMDEX_JMP_2_call_gate_STEP_0;
-wire cond_178 = mc_cmd == `CMD_JMP_2 && mc_cmdex_last == `CMDEX_JMP_2_call_gate_STEP_1;
-wire cond_179 = mc_cmd == `CMD_JMP_2 && mc_cmdex_last == `CMDEX_JMP_2_call_gate_STEP_2;
-wire cond_180 = mc_cmd == `CMD_OUT && (mc_cmdex_last == `CMDEX_OUT_imm || mc_cmdex_last == `CMDEX_OUT_dx) && ~(io_allow_check_needed);
-wire cond_181 = mc_cmd == `CMD_OUT && (mc_cmdex_last == `CMDEX_OUT_imm || mc_cmdex_last == `CMDEX_OUT_dx) && io_allow_check_needed;
-wire cond_182 = mc_cmd == `CMD_OUT && mc_cmdex_last == `CMDEX_OUT_protected;
-wire cond_183 = mc_cmd == `CMD_POPF && mc_cmdex_last == `CMDEX_POPF_STEP_0;
-wire cond_184 = mc_cmd == `CMD_BOUND && mc_cmdex_last == `CMDEX_BOUND_STEP_FIRST;
-wire cond_185 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_1 && cr0_pg;
-wire cond_186 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_2;
-wire cond_187 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_3 && (glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_CALL || glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_INT);
-wire cond_188 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_4;
-wire cond_189 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_5;
-wire cond_190 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_3 && ~(glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_CALL || glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_INT);
-wire cond_191 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_1 && ~(cr0_pg);
-wire cond_192 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_6 && cr0_pg;
-wire cond_193 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_7;
-wire cond_194 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_8;
-wire cond_195 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_6 && ~(cr0_pg);
-wire cond_196 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_9;
-wire cond_197 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_10;
-wire cond_198 = mc_cmd == `CMD_task_switch_2 && mc_cmdex_last < `CMDEX_task_switch_2_STEP_13;
-wire cond_199 = mc_cmd == `CMD_task_switch_2 && mc_cmdex_last == `CMDEX_task_switch_2_STEP_13;
-wire cond_200 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_11;
-wire cond_201 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_12;
-wire cond_202 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_13;
-wire cond_203 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_14;
-wire cond_204 = mc_cmd == `CMD_task_switch_3;
-wire cond_205 = mc_cmd == `CMD_task_switch_3 && mc_cmdex_last == `CMDEX_task_switch_3_STEP_15;
-wire cond_206 = mc_cmd == `CMD_task_switch_4 && mc_cmdex_last < `CMDEX_task_switch_4_STEP_10;
-wire cond_207 = mc_cmd == `CMD_SGDT || mc_cmd == `CMD_SIDT;
-wire cond_208 = mc_cmd == `CMD_POPA && mc_step < 6'd7;
-wire cond_209 = mc_cmd == `CMD_POPA && mc_step == 6'd7;
-wire cond_210 = mc_cmd == `CMD_debug_reg && mc_cmdex_last == `CMDEX_debug_reg_MOV_load_STEP_0;
-wire cond_211 = 
+ assign cond_0 = mc_cmd == `CMD_XADD && mc_cmdex_last == `CMDEX_XADD_FIRST;
+ assign cond_1 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_Ev_STEP_0;
+ assign cond_2 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_Jv_STEP_0;
+ assign cond_3 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_Ep_STEP_0;
+ assign cond_4 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_Ap_STEP_0;
+ assign cond_5 = mc_cmd == `CMD_CALL && (mc_cmdex_last == `CMDEX_CALL_Ep_STEP_1 || mc_cmdex_last == `CMDEX_CALL_Ap_STEP_1) && (real_mode || v8086_mode);
+ assign cond_6 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_real_v8086_STEP_0;
+ assign cond_7 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_real_v8086_STEP_1;
+ assign cond_8 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_real_v8086_STEP_2;
+ assign cond_9 = mc_cmd == `CMD_CALL && (mc_cmdex_last == `CMDEX_CALL_Ep_STEP_1 || mc_cmdex_last == `CMDEX_CALL_Ap_STEP_1) && (protected_mode);
+ assign cond_10 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_STEP_0;
+ assign cond_11 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG];
+ assign cond_12 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_seg_STEP_0;
+ assign cond_13 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_seg_STEP_1;
+ assign cond_14 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_seg_STEP_2;
+ assign cond_15 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_protected_seg_STEP_3;
+ assign cond_16 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && (glob_descriptor[`DESC_BITS_TYPE] == `DESC_TSS_AVAIL_386 || glob_descriptor[`DESC_BITS_TYPE] == `DESC_TSS_AVAIL_286);
+ assign cond_17 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_task_switch_STEP_0 && glob_param_3[21:18] == 4'd0;
+ assign cond_18 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_task_switch_STEP_0 && glob_param_3[21:18] != 4'd0;
+ assign cond_19 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && glob_descriptor[`DESC_BITS_TYPE] == `DESC_TASK_GATE;
+ assign cond_20 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_task_gate_STEP_0;
+ assign cond_21 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_task_gate_STEP_1;
+ assign cond_22 = mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && (glob_descriptor[`DESC_BITS_TYPE] == `DESC_CALL_GATE_386 || glob_descriptor[`DESC_BITS_TYPE] == `DESC_CALL_GATE_286);
+ assign cond_23 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_STEP_0;
+ assign cond_24 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_STEP_1;
+ assign cond_25 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_STEP_2 && `DESC_IS_CODE_NON_CONFORMING(glob_descriptor) && glob_descriptor[`DESC_BITS_DPL] < cpl;
+ assign cond_26 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_more_STEP_0;
+ assign cond_27 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_more_STEP_1;
+ assign cond_28 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_more_STEP_2;
+ assign cond_29 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_more_STEP_3 && glob_param_3[24:20] != 5'd0;
+ assign cond_30 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_4 && glob_param_3[24:20] == 5'd1;
+ assign cond_31 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_4 && glob_param_3[24:20] != 5'd1;
+ assign cond_32 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_5 && glob_param_3[24:20] == 5'd1;
+ assign cond_33 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_5 && glob_param_3[24:20] != 5'd1;
+ assign cond_34 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_more_STEP_3 && glob_param_3[24:20] == 5'd0;
+ assign cond_35 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_6;
+ assign cond_36 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_7;
+ assign cond_37 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_8;
+ assign cond_38 = mc_cmd == `CMD_CALL_3 && mc_cmdex_last == `CMDEX_CALL_3_call_gate_more_STEP_9;
+ assign cond_39 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_STEP_2 && ~(`DESC_IS_CODE_NON_CONFORMING(glob_descriptor) && glob_descriptor[`DESC_BITS_DPL] < cpl);
+ assign cond_40 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_same_STEP_0;
+ assign cond_41 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_same_STEP_1;
+ assign cond_42 = mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_call_gate_same_STEP_2;
+ assign cond_43 = mc_cmd == `CMD_INVD && mc_cmdex_last == `CMDEX_INVD_STEP_0;
+ assign cond_44 = mc_cmd == `CMD_INVD && mc_cmdex_last == `CMDEX_INVD_STEP_1;
+ assign cond_45 = mc_cmd == `CMD_INVLPG && mc_cmdex_last == `CMDEX_INVLPG_STEP_0;
+ assign cond_46 = mc_cmd == `CMD_INVLPG && mc_cmdex_last == `CMDEX_INVLPG_STEP_1;
+ assign cond_47 = mc_cmd == `CMD_io_allow && mc_cmdex_last == `CMDEX_io_allow_1;
+ assign cond_48 = mc_cmd == `CMD_io_allow && mc_cmdex_last == `CMDEX_io_allow_2;
+ assign cond_49 = mc_cmd == `CMD_RET_near && mc_cmdex_last == `CMDEX_RET_near_imm;
+ assign cond_50 = mc_cmd == `CMD_RET_near && mc_cmdex_last == `CMDEX_RET_near;
+ assign cond_51 = mc_cmd == `CMD_LxS && mc_cmdex_last == `CMDEX_LxS_STEP_1;
+ assign cond_52 = mc_cmd == `CMD_LxS && mc_cmdex_last == `CMDEX_LxS_STEP_2;
+ assign cond_53 = mc_cmd == `CMD_LxS && mc_cmdex_last == `CMDEX_LxS_STEP_3;
+ assign cond_54 = (mc_cmd == `CMD_MOV_to_seg || mc_cmd == `CMD_LLDT || mc_cmd == `CMD_LTR) && mc_cmdex_last != `CMDEX_MOV_to_seg_LLDT_LTR_STEP_LAST;
+ assign cond_55 = (mc_cmd == `CMD_MOV_to_seg || mc_cmd == `CMD_LLDT || mc_cmd == `CMD_LTR) && mc_cmdex_last == `CMDEX_MOV_to_seg_LLDT_LTR_STEP_LAST;
+ assign cond_56 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_STEP_0;
+ assign cond_57 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_STEP_1 && real_mode;
+ assign cond_58 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_real_STEP_0;
+ assign cond_59 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_real_STEP_1;
+ assign cond_60 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_real_STEP_2;
+ assign cond_61 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_real_STEP_3;
+ assign cond_62 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_real_STEP_4;
+ assign cond_63 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_STEP_1 && ~(real_mode);
+ assign cond_64 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_protected_STEP_0;
+ assign cond_65 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_protected_STEP_1;
+ assign cond_66 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_protected_STEP_2 && glob_descriptor[`DESC_BITS_TYPE] == `DESC_TASK_GATE;
+ assign cond_67 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_task_gate_STEP_0;
+ assign cond_68 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_task_gate_STEP_1;
+ assign cond_69 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_protected_STEP_2 && glob_descriptor[`DESC_BITS_TYPE] != `DESC_TASK_GATE;
+ assign cond_70 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_int_trap_gate_STEP_0;
+ assign cond_71 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_int_trap_gate_STEP_1;
+ assign cond_72 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_int_trap_gate_STEP_2 && `DESC_IS_CODE_NON_CONFORMING(glob_descriptor) && glob_descriptor[`DESC_BITS_DPL] < cpl;
+ assign cond_73 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_0;
+ assign cond_74 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_1;
+ assign cond_75 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_2;
+ assign cond_76 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_3 && v8086_mode;
+ assign cond_77 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_4;
+ assign cond_78 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_5;
+ assign cond_79 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_6;
+ assign cond_80 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_7;
+ assign cond_81 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_3 && ~(v8086_mode);
+ assign cond_82 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_8;
+ assign cond_83 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_more_STEP_9;
+ assign cond_84 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_0;
+ assign cond_85 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_1;
+ assign cond_86 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_2 && exc_push_error;
+ assign cond_87 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_3;
+ assign cond_88 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_2 && ~(exc_push_error);
+ assign cond_89 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_4;
+ assign cond_90 = mc_cmd == `CMD_int_3 && mc_cmdex_last == `CMDEX_int_3_int_trap_gate_more_STEP_5;
+ assign cond_91 = mc_cmd == `CMD_int && mc_cmdex_last == `CMDEX_int_int_trap_gate_STEP_2 && ~(`DESC_IS_CODE_NON_CONFORMING(glob_descriptor) && glob_descriptor[`DESC_BITS_DPL] < cpl);
+ assign cond_92 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_0;
+ assign cond_93 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_1;
+ assign cond_94 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_2 && exc_push_error;
+ assign cond_95 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_3;
+ assign cond_96 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_2 && ~(exc_push_error);
+ assign cond_97 = mc_cmd == `CMD_int_2 && mc_cmdex_last == `CMDEX_int_2_int_trap_gate_same_STEP_4;
+ assign cond_98 = mc_cmd == `CMD_load_seg && (~(protected_mode) || (protected_mode && mc_cmdex_last == `CMDEX_load_seg_STEP_2));
+ assign cond_99 = mc_cmd == `CMD_load_seg && protected_mode && mc_cmdex_last == `CMDEX_load_seg_STEP_1;
+ assign cond_100 = mc_cmd == `CMD_POP_seg && mc_cmdex_last == `CMDEX_POP_seg_STEP_1;
+ assign cond_101 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_real_v86_STEP_0;
+ assign cond_102 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_real_v86_STEP_1;
+ assign cond_103 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_real_v86_STEP_2;
+ assign cond_104 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_0 && ntflag;
+ assign cond_105 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_task_switch_STEP_0;
+ assign cond_106 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_task_switch_STEP_1;
+ assign cond_107 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_0 && ~(ntflag);
+ assign cond_108 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_1;
+ assign cond_109 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_2;
+ assign cond_110 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_3 && mc_operand_32bit && glob_param_3[`EFLAGS_BIT_VM] && cpl == 2'd0;
+ assign cond_111 = mc_cmd == `CMD_IRET && mc_cmdex_last >= `CMDEX_IRET_protected_to_v86_STEP_0 && mc_cmdex_last < `CMDEX_IRET_protected_to_v86_STEP_5;
+ assign cond_112 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_to_v86_STEP_5;
+ assign cond_113 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last == `CMDEX_IRET_2_protected_to_v86_STEP_6;
+ assign cond_114 = mc_cmd == `CMD_IRET && mc_cmdex_last == `CMDEX_IRET_protected_STEP_3 && ~(mc_operand_32bit && glob_param_3[`EFLAGS_BIT_VM] && cpl == 2'd0);
+ assign cond_115 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last == `CMDEX_IRET_2_protected_same_STEP_0;
+ assign cond_116 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last == `CMDEX_IRET_2_protected_same_STEP_1;
+ assign cond_117 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last == `CMDEX_IRET_2_protected_outer_STEP_0;
+ assign cond_118 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last >= `CMDEX_IRET_2_protected_outer_STEP_1 && mc_cmdex_last < `CMDEX_IRET_2_protected_outer_STEP_6;
+ assign cond_119 = mc_cmd == `CMD_IRET_2 && mc_cmdex_last == `CMDEX_IRET_2_protected_outer_STEP_6;
+ assign cond_120 = mc_cmd == `CMD_POP && mc_cmdex_last == `CMDEX_POP_modregrm_STEP_0;
+ assign cond_121 = mc_cmd == `CMD_CMPS && mc_cmdex_last == `CMDEX_CMPS_FIRST;
+ assign cond_122 = mc_cmd == `CMD_CMPS && mc_cmdex_last == `CMDEX_CMPS_LAST;
+ assign cond_123 = mc_cmd == `CMD_control_reg && mc_cmdex_last == `CMDEX_control_reg_LMSW_STEP_0;
+ assign cond_124 = mc_cmd == `CMD_control_reg && mc_cmdex_last == `CMDEX_control_reg_MOV_load_STEP_0;
+ assign cond_125 = (mc_cmd == `CMD_LGDT || mc_cmd == `CMD_LIDT) && mc_cmdex_last == `CMDEX_LGDT_LIDT_STEP_1;
+ assign cond_126 = (mc_cmd == `CMD_LGDT || mc_cmd == `CMD_LIDT) && mc_cmdex_last == `CMDEX_LGDT_LIDT_STEP_2;
+ assign cond_127 = (mc_cmd == `CMD_LGDT || mc_cmd == `CMD_LIDT) && mc_cmdex_last == `CMDEX_LGDT_LIDT_STEP_LAST;
+ assign cond_128 = mc_cmd == `CMD_PUSHA && mc_step < 6'd7;
+ assign cond_129 = mc_cmd == `CMD_PUSHA && mc_step == 6'd7;
+ assign cond_130 = mc_cmd == `CMD_ENTER && ((mc_step == 6'd1 && mc_decoder[28:24] == 5'd0) || (mc_step == 6'd2 && mc_decoder[28:24] == 5'd1) || (mc_step > { 1'b0, mc_decoder[28:24] } && mc_decoder[28:24] > 5'd1));
+ assign cond_131 = mc_cmd == `CMD_ENTER && ((mc_step == 6'd1 && mc_decoder[28:24] == 5'd1) || (mc_step == { 1'b0, mc_decoder[28:24] } && mc_decoder[28:24] > 5'd1));
+ assign cond_132 = mc_cmd == `CMD_ENTER && (mc_step < { 1'b0, mc_decoder[28:24] } && mc_decoder[28:24] > 5'd1);
+ assign cond_133 = mc_cmd == `CMD_WBINVD && mc_cmdex_last == `CMDEX_WBINVD_STEP_0;
+ assign cond_134 = mc_cmd == `CMD_WBINVD && mc_cmdex_last == `CMDEX_WBINVD_STEP_1;
+ assign cond_135 = mc_cmd == `CMD_CLTS && mc_cmdex_last == `CMDEX_CLTS_STEP_FIRST;
+ assign cond_136 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_STEP_1;
+ assign cond_137 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_STEP_2;
+ assign cond_138 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_real_STEP_3;
+ assign cond_139 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_same_STEP_3;
+ assign cond_140 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_outer_STEP_3;
+ assign cond_141 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_outer_STEP_4;
+ assign cond_142 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_outer_STEP_5;
+ assign cond_143 = mc_cmd == `CMD_RET_far && mc_cmdex_last == `CMDEX_RET_far_outer_STEP_6;
+ assign cond_144 = mc_cmd == `CMD_XCHG && mc_cmdex_last == `CMDEX_XCHG_modregrm;
+ assign cond_145 = mc_cmd == `CMD_INT_INTO && (mc_cmdex_last == `CMDEX_INT_INTO_INT_STEP_0 || mc_cmdex_last == `CMDEX_INT_INTO_INT3_STEP_0 || mc_cmdex_last == `CMDEX_INT_INTO_INT1_STEP_0);
+ assign cond_146 = mc_cmd == `CMD_INT_INTO && mc_cmdex_last == `CMDEX_INT_INTO_INTO_STEP_0 && oflag;
+ assign cond_147 = mc_cmd == `CMD_INT_INTO && mc_cmdex_last == `CMDEX_INT_INTO_INTO_STEP_0 && ~(oflag);
+ assign cond_148 = mc_cmd == `CMD_IN && (mc_cmdex_last == `CMDEX_IN_imm || mc_cmdex_last == `CMDEX_IN_dx) && ~(io_allow_check_needed);
+ assign cond_149 = mc_cmd == `CMD_IN && (mc_cmdex_last == `CMDEX_IN_imm || mc_cmdex_last == `CMDEX_IN_dx) && io_allow_check_needed;
+ assign cond_150 = mc_cmd == `CMD_IN && mc_cmdex_last == `CMDEX_IN_protected;
+ assign cond_151 = (mc_cmd == `CMD_LAR || mc_cmd == `CMD_LSL || mc_cmd == `CMD_VERR || mc_cmd == `CMD_VERW) && mc_cmdex_last == `CMDEX_LAR_LSL_VERR_VERW_STEP_1;
+ assign cond_152 = (mc_cmd == `CMD_LAR || mc_cmd == `CMD_LSL || mc_cmd == `CMD_VERR || mc_cmd == `CMD_VERW) && mc_cmdex_last == `CMDEX_LAR_LSL_VERR_VERW_STEP_2;
+ assign cond_153 = mc_cmd == `CMD_INS && mc_cmdex_last == `CMDEX_INS_real_1 && ~(io_allow_check_needed);
+ assign cond_154 = mc_cmd == `CMD_INS && mc_cmdex_last == `CMDEX_INS_real_2;
+ assign cond_155 = mc_cmd == `CMD_INS && mc_cmdex_last == `CMDEX_INS_real_1 && io_allow_check_needed;
+ assign cond_156 = mc_cmd == `CMD_INS && mc_cmdex_last == `CMDEX_INS_protected_1;
+ assign cond_157 = mc_cmd == `CMD_INS && mc_cmdex_last == `CMDEX_INS_protected_2;
+ assign cond_158 = mc_cmd == `CMD_OUTS && mc_cmdex_last == `CMDEX_OUTS_first && ~(io_allow_check_needed);
+ assign cond_159 = mc_cmd == `CMD_OUTS && mc_cmdex_last == `CMDEX_OUTS_first && io_allow_check_needed;
+ assign cond_160 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_Jv_STEP_0;
+ assign cond_161 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_Ev_STEP_0;
+ assign cond_162 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_Ep_STEP_0;
+ assign cond_163 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_Ap_STEP_0;
+ assign cond_164 = mc_cmd == `CMD_JMP && (mc_cmdex_last == `CMDEX_JMP_Ep_STEP_1 || mc_cmdex_last == `CMDEX_JMP_Ap_STEP_1) && (real_mode || v8086_mode);
+ assign cond_165 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_real_v8086_STEP_0;
+ assign cond_166 = mc_cmd == `CMD_JMP && (mc_cmdex_last == `CMDEX_JMP_Ep_STEP_1 || mc_cmdex_last == `CMDEX_JMP_Ap_STEP_1) && (protected_mode);
+ assign cond_167 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_STEP_0;
+ assign cond_168 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG];
+ assign cond_169 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_seg_STEP_0;
+ assign cond_170 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && (glob_descriptor[`DESC_BITS_TYPE] == `DESC_TSS_AVAIL_386 || glob_descriptor[`DESC_BITS_TYPE] == `DESC_TSS_AVAIL_286);
+ assign cond_171 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_task_switch_STEP_0 && glob_param_3[21:18] == 4'd0;
+ assign cond_172 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_task_switch_STEP_0 && glob_param_3[21:18] != 4'd0;
+ assign cond_173 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && glob_descriptor[`DESC_BITS_TYPE] == `DESC_TASK_GATE;
+ assign cond_174 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_task_gate_STEP_0;
+ assign cond_175 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_task_gate_STEP_1;
+ assign cond_176 = mc_cmd == `CMD_JMP && mc_cmdex_last == `CMDEX_JMP_protected_STEP_1 && glob_descriptor[`DESC_BIT_SEG] == `FALSE && (glob_descriptor[`DESC_BITS_TYPE] == `DESC_CALL_GATE_386 || glob_descriptor[`DESC_BITS_TYPE] == `DESC_CALL_GATE_286);
+ assign cond_177 = mc_cmd == `CMD_JMP_2 && mc_cmdex_last == `CMDEX_JMP_2_call_gate_STEP_0;
+ assign cond_178 = mc_cmd == `CMD_JMP_2 && mc_cmdex_last == `CMDEX_JMP_2_call_gate_STEP_1;
+ assign cond_179 = mc_cmd == `CMD_JMP_2 && mc_cmdex_last == `CMDEX_JMP_2_call_gate_STEP_2;
+ assign cond_180 = mc_cmd == `CMD_OUT && (mc_cmdex_last == `CMDEX_OUT_imm || mc_cmdex_last == `CMDEX_OUT_dx) && ~(io_allow_check_needed);
+ assign cond_181 = mc_cmd == `CMD_OUT && (mc_cmdex_last == `CMDEX_OUT_imm || mc_cmdex_last == `CMDEX_OUT_dx) && io_allow_check_needed;
+ assign cond_182 = mc_cmd == `CMD_OUT && mc_cmdex_last == `CMDEX_OUT_protected;
+ assign cond_183 = mc_cmd == `CMD_POPF && mc_cmdex_last == `CMDEX_POPF_STEP_0;
+ assign cond_184 = mc_cmd == `CMD_BOUND && mc_cmdex_last == `CMDEX_BOUND_STEP_FIRST;
+ assign cond_185 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_1 && cr0_pg;
+ assign cond_186 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_2;
+ assign cond_187 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_3 && (glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_CALL || glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_INT);
+ assign cond_188 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_4;
+ assign cond_189 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_5;
+ assign cond_190 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_3 && ~(glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_CALL || glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_INT);
+ assign cond_191 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_1 && ~(cr0_pg);
+ assign cond_192 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_6 && cr0_pg;
+ assign cond_193 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_7;
+ assign cond_194 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_8;
+ assign cond_195 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_6 && ~(cr0_pg);
+ assign cond_196 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_9;
+ assign cond_197 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_10;
+ assign cond_198 = mc_cmd == `CMD_task_switch_2 && mc_cmdex_last < `CMDEX_task_switch_2_STEP_13;
+ assign cond_199 = mc_cmd == `CMD_task_switch_2 && mc_cmdex_last == `CMDEX_task_switch_2_STEP_13;
+ assign cond_200 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_11;
+ assign cond_201 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_12;
+ assign cond_202 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_13;
+ assign cond_203 = mc_cmd == `CMD_task_switch && mc_cmdex_last == `CMDEX_task_switch_STEP_14;
+ assign cond_204 = mc_cmd == `CMD_task_switch_3;
+ assign cond_205 = mc_cmd == `CMD_task_switch_3 && mc_cmdex_last == `CMDEX_task_switch_3_STEP_15;
+ assign cond_206 = mc_cmd == `CMD_task_switch_4 && mc_cmdex_last < `CMDEX_task_switch_4_STEP_10;
+ assign cond_207 = mc_cmd == `CMD_SGDT || mc_cmd == `CMD_SIDT;
+ assign cond_208 = mc_cmd == `CMD_POPA && mc_step < 6'd7;
+ assign cond_209 = mc_cmd == `CMD_POPA && mc_step == 6'd7;
+ assign cond_210 = mc_cmd == `CMD_debug_reg && mc_cmdex_last == `CMDEX_debug_reg_MOV_load_STEP_0;
+ assign cond_211 = 
 (mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_Ev_Jv_STEP_1) ||
 (mc_cmd == `CMD_CALL && mc_cmdex_last == `CMDEX_CALL_real_v8086_STEP_3) ||
 (mc_cmd == `CMD_CALL_2 && mc_cmdex_last == `CMDEX_CALL_2_protected_seg_STEP_4) ||
@@ -249,7 +464,7 @@ wire cond_211 =
 (mc_cmd == `CMD_debug_reg && mc_cmdex_last == `CMDEX_debug_reg_MOV_load_STEP_1)
 ;
 //======================================================== saves
-wire [6:0] mc_saved_command_to_reg =
+ assign mc_saved_command_to_reg =
     (cond_8)? ( `CMD_CALL) :
     (cond_53)? ( `CMD_LxS) :
     (cond_54)? ( `CMD_MOV_to_seg) :
@@ -266,7 +481,7 @@ wire [6:0] mc_saved_command_to_reg =
     (cond_165)? ( `CMD_JMP) :
     (cond_181)? ( `CMD_OUT) :
     mc_saved_command;
-wire [3:0] mc_saved_cmdex_to_reg =
+ assign mc_saved_cmdex_to_reg =
     (cond_8)? (   `CMDEX_CALL_real_v8086_STEP_3) :
     (cond_53)? (   `CMDEX_LxS_STEP_LAST) :
     (cond_54)? (   `CMDEX_MOV_to_seg_LLDT_LTR_STEP_LAST) :
@@ -284,12 +499,12 @@ wire [3:0] mc_saved_cmdex_to_reg =
     (cond_181)? (   `CMDEX_OUT_protected) :
     mc_saved_cmdex;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) mc_saved_command <= 7'd0;
+always @(posedge clk) begin
+    if(rst) mc_saved_command <= 7'd0;
     else              mc_saved_command <= mc_saved_command_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) mc_saved_cmdex <= 4'd0;
+always @(posedge clk) begin
+    if(rst) mc_saved_cmdex <= 4'd0;
     else              mc_saved_cmdex <= mc_saved_cmdex_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/prefetch_control.v b/rtl/ao486/autogen/prefetch_control.v
index 2b4d7de..4201358 100644
--- a/rtl/ao486/autogen/prefetch_control.v
+++ b/rtl/ao486/autogen/prefetch_control.v
@@ -1,41 +1,52 @@
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire [31:0] physical_to_reg ;
+wire [31:0] linear_to_reg ;
+wire [1:0] state_to_reg ;
+wire cache_disable_to_reg;
+
 //======================================================== conditions
-wire cond_0 = state == STATE_TLB_REQUEST;
-wire cond_1 = ~(pr_reset) && prefetch_length > 5'd0 && prefetchfifo_used < 5'd3;
-wire cond_2 = tlbcode_do;
-wire cond_3 = state == STATE_ICACHE;
-wire cond_4 = page_cross || pr_reset || prefetchfifo_used >= 5'd8;
-wire cond_5 = offset_update;
+ assign cond_0 = state == STATE_TLB_REQUEST;
+ assign cond_1 = ~(pr_reset) && prefetch_length > 5'd0 && prefetchfifo_used < 5'd3;
+ assign cond_2 = tlbcode_do;
+ assign cond_3 = state == STATE_ICACHE;
+ assign cond_4 = page_cross || pr_reset || prefetchfifo_used >= 5'd8;
+ assign cond_5 = offset_update;
 //======================================================== saves
-wire [31:0] physical_to_reg =
+ assign physical_to_reg =
     (cond_0 && cond_1 && cond_2)? (      tlbcode_physical) :
     (cond_3 && cond_5)? ( { physical[31:12], prefetch_address[11:0] }) :
     physical;
-wire [31:0] linear_to_reg =
+ assign linear_to_reg =
     (cond_0 && cond_1 && cond_2)? (        tlbcode_linear) :
     (cond_3 && cond_5)? (   { linear[31:12],   prefetch_address[11:0] }) :
     linear;
-wire [1:0] state_to_reg =
+ assign state_to_reg =
     (cond_0 && cond_1 && cond_2)? ( STATE_ICACHE) :
     (cond_3 && cond_4)? ( STATE_TLB_REQUEST) :
     state;
-wire  cache_disable_to_reg =
+ assign cache_disable_to_reg =
     (cond_0 && cond_1 && cond_2)? ( tlbcode_cache_disable) :
     cache_disable;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) physical <= 32'd0;
+always @(posedge clk) begin
+    if(rst) physical <= 32'd0;
     else              physical <= physical_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) linear <= 32'd0;
+always @(posedge clk) begin
+    if(rst) linear <= 32'd0;
     else              linear <= linear_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) state <= 2'd0;
+always @(posedge clk) begin
+    if(rst) state <= 2'd0;
     else              state <= state_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) cache_disable <= 1'd0;
+always @(posedge clk) begin
+    if(rst) cache_disable <= 1'd0;
     else              cache_disable <= cache_disable_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/read_commands.v b/rtl/ao486/autogen/read_commands.v
index 098b1dc..3ae4114 100644
--- a/rtl/ao486/autogen/read_commands.v
+++ b/rtl/ao486/autogen/read_commands.v
@@ -1,299 +1,559 @@
+reg [31:0] rd_task_switch_linear_reg;
 wire [4:0] rd_call_gate_param;
-assign rd_call_gate_param = glob_param_3[24:20] - 5'd1;
-
 wire rd_io_allow_1_fault;
 wire rd_io_allow_2_fault;
+wire rd_imul_modregrm_mutex_busy;
+wire rd_arith_modregrm_to_rm;
+wire rd_arith_modregrm_to_reg;
+wire rd_in_condition;
+wire [31:0] rd_offset_for_esp_from_tss;
+wire [31:0] rd_offset_for_ss_from_tss;
+wire [31:0] r_limit_for_ss_esp_from_tss;
+wire        rd_ss_esp_from_tss_386;
+wire [31:0] rd_task_switch_linear_next;
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire cond_12;
+wire cond_13;
+wire cond_14;
+wire cond_15;
+wire cond_16;
+wire cond_17;
+wire cond_18;
+wire cond_19;
+wire cond_20;
+wire cond_21;
+wire cond_22;
+wire cond_23;
+wire cond_24;
+wire cond_25;
+wire cond_26;
+wire cond_27;
+wire cond_28;
+wire cond_29;
+wire cond_30;
+wire cond_31;
+wire cond_32;
+wire cond_33;
+wire cond_34;
+wire cond_35;
+wire cond_36;
+wire cond_37;
+wire cond_38;
+wire cond_39;
+wire cond_40;
+wire cond_41;
+wire cond_42;
+wire cond_43;
+wire cond_44;
+wire cond_45;
+wire cond_46;
+wire cond_47;
+wire cond_48;
+wire cond_49;
+wire cond_50;
+wire cond_51;
+wire cond_52;
+wire cond_53;
+wire cond_54;
+wire cond_55;
+wire cond_56;
+wire cond_57;
+wire cond_58;
+wire cond_59;
+wire cond_60;
+wire cond_61;
+wire cond_62;
+wire cond_63;
+wire cond_64;
+wire cond_65;
+wire cond_66;
+wire cond_67;
+wire cond_68;
+wire cond_69;
+wire cond_70;
+wire cond_71;
+wire cond_72;
+wire cond_73;
+wire cond_74;
+wire cond_75;
+wire cond_76;
+wire cond_77;
+wire cond_78;
+wire cond_79;
+wire cond_80;
+wire cond_81;
+wire cond_82;
+wire cond_83;
+wire cond_84;
+wire cond_85;
+wire cond_86;
+wire cond_87;
+wire cond_88;
+wire cond_89;
+wire cond_90;
+wire cond_91;
+wire cond_92;
+wire cond_93;
+wire cond_94;
+wire cond_95;
+wire cond_96;
+wire cond_97;
+wire cond_98;
+wire cond_99;
+wire cond_100;
+wire cond_101;
+wire cond_102;
+wire cond_103;
+wire cond_104;
+wire cond_105;
+wire cond_106;
+wire cond_107;
+wire cond_108;
+wire cond_109;
+wire cond_110;
+wire cond_111;
+wire cond_112;
+wire cond_113;
+wire cond_114;
+wire cond_115;
+wire cond_116;
+wire cond_117;
+wire cond_118;
+wire cond_119;
+wire cond_120;
+wire cond_121;
+wire cond_122;
+wire cond_123;
+wire cond_124;
+wire cond_125;
+wire cond_126;
+wire cond_127;
+wire cond_128;
+wire cond_129;
+wire cond_130;
+wire cond_131;
+wire cond_132;
+wire cond_133;
+wire cond_134;
+wire cond_135;
+wire cond_136;
+wire cond_137;
+wire cond_138;
+wire cond_139;
+wire cond_140;
+wire cond_141;
+wire cond_142;
+wire cond_143;
+wire cond_144;
+wire cond_145;
+wire cond_146;
+wire cond_147;
+wire cond_148;
+wire cond_149;
+wire cond_150;
+wire cond_151;
+wire cond_152;
+wire cond_153;
+wire cond_154;
+wire cond_155;
+wire cond_156;
+wire cond_157;
+wire cond_158;
+wire cond_159;
+wire cond_160;
+wire cond_161;
+wire cond_162;
+wire cond_163;
+wire cond_164;
+wire cond_165;
+wire cond_166;
+wire cond_167;
+wire cond_168;
+wire cond_169;
+wire cond_170;
+wire cond_171;
+wire cond_172;
+wire cond_173;
+wire cond_174;
+wire cond_175;
+wire cond_176;
+wire cond_177;
+wire cond_178;
+wire cond_179;
+wire cond_180;
+wire cond_181;
+wire cond_182;
+wire cond_183;
+wire cond_184;
+wire cond_185;
+wire cond_186;
+wire cond_187;
+wire cond_188;
+wire cond_189;
+wire cond_190;
+wire cond_191;
+wire cond_192;
+wire cond_193;
+wire cond_194;
+wire cond_195;
+wire cond_196;
+wire cond_197;
+wire cond_198;
+wire cond_199;
+wire cond_200;
+wire cond_201;
+wire cond_202;
+wire cond_203;
+wire cond_204;
+wire cond_205;
+wire cond_206;
+wire cond_207;
+wire cond_208;
+wire cond_209;
+wire cond_210;
+wire cond_211;
+wire cond_212;
+wire cond_213;
+wire cond_214;
+wire cond_215;
+wire cond_216;
+wire cond_217;
+wire cond_218;
+wire cond_219;
+wire cond_220;
+wire cond_221;
+wire cond_222;
+wire cond_223;
+wire cond_224;
+wire cond_225;
+wire cond_226;
+wire cond_227;
+wire cond_228;
+wire cond_229;
+wire cond_230;
+wire cond_231;
+wire cond_232;
+wire cond_233;
+wire cond_234;
+wire cond_235;
+wire cond_236;
+wire cond_237;
+wire cond_238;
+wire cond_239;
+wire cond_240;
+wire cond_241;
+wire cond_242;
+wire cond_243;
+wire cond_244;
+wire cond_245;
+wire cond_246;
+wire cond_247;
+wire cond_248;
+wire cond_249;
+wire cond_250;
+wire cond_251;
+wire cond_252;
+wire cond_253;
+wire cond_254;
+wire cond_255;
+wire cond_256;
+wire cond_257;
+wire cond_258;
+
+assign rd_call_gate_param = glob_param_3[24:20] - 5'd1;
+
 assign rd_io_allow_1_fault = rd_cmd == `CMD_io_allow && rd_cmdex == `CMDEX_io_allow_1 && (   ~(tr_cache_valid) || (tr_cache[`DESC_BITS_TYPE] != `DESC_TSS_AVAIL_386 && tr_cache[`DESC_BITS_TYPE] != `DESC_TSS_BUSY_386) || tr_limit < 32'd103 );
 assign rd_io_allow_2_fault = rd_cmd == `CMD_io_allow && rd_cmdex == `CMDEX_io_allow_2 && ({ 16'd0, rd_memory_last[15:0] } + { 16'd0, 3'd0, glob_param_1[15:3] }) >= tr_limit;
 assign rd_io_allow_fault = rd_io_allow_1_fault || rd_io_allow_2_fault;
 
-wire rd_imul_modregrm_mutex_busy;
 assign rd_imul_modregrm_mutex_busy = (  rd_decoder[3]  && rd_mutex_busy_modregrm_reg) || (~(rd_decoder[3]) && rd_mutex_busy_eax);
 
-wire rd_arith_modregrm_to_rm;
-wire rd_arith_modregrm_to_reg;
 assign rd_arith_modregrm_to_rm = ~(rd_decoder[1]);
 assign rd_arith_modregrm_to_reg= rd_decoder[1];
 
-wire rd_in_condition;
 assign rd_in_condition = (rd_mutex_busy_active && (rd_cmdex == `CMDEX_IN_imm || rd_cmdex == `CMDEX_IN_dx) && ~(io_allow_check_needed)) || (rd_cmdex == `CMDEX_IN_dx && rd_mutex_busy_edx);
 
-wire [31:0] rd_offset_for_esp_from_tss;
-wire [31:0] rd_offset_for_ss_from_tss;
-wire [31:0] r_limit_for_ss_esp_from_tss;
-wire        rd_ss_esp_from_tss_386;
 assign rd_ss_esp_from_tss_386 = tr_cache[`DESC_BITS_TYPE] == `DESC_TSS_AVAIL_386 || tr_cache[`DESC_BITS_TYPE] == `DESC_TSS_BUSY_386;
 assign r_limit_for_ss_esp_from_tss = (rd_ss_esp_from_tss_386)?   { 27'd0, glob_descriptor[`DESC_BITS_DPL], 3'd0 } + 32'd11 : { 28'd0, glob_descriptor[`DESC_BITS_DPL], 2'd0 } + 32'd5;
 assign rd_offset_for_ss_from_tss = (rd_ss_esp_from_tss_386)?   { 27'd0, glob_descriptor[`DESC_BITS_DPL], 3'd0 } + 32'd8 : { 28'd0, glob_descriptor[`DESC_BITS_DPL], 2'd0 } + 32'd4;
 assign rd_offset_for_esp_from_tss = (rd_ss_esp_from_tss_386)?   { 27'd0, glob_descriptor[`DESC_BITS_DPL], 3'd0 } + 32'd4 : { 28'd0, glob_descriptor[`DESC_BITS_DPL], 2'd0 } + 32'd2;
 assign rd_ss_esp_from_tss_fault = (   (rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_0) || (rd_cmd == `CMD_int_2  && rd_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_0) ) && r_limit_for_ss_esp_from_tss > tr_limit;
 
-wire [31:0] rd_task_switch_linear_next;
-reg [31:0] rd_task_switch_linear_reg;
 assign rd_task_switch_linear_next = (glob_descriptor[`DESC_BITS_TYPE] <= 4'd3)? rd_task_switch_linear_reg + 32'd2 : rd_task_switch_linear_reg + 32'd4;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0)                                                               rd_task_switch_linear_reg <= 32'd0; else if(rd_cmd == `CMD_task_switch && rd_cmdex == `CMDEX_task_switch_STEP_12)   rd_task_switch_linear_reg <= rd_system_linear; else if(rd_ready)                                                               rd_task_switch_linear_reg <= rd_task_switch_linear_next;
+always @(posedge clk) begin if(rst)                                                               rd_task_switch_linear_reg <= 32'd0; else if(rd_cmd == `CMD_task_switch && rd_cmdex == `CMDEX_task_switch_STEP_12)   rd_task_switch_linear_reg <= rd_system_linear; else if(rd_ready)                                                               rd_task_switch_linear_reg <= rd_task_switch_linear_next;
 end
 
 //======================================================== conditions
-wire cond_0 = rd_cmd == `CMD_XADD && rd_cmdex == `CMDEX_XADD_FIRST;
-wire cond_1 = rd_modregrm_mod == 2'b11;
-wire cond_2 = rd_mutex_busy_modregrm_reg || rd_mutex_busy_modregrm_rm;
-wire cond_3 = rd_modregrm_mod != 2'b11;
-wire cond_4 = rd_mutex_busy_modregrm_reg || rd_mutex_busy_memory;
-wire cond_5 = ~(read_for_rd_ready);
-wire cond_6 = rd_cmd == `CMD_XADD && rd_cmdex == `CMDEX_XADD_LAST;
-wire cond_7 = rd_cmd == `CMD_CALL && rd_cmdex == `CMDEX_CALL_Ev_STEP_0;
-wire cond_8 = rd_mutex_busy_modregrm_rm;
-wire cond_9 = rd_mutex_busy_memory;
-wire cond_10 = rd_cmd == `CMD_CALL && rd_cmdex == `CMDEX_CALL_Jv_STEP_0;
-wire cond_11 = rd_cmd == `CMD_CALL && (rd_cmdex == `CMDEX_CALL_Ep_STEP_0 || rd_cmdex == `CMDEX_CALL_Ep_STEP_1);
-wire cond_12 = rd_cmdex == `CMDEX_CALL_Ep_STEP_1;
-wire cond_13 = rd_cmd == `CMD_CALL && rd_cmdex == `CMDEX_CALL_Ap_STEP_0;
-wire cond_14 = rd_cmd == `CMD_CALL && rd_cmdex == `CMDEX_CALL_Ap_STEP_1;
-wire cond_15 = rd_cmd == `CMD_CALL && rd_cmdex == `CMDEX_CALL_protected_STEP_0;
-wire cond_16 = rd_mutex_busy_active;
-wire cond_17 = glob_param_1[15:2] != 14'd0;
-wire cond_18 = rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_task_gate_STEP_0;
-wire cond_19 = rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_task_gate_STEP_1;
-wire cond_20 = glob_param_1[`SELECTOR_BIT_TI] == 1'b0;
-wire cond_21 = rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_call_gate_STEP_1;
-wire cond_22 = rd_cmd == `CMD_CALL_3 && (rd_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_4 || rd_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_5);
-wire cond_23 = ~(glob_param_3[19]);
-wire cond_24 = glob_param_3[19];
-wire cond_25 = rd_ready;
-wire cond_26 = rd_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_4;
-wire cond_27 = rd_cmd == `CMD_PUSH_MOV_SEG && { rd_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_implicit;
-wire cond_28 = rd_cmd == `CMD_PUSH_MOV_SEG && { rd_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_modregrm;
-wire cond_29 = ~(write_virtual_check_ready);
-wire cond_30 = rd_cmd == `CMD_NEG;
-wire cond_31 = rd_cmd == `CMD_INVLPG && rd_cmdex == `CMDEX_INVLPG_STEP_1;
-wire cond_32 = ~(rd_address_effective_ready);
-wire cond_33 = rd_cmd == `CMD_io_allow && rd_cmdex == `CMDEX_io_allow_1;
-wire cond_34 = rd_io_allow_1_fault || rd_mutex_busy_active;
-wire cond_35 = rd_cmd == `CMD_io_allow && rd_cmdex == `CMDEX_io_allow_2;
-wire cond_36 = rd_io_allow_2_fault;
-wire cond_37 = rd_cmd == `CMD_SCAS;
-wire cond_38 = rd_mutex_busy_memory || (rd_mutex_busy_ecx && rd_prefix_group_1_rep != 2'd0);
-wire cond_39 = ~(rd_string_ignore);
-wire cond_40 = rd_cmd == `CMD_INC_DEC && { rd_cmdex[3:1], 1'b0 } == `CMDEX_INC_DEC_modregrm;
-wire cond_41 = rd_cmd == `CMD_INC_DEC && { rd_cmdex[3:1], 1'b0 } == `CMDEX_INC_DEC_implicit;
-wire cond_42 = rd_mutex_busy_implicit_reg;
-wire cond_43 = rd_cmd == `CMD_RET_near && rd_cmdex != `CMDEX_RET_near_LAST;
-wire cond_44 = rd_cmd == `CMD_ARPL;
-wire cond_45 = rd_mutex_busy_modregrm_rm || rd_mutex_busy_modregrm_reg;
-wire cond_46 = rd_mutex_busy_memory || rd_mutex_busy_modregrm_reg;
-wire cond_47 = rd_cmd == `CMD_BSWAP;
-wire cond_48 = rd_cmd == `CMD_LxS && rd_cmdex == `CMDEX_LxS_STEP_1;
-wire cond_49 = ~(rd_address_effective_ready) || rd_mutex_busy_memory;
-wire cond_50 = rd_operand_16bit;
-wire cond_51 = rd_cmd == `CMD_LxS && rd_cmdex == `CMDEX_LxS_STEP_2;
-wire cond_52 = rd_operand_32bit;
-wire cond_53 = rd_cmd == `CMD_LxS && rd_cmdex == `CMDEX_LxS_STEP_3;
-wire cond_54 = rd_cmd == `CMD_LxS && rd_cmdex == `CMDEX_LxS_STEP_LAST;
-wire cond_55 = (rd_cmd == `CMD_MOV_to_seg || rd_cmd == `CMD_LLDT || rd_cmd == `CMD_LTR) && rd_cmdex == `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1;
-wire cond_56 = rd_cmd == `CMD_MOV_to_seg || cpl == 2'd0;
-wire cond_57 = rd_cmd == `CMD_MOV_to_seg;
-wire cond_58 = rd_cmd == `CMD_LLDT;
-wire cond_59 = rd_cmd == `CMD_LTR;
-wire cond_60 = rd_cmd == `CMD_CLC || rd_cmd == `CMD_CMC || rd_cmd == `CMD_CLD || rd_cmd == `CMD_STC || rd_cmd == `CMD_STD || rd_cmd == `CMD_SAHF;
-wire cond_61 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_task_gate_STEP_0;
-wire cond_62 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_task_gate_STEP_1;
-wire cond_63 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_int_trap_gate_STEP_1;
-wire cond_64 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_real_STEP_3;
-wire cond_65 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_real_STEP_4;
-wire cond_66 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_protected_STEP_1;
-wire cond_67 = rd_cmd == `CMD_AAM || rd_cmd == `CMD_AAD;
-wire cond_68 = rd_mutex_busy_eax;
-wire cond_69 = rd_cmd == `CMD_load_seg && rd_cmdex == `CMDEX_load_seg_STEP_1;
-wire cond_70 = v8086_mode;
-wire cond_71 = real_mode;
-wire cond_72 = protected_mode;
-wire cond_73 = rd_cmd == `CMD_load_seg && rd_cmdex == `CMDEX_load_seg_STEP_2;
-wire cond_74 = ~(protected_mode && glob_param_1[15:2] == 14'd0);
-wire cond_75 = rd_cmd == `CMD_POP_seg && rd_cmdex == `CMDEX_POP_seg_STEP_1;
-wire cond_76 = { rd_cmd[6:2], 2'd0 } == `CMD_BTx;
-wire cond_77 = rd_mutex_busy_modregrm_rm || (rd_cmdex == `CMDEX_BTx_modregrm && rd_mutex_busy_modregrm_reg);
-wire cond_78 = rd_mutex_busy_memory || (rd_cmdex == `CMDEX_BTx_modregrm && rd_mutex_busy_modregrm_reg);
-wire cond_79 = rd_cmd == `CMD_IRET && rd_cmdex <= `CMDEX_IRET_real_v86_STEP_2;
-wire cond_80 = rd_cmdex >`CMDEX_IRET_real_v86_STEP_0;
-wire cond_81 = rd_cmdex == `CMDEX_IRET_real_v86_STEP_0;
-wire cond_82 = rd_cmdex == `CMDEX_IRET_real_v86_STEP_1;
-wire cond_83 = rd_cmdex == `CMDEX_IRET_real_v86_STEP_2;
-wire cond_84 = rd_mutex_busy_memory || (rd_mutex_busy_eflags && v8086_mode);
-wire cond_85 = ~(v8086_mode) || iopl == 2'd3;
-wire cond_86 = rd_cmd == `CMD_IRET && rd_cmdex == `CMDEX_IRET_protected_STEP_0;
-wire cond_87 = rd_mutex_busy_memory || rd_mutex_busy_eflags;
-wire cond_88 = rd_cmd == `CMD_IRET && rd_cmdex == `CMDEX_IRET_task_switch_STEP_0;
-wire cond_89 = rd_cmd == `CMD_IRET && rd_cmdex == `CMDEX_IRET_task_switch_STEP_1;
-wire cond_90 = ~(rd_descriptor_not_in_limits);
-wire cond_91 = rd_cmd == `CMD_IRET && rd_cmdex >= `CMDEX_IRET_protected_STEP_1 && rd_cmdex <= `CMDEX_IRET_protected_STEP_3;
-wire cond_92 = rd_cmdex == `CMDEX_IRET_protected_STEP_1;
-wire cond_93 = rd_cmdex == `CMDEX_IRET_protected_STEP_2;
-wire cond_94 = rd_cmdex == `CMDEX_IRET_protected_STEP_3;
-wire cond_95 = rd_cmd == `CMD_IRET && rd_cmdex >= `CMDEX_IRET_protected_to_v86_STEP_0;
-wire cond_96 = rd_cmdex == `CMDEX_IRET_protected_to_v86_STEP_0;
-wire cond_97 = rd_cmd == `CMD_IRET_2 && rd_cmdex == `CMDEX_IRET_2_protected_outer_STEP_0;
-wire cond_98 = rd_cmd == `CMD_IRET_2 && rd_cmdex >= `CMDEX_IRET_2_protected_outer_STEP_1 && rd_cmdex <= `CMDEX_IRET_2_protected_outer_STEP_3;
-wire cond_99 = rd_cmdex == `CMDEX_IRET_2_protected_outer_STEP_1;
-wire cond_100 = rd_cmdex == `CMDEX_IRET_2_protected_outer_STEP_2;
-wire cond_101 = rd_cmdex == `CMDEX_IRET_2_protected_outer_STEP_3;
-wire cond_102 = rd_cmd == `CMD_IRET_2 && rd_cmdex >= `CMDEX_IRET_2_protected_outer_STEP_6;
-wire cond_103 = rd_cmd == `CMD_POP && rd_cmdex == `CMDEX_POP_implicit;
-wire cond_104 = rd_mutex_busy_memory || rd_mutex_busy_esp;
-wire cond_105 = rd_cmd == `CMD_POP && rd_cmdex == `CMDEX_POP_modregrm_STEP_0;
-wire cond_106 = rd_cmd == `CMD_POP && rd_cmdex == `CMDEX_POP_modregrm_STEP_1;
-wire cond_107 = rd_cmd == `CMD_IDIV || rd_cmd == `CMD_DIV;
-wire cond_108 = rd_mutex_busy_eax || (rd_decoder[0] && rd_mutex_busy_edx) || rd_mutex_busy_modregrm_rm;
-wire cond_109 = rd_mutex_busy_eax || (rd_decoder[0] && rd_mutex_busy_edx) || rd_mutex_busy_memory;
-wire cond_110 = rd_cmd == `CMD_Shift && rd_cmdex != `CMDEX_Shift_implicit;
-wire cond_111 = rd_cmd == `CMD_Shift && rd_cmdex == `CMDEX_Shift_implicit;
-wire cond_112 = rd_mutex_busy_modregrm_rm || rd_mutex_busy_ecx;
-wire cond_113 = rd_mutex_busy_memory || rd_mutex_busy_ecx;
-wire cond_114 = rd_cmd == `CMD_CMPS && rd_cmdex == `CMDEX_CMPS_FIRST;
-wire cond_115 = rd_cmd == `CMD_CMPS && rd_cmdex == `CMDEX_CMPS_LAST;
-wire cond_116 = rd_cmd == `CMD_control_reg && rd_cmdex == `CMDEX_control_reg_SMSW_STEP_0;
-wire cond_117 = rd_cmd == `CMD_control_reg && rd_cmdex == `CMDEX_control_reg_LMSW_STEP_0;
-wire cond_118 = cpl == 2'd0;
-wire cond_119 = rd_cmd == `CMD_control_reg && rd_cmdex == `CMDEX_control_reg_MOV_load_STEP_0;
-wire cond_120 = rd_cmd == `CMD_control_reg && rd_cmdex == `CMDEX_control_reg_MOV_store_STEP_0;
-wire cond_121 = (rd_cmd == `CMD_LGDT || rd_cmd == `CMD_LIDT) && (rd_cmdex == `CMDEX_LGDT_LIDT_STEP_1 || rd_cmdex == `CMDEX_LGDT_LIDT_STEP_2);
-wire cond_122 = rd_cmdex == `CMDEX_LGDT_LIDT_STEP_1;
-wire cond_123 = rd_cmdex == `CMDEX_LGDT_LIDT_STEP_2;
-wire cond_124 = rd_cmd == `CMD_PUSHA;
-wire cond_125 = (rd_cmdex == `CMDEX_PUSHA_STEP_0 && rd_mutex_busy_eax) || (rd_cmdex == `CMDEX_PUSHA_STEP_1 && rd_mutex_busy_ecx) || (rd_cmdex == `CMDEX_PUSHA_STEP_2 && rd_mutex_busy_edx);
-wire cond_126 = rd_cmd == `CMD_SETcc;
-wire cond_127 = rd_cmd == `CMD_CMPXCHG;
-wire cond_128 = rd_cmd == `CMD_ENTER && rd_cmdex == `CMDEX_ENTER_FIRST;
-wire cond_129 = rd_mutex_busy_ebp;
-wire cond_130 = rd_cmd == `CMD_ENTER && rd_cmdex == `CMDEX_ENTER_LAST;
-wire cond_131 = rd_cmd == `CMD_ENTER && rd_cmdex == `CMDEX_ENTER_PUSH;
-wire cond_132 = rd_cmd == `CMD_ENTER && rd_cmdex == `CMDEX_ENTER_LOOP;
-wire cond_133 = rd_cmd == `CMD_IMUL && rd_cmdex == `CMDEX_IMUL_modregrm_imm;
-wire cond_134 = rd_decoder[1:0] == 2'b11;
-wire cond_135 = rd_cmd == `CMD_IMUL && rd_cmdex == `CMDEX_IMUL_modregrm;
-wire cond_136 = rd_imul_modregrm_mutex_busy || rd_mutex_busy_modregrm_rm;
-wire cond_137 = rd_imul_modregrm_mutex_busy || rd_mutex_busy_memory;
-wire cond_138 = rd_cmd == `CMD_LEAVE;
-wire cond_139 = { rd_cmd[6:1], 1'd0 } == `CMD_SHxD && rd_cmdex != `CMDEX_SHxD_implicit;
-wire cond_140 = { rd_cmd[6:1], 1'd0 } == `CMD_SHxD && rd_cmdex == `CMDEX_SHxD_implicit;
-wire cond_141 = rd_mutex_busy_modregrm_rm || rd_mutex_busy_ecx || rd_mutex_busy_modregrm_reg;
-wire cond_142 = rd_mutex_busy_memory || rd_mutex_busy_ecx || rd_mutex_busy_modregrm_reg;
-wire cond_143 = { rd_cmd[6:3], 3'd0 } == `CMD_Arith && rd_cmdex == `CMDEX_Arith_modregrm;
-wire cond_144 = rd_decoder[5:3] != 3'b111;
-wire cond_145 = rd_decoder[5:3] != 3'b111 && rd_arith_modregrm_to_rm;
-wire cond_146 = rd_decoder[5:3] != 3'b111 && rd_arith_modregrm_to_reg;
-wire cond_147 = { rd_cmd[6:3], 3'd0 } == `CMD_Arith && rd_cmdex == `CMDEX_Arith_modregrm_imm;
-wire cond_148 = rd_decoder[13:11] != 3'b111;
-wire cond_149 = { rd_cmd[6:3], 3'd0 } == `CMD_Arith && rd_cmdex == `CMDEX_Arith_immediate;
-wire cond_150 = rd_cmd == `CMD_MUL;
-wire cond_151 = rd_mutex_busy_eax || rd_mutex_busy_modregrm_rm;
-wire cond_152 = rd_mutex_busy_eax || rd_mutex_busy_memory;
-wire cond_153 = rd_cmd == `CMD_LOOP;
-wire cond_154 = rd_cmd == `CMD_TEST && rd_cmdex == `CMDEX_TEST_modregrm;
-wire cond_155 = rd_cmd == `CMD_TEST && rd_cmdex == `CMDEX_TEST_modregrm_imm;
-wire cond_156 = rd_cmd == `CMD_TEST && rd_cmdex == `CMDEX_TEST_immediate;
-wire cond_157 = rd_cmd == `CMD_RET_far && rd_cmdex == `CMDEX_RET_far_outer_STEP_3;
-wire cond_158 = rd_cmd == `CMD_RET_far && rd_cmdex == `CMDEX_RET_far_STEP_1;
-wire cond_159 = real_mode || v8086_mode;
-wire cond_160 = rd_cmd == `CMD_RET_far && rd_cmdex == `CMDEX_RET_far_STEP_2;
-wire cond_161 = rd_cmd == `CMD_RET_far && rd_cmdex == `CMDEX_RET_far_outer_STEP_4;
-wire cond_162 = rd_cmd == `CMD_LODS;
-wire cond_163 = rd_cmd == `CMD_XCHG && rd_cmdex == `CMDEX_XCHG_implicit;
-wire cond_164 = rd_mutex_busy_implicit_reg || rd_mutex_busy_eax;
-wire cond_165 = rd_cmd == `CMD_XCHG && rd_cmdex == `CMDEX_XCHG_modregrm;
-wire cond_166 = rd_cmd == `CMD_XCHG && rd_cmdex == `CMDEX_XCHG_modregrm_LAST;
-wire cond_167 = rd_cmd == `CMD_PUSH && (rd_cmdex == `CMDEX_PUSH_immediate || rd_cmdex == `CMDEX_PUSH_immediate_se);
-wire cond_168 = rd_cmd == `CMD_PUSH && rd_cmdex == `CMDEX_PUSH_implicit;
-wire cond_169 = rd_cmd == `CMD_PUSH && rd_cmdex == `CMDEX_PUSH_modregrm;
-wire cond_170 = rd_cmd == `CMD_INT_INTO && rd_cmdex == `CMDEX_INT_INTO_INTO_STEP_0;
-wire cond_171 = rd_mutex_busy_eflags;
-wire cond_172 = rd_cmd == `CMD_CPUID;
-wire cond_173 = rd_cmd == `CMD_IN && rd_cmdex != `CMDEX_IN_idle;
-wire cond_174 = rd_in_condition;
-wire cond_175 = ~(io_allow_check_needed) || rd_cmdex == `CMDEX_IN_protected;
-wire cond_176 = ~(rd_io_ready);
-wire cond_177 = rd_cmd == `CMD_NOT;
-wire cond_178 = (rd_cmd == `CMD_LAR || rd_cmd == `CMD_LSL || rd_cmd == `CMD_VERR || rd_cmd == `CMD_VERW) && rd_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_1;
-wire cond_179 = (rd_cmd == `CMD_LAR || rd_cmd == `CMD_LSL || rd_cmd == `CMD_VERR || rd_cmd == `CMD_VERW) && rd_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_2;
-wire cond_180 = ~(glob_param_1[15:2] == 14'd0) && ~(rd_descriptor_not_in_limits);
-wire cond_181 = (rd_cmd == `CMD_LAR || rd_cmd == `CMD_LSL) && rd_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_LAST;
-wire cond_182 = rd_cmd == `CMD_LAR;
-wire cond_183 = exe_mutex[`MUTEX_ACTIVE_BIT];
-wire cond_184 = glob_param_2[1:0] == 2'd0 && ((glob_param_2[2] == 1'd0 && rd_cmd == `CMD_LAR) || (glob_param_2[3] == 1'd0 && rd_cmd == `CMD_LSL));
-wire cond_185 = (rd_cmd == `CMD_VERR || rd_cmd == `CMD_VERW) && rd_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_LAST;
-wire cond_186 = glob_param_2[1:0] == 2'd0 && ((glob_param_2[4] == 1'd0 && rd_cmd == `CMD_VERR) || (glob_param_2[5] == 1'd0 && rd_cmd == `CMD_VERW));
-wire cond_187 =  (rd_cmd == `CMD_int_2  && rd_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_0) || (rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_0) ;
-wire cond_188 = rd_ss_esp_from_tss_fault;
-wire cond_189 =  (rd_cmd == `CMD_int_2 && rd_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_1) || (rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_1) ;
-wire cond_190 =  (rd_cmd == `CMD_int_2 && rd_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_2) || (rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_2) ;
-wire cond_191 = rd_cmd == `CMD_STOS;
-wire cond_192 = rd_mutex_busy_eax || (rd_mutex_busy_ecx && rd_prefix_group_1_rep != 2'd0);
-wire cond_193 = rd_cmd == `CMD_INS && (rd_cmdex == `CMDEX_INS_real_1 || rd_cmdex == `CMDEX_INS_protected_1);
-wire cond_194 = rd_mutex_busy_ecx && rd_prefix_group_1_rep != 2'd0;
-wire cond_195 = ~(rd_string_ignore) && ~(io_allow_check_needed && rd_cmdex == `CMDEX_INS_real_1);
-wire cond_196 = rd_cmd == `CMD_INS && (rd_cmdex == `CMDEX_INS_real_2 || rd_cmdex == `CMDEX_INS_protected_2);
-wire cond_197 = rd_mutex_busy_edx || (rd_mutex_busy_ecx && rd_prefix_group_1_rep != 2'd0);
-wire cond_198 = rd_cmd == `CMD_OUTS;
-wire cond_199 = ~(rd_string_ignore) && ~(io_allow_check_needed && rd_cmdex == `CMDEX_OUTS_first);
-wire cond_200 = rd_cmd == `CMD_PUSHF;
-wire cond_201 = rd_cmd == `CMD_JMP && rd_cmdex == `CMDEX_JMP_Jv_STEP_0;
-wire cond_202 = rd_cmd == `CMD_JMP  && rd_cmdex == `CMDEX_JMP_Ap_STEP_1;
-wire cond_203 = rd_cmd == `CMD_JMP_2 && rd_cmdex == `CMDEX_JMP_2_call_gate_STEP_0;
-wire cond_204 = rd_cmd == `CMD_JMP_2 && rd_cmdex == `CMDEX_JMP_2_call_gate_STEP_1;
-wire cond_205 = rd_cmd == `CMD_JMP  && rd_cmdex == `CMDEX_JMP_Ev_STEP_0;
-wire cond_206 = rd_cmd == `CMD_JMP  && (rd_cmdex == `CMDEX_JMP_Ep_STEP_0  || rd_cmdex == `CMDEX_JMP_Ep_STEP_1);
-wire cond_207 = rd_cmdex == `CMDEX_JMP_Ep_STEP_1;
-wire cond_208 = rd_cmd == `CMD_JMP  && rd_cmdex == `CMDEX_JMP_Ap_STEP_0;
-wire cond_209 = rd_cmd == `CMD_JMP && rd_cmdex == `CMDEX_JMP_protected_STEP_0;
-wire cond_210 = rd_cmd == `CMD_JMP && rd_cmdex == `CMDEX_JMP_task_gate_STEP_0;
-wire cond_211 = rd_cmd == `CMD_JMP && rd_cmdex == `CMDEX_JMP_task_gate_STEP_1;
-wire cond_212 = rd_cmd == `CMD_OUT;
-wire cond_213 = rd_cmd == `CMD_MOV && rd_cmdex == `CMDEX_MOV_memoffset;
-wire cond_214 = ~(rd_decoder[1]);
-wire cond_215 = rd_mutex_busy_eax || ~(write_virtual_check_ready);
-wire cond_216 = rd_cmd == `CMD_MOV && rd_cmdex == `CMDEX_MOV_modregrm && rd_decoder[1];
-wire cond_217 = rd_cmd == `CMD_MOV && rd_cmdex == `CMDEX_MOV_modregrm && ~(rd_decoder[1]);
-wire cond_218 = rd_mutex_busy_modregrm_reg;
-wire cond_219 = rd_cmd == `CMD_MOV && rd_cmdex == `CMDEX_MOV_modregrm_imm;
-wire cond_220 = rd_cmd == `CMD_MOV && rd_cmdex == `CMDEX_MOV_immediate;
-wire cond_221 = rd_cmd == `CMD_LAHF || rd_cmd == `CMD_CBW || rd_cmd == `CMD_CWD;
-wire cond_222 = rd_cmd == `CMD_POPF && rd_cmdex == `CMDEX_POPF_STEP_0;
-wire cond_223 = rd_cmd == `CMD_CLI || rd_cmd == `CMD_STI;
-wire cond_224 = rd_cmd == `CMD_BOUND && rd_cmdex == `CMDEX_BOUND_STEP_FIRST;
-wire cond_225 = rd_cmd == `CMD_BOUND && rd_cmdex == `CMDEX_BOUND_STEP_LAST;
-wire cond_226 = rd_cmd == `CMD_SALC && rd_cmdex == `CMDEX_SALC_STEP_0;
-wire cond_227 = rd_cmd == `CMD_task_switch && rd_cmdex == `CMDEX_task_switch_STEP_6;
-wire cond_228 = glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_JUMP || glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_IRET;
-wire cond_229 = rd_cmd == `CMD_task_switch && rd_cmdex == `CMDEX_task_switch_STEP_9;
-wire cond_230 = rd_cmd == `CMD_task_switch_2 && rd_cmdex <= `CMDEX_task_switch_2_STEP_7;
-wire cond_231 = rd_cmd == `CMD_task_switch_2 && rd_cmdex == `CMDEX_task_switch_2_STEP_13;
-wire cond_232 = rd_cmd == `CMD_task_switch && rd_cmdex >= `CMDEX_task_switch_STEP_12 && rd_cmdex <= `CMDEX_task_switch_STEP_14;
-wire cond_233 = rd_cmdex == `CMDEX_task_switch_STEP_12 && glob_descriptor[`DESC_BITS_TYPE] <= 4'd3;
-wire cond_234 = rd_cmdex == `CMDEX_task_switch_STEP_12 && glob_descriptor[`DESC_BITS_TYPE] >  4'd3;
-wire cond_235 = rd_cmdex == `CMDEX_task_switch_STEP_13 || rd_cmdex == `CMDEX_task_switch_STEP_14;
-wire cond_236 = rd_cmdex != `CMDEX_task_switch_STEP_12 || (glob_descriptor[`DESC_BITS_TYPE] > 4'd3 && cr0_pg);
-wire cond_237 = rd_cmd == `CMD_task_switch_3;
-wire cond_238 = rd_cmdex <= `CMDEX_task_switch_3_STEP_12 || glob_descriptor[`DESC_BITS_TYPE] > 4'd3;
-wire cond_239 = rd_cmd == `CMD_task_switch_4 && rd_cmdex == `CMDEX_task_switch_4_STEP_0;
-wire cond_240 = glob_param_1[`TASK_SWITCH_SOURCE_BITS] != `TASK_SWITCH_FROM_IRET;
-wire cond_241 = rd_cmd == `CMD_task_switch_4 && rd_cmdex == `CMDEX_task_switch_4_STEP_2;
-wire cond_242 = glob_param_1[`SELECTOR_BIT_TI] == 1'b0 && glob_param_1[15:2] != 14'd0 && ~(rd_descriptor_not_in_limits);
-wire cond_243 = rd_cmd == `CMD_task_switch_4 && rd_cmdex >= `CMDEX_task_switch_4_STEP_3 && rd_cmdex <= `CMDEX_task_switch_4_STEP_8;
-wire cond_244 = glob_param_1[15:2] != 14'd0 && ~(rd_descriptor_not_in_limits);
-wire cond_245 = rd_cmd == `CMD_LEA;
-wire cond_246 = (rd_cmd == `CMD_SGDT || rd_cmd == `CMD_SIDT);
-wire cond_247 = rd_cmdex == `CMDEX_SGDT_SIDT_STEP_1;
-wire cond_248 = rd_cmdex == `CMDEX_SGDT_SIDT_STEP_2;
-wire cond_249 = rd_cmd == `CMD_MOVS;
-wire cond_250 = rd_cmd == `CMD_MOVSX || rd_cmd == `CMD_MOVZX;
-wire cond_251 = rd_cmd == `CMD_POPA;
-wire cond_252 = rd_cmdex[2:0] > 3'd0;
-wire cond_253 = rd_cmdex[2:0] == 3'd7;
-wire cond_254 = rd_cmd == `CMD_debug_reg && rd_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0;
-wire cond_255 = rd_cmd == `CMD_debug_reg && rd_cmdex == `CMDEX_debug_reg_MOV_load_STEP_0;
-wire cond_256 = rd_cmd == `CMD_XLAT;
-wire cond_257 = rd_cmd == `CMD_AAA || rd_cmd == `CMD_AAS || rd_cmd == `CMD_DAA || rd_cmd == `CMD_DAS;
-wire cond_258 = { rd_cmd[6:1], 1'd0 } == `CMD_BSx;
+ assign cond_0 = rd_cmd == `CMD_XADD && rd_cmdex == `CMDEX_XADD_FIRST;
+ assign cond_1 = rd_modregrm_mod == 2'b11;
+ assign cond_2 = rd_mutex_busy_modregrm_reg || rd_mutex_busy_modregrm_rm;
+ assign cond_3 = rd_modregrm_mod != 2'b11;
+ assign cond_4 = rd_mutex_busy_modregrm_reg || rd_mutex_busy_memory;
+ assign cond_5 = ~(read_for_rd_ready);
+ assign cond_6 = rd_cmd == `CMD_XADD && rd_cmdex == `CMDEX_XADD_LAST;
+ assign cond_7 = rd_cmd == `CMD_CALL && rd_cmdex == `CMDEX_CALL_Ev_STEP_0;
+ assign cond_8 = rd_mutex_busy_modregrm_rm;
+ assign cond_9 = rd_mutex_busy_memory;
+ assign cond_10 = rd_cmd == `CMD_CALL && rd_cmdex == `CMDEX_CALL_Jv_STEP_0;
+ assign cond_11 = rd_cmd == `CMD_CALL && (rd_cmdex == `CMDEX_CALL_Ep_STEP_0 || rd_cmdex == `CMDEX_CALL_Ep_STEP_1);
+ assign cond_12 = rd_cmdex == `CMDEX_CALL_Ep_STEP_1;
+ assign cond_13 = rd_cmd == `CMD_CALL && rd_cmdex == `CMDEX_CALL_Ap_STEP_0;
+ assign cond_14 = rd_cmd == `CMD_CALL && rd_cmdex == `CMDEX_CALL_Ap_STEP_1;
+ assign cond_15 = rd_cmd == `CMD_CALL && rd_cmdex == `CMDEX_CALL_protected_STEP_0;
+ assign cond_16 = rd_mutex_busy_active;
+ assign cond_17 = glob_param_1[15:2] != 14'd0;
+ assign cond_18 = rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_task_gate_STEP_0;
+ assign cond_19 = rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_task_gate_STEP_1;
+ assign cond_20 = glob_param_1[`SELECTOR_BIT_TI] == 1'b0;
+ assign cond_21 = rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_call_gate_STEP_1;
+ assign cond_22 = rd_cmd == `CMD_CALL_3 && (rd_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_4 || rd_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_5);
+ assign cond_23 = ~(glob_param_3[19]);
+ assign cond_24 = glob_param_3[19];
+ assign cond_25 = rd_ready;
+ assign cond_26 = rd_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_4;
+ assign cond_27 = rd_cmd == `CMD_PUSH_MOV_SEG && { rd_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_implicit;
+ assign cond_28 = rd_cmd == `CMD_PUSH_MOV_SEG && { rd_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_modregrm;
+ assign cond_29 = ~(write_virtual_check_ready);
+ assign cond_30 = rd_cmd == `CMD_NEG;
+ assign cond_31 = rd_cmd == `CMD_INVLPG && rd_cmdex == `CMDEX_INVLPG_STEP_1;
+ assign cond_32 = ~(rd_address_effective_ready);
+ assign cond_33 = rd_cmd == `CMD_io_allow && rd_cmdex == `CMDEX_io_allow_1;
+ assign cond_34 = rd_io_allow_1_fault || rd_mutex_busy_active;
+ assign cond_35 = rd_cmd == `CMD_io_allow && rd_cmdex == `CMDEX_io_allow_2;
+ assign cond_36 = rd_io_allow_2_fault;
+ assign cond_37 = rd_cmd == `CMD_SCAS;
+ assign cond_38 = rd_mutex_busy_memory || (rd_mutex_busy_ecx && rd_prefix_group_1_rep != 2'd0);
+ assign cond_39 = ~(rd_string_ignore);
+ assign cond_40 = rd_cmd == `CMD_INC_DEC && { rd_cmdex[3:1], 1'b0 } == `CMDEX_INC_DEC_modregrm;
+ assign cond_41 = rd_cmd == `CMD_INC_DEC && { rd_cmdex[3:1], 1'b0 } == `CMDEX_INC_DEC_implicit;
+ assign cond_42 = rd_mutex_busy_implicit_reg;
+ assign cond_43 = rd_cmd == `CMD_RET_near && rd_cmdex != `CMDEX_RET_near_LAST;
+ assign cond_44 = rd_cmd == `CMD_ARPL;
+ assign cond_45 = rd_mutex_busy_modregrm_rm || rd_mutex_busy_modregrm_reg;
+ assign cond_46 = rd_mutex_busy_memory || rd_mutex_busy_modregrm_reg;
+ assign cond_47 = rd_cmd == `CMD_BSWAP;
+ assign cond_48 = rd_cmd == `CMD_LxS && rd_cmdex == `CMDEX_LxS_STEP_1;
+ assign cond_49 = ~(rd_address_effective_ready) || rd_mutex_busy_memory;
+ assign cond_50 = rd_operand_16bit;
+ assign cond_51 = rd_cmd == `CMD_LxS && rd_cmdex == `CMDEX_LxS_STEP_2;
+ assign cond_52 = rd_operand_32bit;
+ assign cond_53 = rd_cmd == `CMD_LxS && rd_cmdex == `CMDEX_LxS_STEP_3;
+ assign cond_54 = rd_cmd == `CMD_LxS && rd_cmdex == `CMDEX_LxS_STEP_LAST;
+ assign cond_55 = (rd_cmd == `CMD_MOV_to_seg || rd_cmd == `CMD_LLDT || rd_cmd == `CMD_LTR) && rd_cmdex == `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1;
+ assign cond_56 = rd_cmd == `CMD_MOV_to_seg || cpl == 2'd0;
+ assign cond_57 = rd_cmd == `CMD_MOV_to_seg;
+ assign cond_58 = rd_cmd == `CMD_LLDT;
+ assign cond_59 = rd_cmd == `CMD_LTR;
+ assign cond_60 = rd_cmd == `CMD_CLC || rd_cmd == `CMD_CMC || rd_cmd == `CMD_CLD || rd_cmd == `CMD_STC || rd_cmd == `CMD_STD || rd_cmd == `CMD_SAHF;
+ assign cond_61 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_task_gate_STEP_0;
+ assign cond_62 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_task_gate_STEP_1;
+ assign cond_63 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_int_trap_gate_STEP_1;
+ assign cond_64 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_real_STEP_3;
+ assign cond_65 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_real_STEP_4;
+ assign cond_66 = rd_cmd == `CMD_int && rd_cmdex == `CMDEX_int_protected_STEP_1;
+ assign cond_67 = rd_cmd == `CMD_AAM || rd_cmd == `CMD_AAD;
+ assign cond_68 = rd_mutex_busy_eax;
+ assign cond_69 = rd_cmd == `CMD_load_seg && rd_cmdex == `CMDEX_load_seg_STEP_1;
+ assign cond_70 = v8086_mode;
+ assign cond_71 = real_mode;
+ assign cond_72 = protected_mode;
+ assign cond_73 = rd_cmd == `CMD_load_seg && rd_cmdex == `CMDEX_load_seg_STEP_2;
+ assign cond_74 = ~(protected_mode && glob_param_1[15:2] == 14'd0);
+ assign cond_75 = rd_cmd == `CMD_POP_seg && rd_cmdex == `CMDEX_POP_seg_STEP_1;
+ assign cond_76 = { rd_cmd[6:2], 2'd0 } == `CMD_BTx;
+ assign cond_77 = rd_mutex_busy_modregrm_rm || (rd_cmdex == `CMDEX_BTx_modregrm && rd_mutex_busy_modregrm_reg);
+ assign cond_78 = rd_mutex_busy_memory || (rd_cmdex == `CMDEX_BTx_modregrm && rd_mutex_busy_modregrm_reg);
+ assign cond_79 = rd_cmd == `CMD_IRET && rd_cmdex <= `CMDEX_IRET_real_v86_STEP_2;
+ assign cond_80 = rd_cmdex >`CMDEX_IRET_real_v86_STEP_0;
+ assign cond_81 = rd_cmdex == `CMDEX_IRET_real_v86_STEP_0;
+ assign cond_82 = rd_cmdex == `CMDEX_IRET_real_v86_STEP_1;
+ assign cond_83 = rd_cmdex == `CMDEX_IRET_real_v86_STEP_2;
+ assign cond_84 = rd_mutex_busy_memory || (rd_mutex_busy_eflags && v8086_mode);
+ assign cond_85 = ~(v8086_mode) || iopl == 2'd3;
+ assign cond_86 = rd_cmd == `CMD_IRET && rd_cmdex == `CMDEX_IRET_protected_STEP_0;
+ assign cond_87 = rd_mutex_busy_memory || rd_mutex_busy_eflags;
+ assign cond_88 = rd_cmd == `CMD_IRET && rd_cmdex == `CMDEX_IRET_task_switch_STEP_0;
+ assign cond_89 = rd_cmd == `CMD_IRET && rd_cmdex == `CMDEX_IRET_task_switch_STEP_1;
+ assign cond_90 = ~(rd_descriptor_not_in_limits);
+ assign cond_91 = rd_cmd == `CMD_IRET && rd_cmdex >= `CMDEX_IRET_protected_STEP_1 && rd_cmdex <= `CMDEX_IRET_protected_STEP_3;
+ assign cond_92 = rd_cmdex == `CMDEX_IRET_protected_STEP_1;
+ assign cond_93 = rd_cmdex == `CMDEX_IRET_protected_STEP_2;
+ assign cond_94 = rd_cmdex == `CMDEX_IRET_protected_STEP_3;
+ assign cond_95 = rd_cmd == `CMD_IRET && rd_cmdex >= `CMDEX_IRET_protected_to_v86_STEP_0;
+ assign cond_96 = rd_cmdex == `CMDEX_IRET_protected_to_v86_STEP_0;
+ assign cond_97 = rd_cmd == `CMD_IRET_2 && rd_cmdex == `CMDEX_IRET_2_protected_outer_STEP_0;
+ assign cond_98 = rd_cmd == `CMD_IRET_2 && rd_cmdex >= `CMDEX_IRET_2_protected_outer_STEP_1 && rd_cmdex <= `CMDEX_IRET_2_protected_outer_STEP_3;
+ assign cond_99 = rd_cmdex == `CMDEX_IRET_2_protected_outer_STEP_1;
+ assign cond_100 = rd_cmdex == `CMDEX_IRET_2_protected_outer_STEP_2;
+ assign cond_101 = rd_cmdex == `CMDEX_IRET_2_protected_outer_STEP_3;
+ assign cond_102 = rd_cmd == `CMD_IRET_2 && rd_cmdex >= `CMDEX_IRET_2_protected_outer_STEP_6;
+ assign cond_103 = rd_cmd == `CMD_POP && rd_cmdex == `CMDEX_POP_implicit;
+ assign cond_104 = rd_mutex_busy_memory || rd_mutex_busy_esp;
+ assign cond_105 = rd_cmd == `CMD_POP && rd_cmdex == `CMDEX_POP_modregrm_STEP_0;
+ assign cond_106 = rd_cmd == `CMD_POP && rd_cmdex == `CMDEX_POP_modregrm_STEP_1;
+ assign cond_107 = rd_cmd == `CMD_IDIV || rd_cmd == `CMD_DIV;
+ assign cond_108 = rd_mutex_busy_eax || (rd_decoder[0] && rd_mutex_busy_edx) || rd_mutex_busy_modregrm_rm;
+ assign cond_109 = rd_mutex_busy_eax || (rd_decoder[0] && rd_mutex_busy_edx) || rd_mutex_busy_memory;
+ assign cond_110 = rd_cmd == `CMD_Shift && rd_cmdex != `CMDEX_Shift_implicit;
+ assign cond_111 = rd_cmd == `CMD_Shift && rd_cmdex == `CMDEX_Shift_implicit;
+ assign cond_112 = rd_mutex_busy_modregrm_rm || rd_mutex_busy_ecx;
+ assign cond_113 = rd_mutex_busy_memory || rd_mutex_busy_ecx;
+ assign cond_114 = rd_cmd == `CMD_CMPS && rd_cmdex == `CMDEX_CMPS_FIRST;
+ assign cond_115 = rd_cmd == `CMD_CMPS && rd_cmdex == `CMDEX_CMPS_LAST;
+ assign cond_116 = rd_cmd == `CMD_control_reg && rd_cmdex == `CMDEX_control_reg_SMSW_STEP_0;
+ assign cond_117 = rd_cmd == `CMD_control_reg && rd_cmdex == `CMDEX_control_reg_LMSW_STEP_0;
+ assign cond_118 = cpl == 2'd0;
+ assign cond_119 = rd_cmd == `CMD_control_reg && rd_cmdex == `CMDEX_control_reg_MOV_load_STEP_0;
+ assign cond_120 = rd_cmd == `CMD_control_reg && rd_cmdex == `CMDEX_control_reg_MOV_store_STEP_0;
+ assign cond_121 = (rd_cmd == `CMD_LGDT || rd_cmd == `CMD_LIDT) && (rd_cmdex == `CMDEX_LGDT_LIDT_STEP_1 || rd_cmdex == `CMDEX_LGDT_LIDT_STEP_2);
+ assign cond_122 = rd_cmdex == `CMDEX_LGDT_LIDT_STEP_1;
+ assign cond_123 = rd_cmdex == `CMDEX_LGDT_LIDT_STEP_2;
+ assign cond_124 = rd_cmd == `CMD_PUSHA;
+ assign cond_125 = (rd_cmdex == `CMDEX_PUSHA_STEP_0 && rd_mutex_busy_eax) || (rd_cmdex == `CMDEX_PUSHA_STEP_1 && rd_mutex_busy_ecx) || (rd_cmdex == `CMDEX_PUSHA_STEP_2 && rd_mutex_busy_edx);
+ assign cond_126 = rd_cmd == `CMD_SETcc;
+ assign cond_127 = rd_cmd == `CMD_CMPXCHG;
+ assign cond_128 = rd_cmd == `CMD_ENTER && rd_cmdex == `CMDEX_ENTER_FIRST;
+ assign cond_129 = rd_mutex_busy_ebp;
+ assign cond_130 = rd_cmd == `CMD_ENTER && rd_cmdex == `CMDEX_ENTER_LAST;
+ assign cond_131 = rd_cmd == `CMD_ENTER && rd_cmdex == `CMDEX_ENTER_PUSH;
+ assign cond_132 = rd_cmd == `CMD_ENTER && rd_cmdex == `CMDEX_ENTER_LOOP;
+ assign cond_133 = rd_cmd == `CMD_IMUL && rd_cmdex == `CMDEX_IMUL_modregrm_imm;
+ assign cond_134 = rd_decoder[1:0] == 2'b11;
+ assign cond_135 = rd_cmd == `CMD_IMUL && rd_cmdex == `CMDEX_IMUL_modregrm;
+ assign cond_136 = rd_imul_modregrm_mutex_busy || rd_mutex_busy_modregrm_rm;
+ assign cond_137 = rd_imul_modregrm_mutex_busy || rd_mutex_busy_memory;
+ assign cond_138 = rd_cmd == `CMD_LEAVE;
+ assign cond_139 = { rd_cmd[6:1], 1'd0 } == `CMD_SHxD && rd_cmdex != `CMDEX_SHxD_implicit;
+ assign cond_140 = { rd_cmd[6:1], 1'd0 } == `CMD_SHxD && rd_cmdex == `CMDEX_SHxD_implicit;
+ assign cond_141 = rd_mutex_busy_modregrm_rm || rd_mutex_busy_ecx || rd_mutex_busy_modregrm_reg;
+ assign cond_142 = rd_mutex_busy_memory || rd_mutex_busy_ecx || rd_mutex_busy_modregrm_reg;
+ assign cond_143 = { rd_cmd[6:3], 3'd0 } == `CMD_Arith && rd_cmdex == `CMDEX_Arith_modregrm;
+ assign cond_144 = rd_decoder[5:3] != 3'b111;
+ assign cond_145 = rd_decoder[5:3] != 3'b111 && rd_arith_modregrm_to_rm;
+ assign cond_146 = rd_decoder[5:3] != 3'b111 && rd_arith_modregrm_to_reg;
+ assign cond_147 = { rd_cmd[6:3], 3'd0 } == `CMD_Arith && rd_cmdex == `CMDEX_Arith_modregrm_imm;
+ assign cond_148 = rd_decoder[13:11] != 3'b111;
+ assign cond_149 = { rd_cmd[6:3], 3'd0 } == `CMD_Arith && rd_cmdex == `CMDEX_Arith_immediate;
+ assign cond_150 = rd_cmd == `CMD_MUL;
+ assign cond_151 = rd_mutex_busy_eax || rd_mutex_busy_modregrm_rm;
+ assign cond_152 = rd_mutex_busy_eax || rd_mutex_busy_memory;
+ assign cond_153 = rd_cmd == `CMD_LOOP;
+ assign cond_154 = rd_cmd == `CMD_TEST && rd_cmdex == `CMDEX_TEST_modregrm;
+ assign cond_155 = rd_cmd == `CMD_TEST && rd_cmdex == `CMDEX_TEST_modregrm_imm;
+ assign cond_156 = rd_cmd == `CMD_TEST && rd_cmdex == `CMDEX_TEST_immediate;
+ assign cond_157 = rd_cmd == `CMD_RET_far && rd_cmdex == `CMDEX_RET_far_outer_STEP_3;
+ assign cond_158 = rd_cmd == `CMD_RET_far && rd_cmdex == `CMDEX_RET_far_STEP_1;
+ assign cond_159 = real_mode || v8086_mode;
+ assign cond_160 = rd_cmd == `CMD_RET_far && rd_cmdex == `CMDEX_RET_far_STEP_2;
+ assign cond_161 = rd_cmd == `CMD_RET_far && rd_cmdex == `CMDEX_RET_far_outer_STEP_4;
+ assign cond_162 = rd_cmd == `CMD_LODS;
+ assign cond_163 = rd_cmd == `CMD_XCHG && rd_cmdex == `CMDEX_XCHG_implicit;
+ assign cond_164 = rd_mutex_busy_implicit_reg || rd_mutex_busy_eax;
+ assign cond_165 = rd_cmd == `CMD_XCHG && rd_cmdex == `CMDEX_XCHG_modregrm;
+ assign cond_166 = rd_cmd == `CMD_XCHG && rd_cmdex == `CMDEX_XCHG_modregrm_LAST;
+ assign cond_167 = rd_cmd == `CMD_PUSH && (rd_cmdex == `CMDEX_PUSH_immediate || rd_cmdex == `CMDEX_PUSH_immediate_se);
+ assign cond_168 = rd_cmd == `CMD_PUSH && rd_cmdex == `CMDEX_PUSH_implicit;
+ assign cond_169 = rd_cmd == `CMD_PUSH && rd_cmdex == `CMDEX_PUSH_modregrm;
+ assign cond_170 = rd_cmd == `CMD_INT_INTO && rd_cmdex == `CMDEX_INT_INTO_INTO_STEP_0;
+ assign cond_171 = rd_mutex_busy_eflags;
+ assign cond_172 = rd_cmd == `CMD_CPUID;
+ assign cond_173 = rd_cmd == `CMD_IN && rd_cmdex != `CMDEX_IN_idle;
+ assign cond_174 = rd_in_condition;
+ assign cond_175 = ~(io_allow_check_needed) || rd_cmdex == `CMDEX_IN_protected;
+ assign cond_176 = ~(rd_io_ready);
+ assign cond_177 = rd_cmd == `CMD_NOT;
+ assign cond_178 = (rd_cmd == `CMD_LAR || rd_cmd == `CMD_LSL || rd_cmd == `CMD_VERR || rd_cmd == `CMD_VERW) && rd_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_1;
+ assign cond_179 = (rd_cmd == `CMD_LAR || rd_cmd == `CMD_LSL || rd_cmd == `CMD_VERR || rd_cmd == `CMD_VERW) && rd_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_2;
+ assign cond_180 = ~(glob_param_1[15:2] == 14'd0) && ~(rd_descriptor_not_in_limits);
+ assign cond_181 = (rd_cmd == `CMD_LAR || rd_cmd == `CMD_LSL) && rd_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_LAST;
+ assign cond_182 = rd_cmd == `CMD_LAR;
+ assign cond_183 = exe_mutex[`MUTEX_ACTIVE_BIT];
+ assign cond_184 = glob_param_2[1:0] == 2'd0 && ((glob_param_2[2] == 1'd0 && rd_cmd == `CMD_LAR) || (glob_param_2[3] == 1'd0 && rd_cmd == `CMD_LSL));
+ assign cond_185 = (rd_cmd == `CMD_VERR || rd_cmd == `CMD_VERW) && rd_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_LAST;
+ assign cond_186 = glob_param_2[1:0] == 2'd0 && ((glob_param_2[4] == 1'd0 && rd_cmd == `CMD_VERR) || (glob_param_2[5] == 1'd0 && rd_cmd == `CMD_VERW));
+ assign cond_187 =  (rd_cmd == `CMD_int_2  && rd_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_0) || (rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_0) ;
+ assign cond_188 = rd_ss_esp_from_tss_fault;
+ assign cond_189 =  (rd_cmd == `CMD_int_2 && rd_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_1) || (rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_1) ;
+ assign cond_190 =  (rd_cmd == `CMD_int_2 && rd_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_2) || (rd_cmd == `CMD_CALL_2 && rd_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_2) ;
+ assign cond_191 = rd_cmd == `CMD_STOS;
+ assign cond_192 = rd_mutex_busy_eax || (rd_mutex_busy_ecx && rd_prefix_group_1_rep != 2'd0);
+ assign cond_193 = rd_cmd == `CMD_INS && (rd_cmdex == `CMDEX_INS_real_1 || rd_cmdex == `CMDEX_INS_protected_1);
+ assign cond_194 = rd_mutex_busy_ecx && rd_prefix_group_1_rep != 2'd0;
+ assign cond_195 = ~(rd_string_ignore) && ~(io_allow_check_needed && rd_cmdex == `CMDEX_INS_real_1);
+ assign cond_196 = rd_cmd == `CMD_INS && (rd_cmdex == `CMDEX_INS_real_2 || rd_cmdex == `CMDEX_INS_protected_2);
+ assign cond_197 = rd_mutex_busy_edx || (rd_mutex_busy_ecx && rd_prefix_group_1_rep != 2'd0);
+ assign cond_198 = rd_cmd == `CMD_OUTS;
+ assign cond_199 = ~(rd_string_ignore) && ~(io_allow_check_needed && rd_cmdex == `CMDEX_OUTS_first);
+ assign cond_200 = rd_cmd == `CMD_PUSHF;
+ assign cond_201 = rd_cmd == `CMD_JMP && rd_cmdex == `CMDEX_JMP_Jv_STEP_0;
+ assign cond_202 = rd_cmd == `CMD_JMP  && rd_cmdex == `CMDEX_JMP_Ap_STEP_1;
+ assign cond_203 = rd_cmd == `CMD_JMP_2 && rd_cmdex == `CMDEX_JMP_2_call_gate_STEP_0;
+ assign cond_204 = rd_cmd == `CMD_JMP_2 && rd_cmdex == `CMDEX_JMP_2_call_gate_STEP_1;
+ assign cond_205 = rd_cmd == `CMD_JMP  && rd_cmdex == `CMDEX_JMP_Ev_STEP_0;
+ assign cond_206 = rd_cmd == `CMD_JMP  && (rd_cmdex == `CMDEX_JMP_Ep_STEP_0  || rd_cmdex == `CMDEX_JMP_Ep_STEP_1);
+ assign cond_207 = rd_cmdex == `CMDEX_JMP_Ep_STEP_1;
+ assign cond_208 = rd_cmd == `CMD_JMP  && rd_cmdex == `CMDEX_JMP_Ap_STEP_0;
+ assign cond_209 = rd_cmd == `CMD_JMP && rd_cmdex == `CMDEX_JMP_protected_STEP_0;
+ assign cond_210 = rd_cmd == `CMD_JMP && rd_cmdex == `CMDEX_JMP_task_gate_STEP_0;
+ assign cond_211 = rd_cmd == `CMD_JMP && rd_cmdex == `CMDEX_JMP_task_gate_STEP_1;
+ assign cond_212 = rd_cmd == `CMD_OUT;
+ assign cond_213 = rd_cmd == `CMD_MOV && rd_cmdex == `CMDEX_MOV_memoffset;
+ assign cond_214 = ~(rd_decoder[1]);
+ assign cond_215 = rd_mutex_busy_eax || ~(write_virtual_check_ready);
+ assign cond_216 = rd_cmd == `CMD_MOV && rd_cmdex == `CMDEX_MOV_modregrm && rd_decoder[1];
+ assign cond_217 = rd_cmd == `CMD_MOV && rd_cmdex == `CMDEX_MOV_modregrm && ~(rd_decoder[1]);
+ assign cond_218 = rd_mutex_busy_modregrm_reg;
+ assign cond_219 = rd_cmd == `CMD_MOV && rd_cmdex == `CMDEX_MOV_modregrm_imm;
+ assign cond_220 = rd_cmd == `CMD_MOV && rd_cmdex == `CMDEX_MOV_immediate;
+ assign cond_221 = rd_cmd == `CMD_LAHF || rd_cmd == `CMD_CBW || rd_cmd == `CMD_CWD;
+ assign cond_222 = rd_cmd == `CMD_POPF && rd_cmdex == `CMDEX_POPF_STEP_0;
+ assign cond_223 = rd_cmd == `CMD_CLI || rd_cmd == `CMD_STI;
+ assign cond_224 = rd_cmd == `CMD_BOUND && rd_cmdex == `CMDEX_BOUND_STEP_FIRST;
+ assign cond_225 = rd_cmd == `CMD_BOUND && rd_cmdex == `CMDEX_BOUND_STEP_LAST;
+ assign cond_226 = rd_cmd == `CMD_SALC && rd_cmdex == `CMDEX_SALC_STEP_0;
+ assign cond_227 = rd_cmd == `CMD_task_switch && rd_cmdex == `CMDEX_task_switch_STEP_6;
+ assign cond_228 = glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_JUMP || glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_IRET;
+ assign cond_229 = rd_cmd == `CMD_task_switch && rd_cmdex == `CMDEX_task_switch_STEP_9;
+ assign cond_230 = rd_cmd == `CMD_task_switch_2 && rd_cmdex <= `CMDEX_task_switch_2_STEP_7;
+ assign cond_231 = rd_cmd == `CMD_task_switch_2 && rd_cmdex == `CMDEX_task_switch_2_STEP_13;
+ assign cond_232 = rd_cmd == `CMD_task_switch && rd_cmdex >= `CMDEX_task_switch_STEP_12 && rd_cmdex <= `CMDEX_task_switch_STEP_14;
+ assign cond_233 = rd_cmdex == `CMDEX_task_switch_STEP_12 && glob_descriptor[`DESC_BITS_TYPE] <= 4'd3;
+ assign cond_234 = rd_cmdex == `CMDEX_task_switch_STEP_12 && glob_descriptor[`DESC_BITS_TYPE] >  4'd3;
+ assign cond_235 = rd_cmdex == `CMDEX_task_switch_STEP_13 || rd_cmdex == `CMDEX_task_switch_STEP_14;
+ assign cond_236 = rd_cmdex != `CMDEX_task_switch_STEP_12 || (glob_descriptor[`DESC_BITS_TYPE] > 4'd3 && cr0_pg);
+ assign cond_237 = rd_cmd == `CMD_task_switch_3;
+ assign cond_238 = rd_cmdex <= `CMDEX_task_switch_3_STEP_12 || glob_descriptor[`DESC_BITS_TYPE] > 4'd3;
+ assign cond_239 = rd_cmd == `CMD_task_switch_4 && rd_cmdex == `CMDEX_task_switch_4_STEP_0;
+ assign cond_240 = glob_param_1[`TASK_SWITCH_SOURCE_BITS] != `TASK_SWITCH_FROM_IRET;
+ assign cond_241 = rd_cmd == `CMD_task_switch_4 && rd_cmdex == `CMDEX_task_switch_4_STEP_2;
+ assign cond_242 = glob_param_1[`SELECTOR_BIT_TI] == 1'b0 && glob_param_1[15:2] != 14'd0 && ~(rd_descriptor_not_in_limits);
+ assign cond_243 = rd_cmd == `CMD_task_switch_4 && rd_cmdex >= `CMDEX_task_switch_4_STEP_3 && rd_cmdex <= `CMDEX_task_switch_4_STEP_8;
+ assign cond_244 = glob_param_1[15:2] != 14'd0 && ~(rd_descriptor_not_in_limits);
+ assign cond_245 = rd_cmd == `CMD_LEA;
+ assign cond_246 = (rd_cmd == `CMD_SGDT || rd_cmd == `CMD_SIDT);
+ assign cond_247 = rd_cmdex == `CMDEX_SGDT_SIDT_STEP_1;
+ assign cond_248 = rd_cmdex == `CMDEX_SGDT_SIDT_STEP_2;
+ assign cond_249 = rd_cmd == `CMD_MOVS;
+ assign cond_250 = rd_cmd == `CMD_MOVSX || rd_cmd == `CMD_MOVZX;
+ assign cond_251 = rd_cmd == `CMD_POPA;
+ assign cond_252 = rd_cmdex[2:0] > 3'd0;
+ assign cond_253 = rd_cmdex[2:0] == 3'd7;
+ assign cond_254 = rd_cmd == `CMD_debug_reg && rd_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0;
+ assign cond_255 = rd_cmd == `CMD_debug_reg && rd_cmdex == `CMDEX_debug_reg_MOV_load_STEP_0;
+ assign cond_256 = rd_cmd == `CMD_XLAT;
+ assign cond_257 = rd_cmd == `CMD_AAA || rd_cmd == `CMD_AAS || rd_cmd == `CMD_DAA || rd_cmd == `CMD_DAS;
+ assign cond_258 = { rd_cmd[6:1], 1'd0 } == `CMD_BSx;
 //======================================================== saves
 //======================================================== always
 //======================================================== sets
diff --git a/rtl/ao486/autogen/tlb.v b/rtl/ao486/autogen/tlb.v
index ce728e9..91d4bd3 100644
--- a/rtl/ao486/autogen/tlb.v
+++ b/rtl/ao486/autogen/tlb.v
@@ -1,76 +1,77 @@
+
 //======================================================== conditions
-wire cond_0 = state == STATE_IDLE;
-wire cond_1 = tlbflushsingle_do;
-wire cond_2 = tlbflushall_do || tlbflushall_do_waiting;
-wire cond_3 = ~(wr_reset) && tlbwrite_do && ~(write_ac) && cr0_am && acflag && tlbwrite_cpl == 2'd3 &&
+ assign cond_0 = state == STATE_IDLE;
+ assign cond_1 = tlbflushsingle_do;
+ assign cond_2 = tlbflushall_do || tlbflushall_do_waiting;
+ assign cond_3 = ~(wr_reset) && tlbwrite_do && ~(write_ac) && cr0_am && acflag && tlbwrite_cpl == 2'd3 &&
              ( (tlbwrite_length_full == 3'd2 && tlbwrite_address[0] != 1'b0) || (tlbwrite_length_full == 3'd4 && tlbwrite_address[1:0] != 2'b00) )
     ;
-wire cond_4 = ~(wr_reset) && tlbwrite_do && ~(write_pf) && ~(write_ac);
-wire cond_5 = ~(exe_reset) && tlbcheck_do && ~(tlbcheck_done) && ~(check_pf);
-wire cond_6 = ~(rd_reset) && tlbread_do && ~(read_ac) && cr0_am && acflag && tlbread_cpl == 2'd3 &&
+ assign cond_4 = ~(wr_reset) && tlbwrite_do && ~(write_pf) && ~(write_ac);
+ assign cond_5 = ~(exe_reset) && tlbcheck_do && ~(tlbcheck_done) && ~(check_pf);
+ assign cond_6 = ~(rd_reset) && tlbread_do && ~(read_ac) && cr0_am && acflag && tlbread_cpl == 2'd3 &&
              ( (tlbread_length_full == 4'd2 && tlbread_address[0] != 1'b0) || (tlbread_length_full == 4'd4 && tlbread_address[1:0] != 2'b00))
     ;
-wire cond_7 = ~(rd_reset) && tlbread_do && ~(read_pf) && ~(read_ac);
-wire cond_8 = ~(pr_reset) && tlbcoderequest_do && ~(code_pf) && ~(tlbcode_do);
-wire cond_9 = state == STATE_WRITE_DOUBLE;
-wire cond_10 = write_double_state == WRITE_DOUBLE_CHECK;
-wire cond_11 = state == STATE_WRITE_WAIT;
-wire cond_12 = dcachewrite_done;
-wire cond_13 = state == STATE_READ_WAIT;
-wire cond_14 = dcacheread_done;
-wire cond_15 = state == STATE_READ_CHECK;
-wire cond_16 = cr0_pg;
-wire cond_17 = ~(cr0_pg) || translate_valid;
-wire cond_18 = cr0_pg && fault;
-wire cond_19 = state == STATE_WRITE_CHECK;
-wire cond_20 = translate_valid && write_double_state != WRITE_DOUBLE_NONE;
-wire cond_21 = state == STATE_CHECK_CHECK;
-wire cond_22 = state == STATE_CODE_CHECK;
-wire cond_23 = pr_reset || pr_reset_waiting;
-wire cond_24 = state == STATE_LOAD_PDE;
-wire cond_25 = dcacheread_data[0] == `FALSE;
-wire cond_26 = current_type == TYPE_CODE && ~(pr_reset) && ~(pr_reset_waiting);
-wire cond_27 = current_type == TYPE_CHECK;
-wire cond_28 = current_type == TYPE_WRITE;
-wire cond_29 = current_type == TYPE_READ;
-wire cond_30 = state == STATE_LOAD_PTE_START;
-wire cond_31 = state == STATE_RETRY;
-wire cond_32 = state == STATE_LOAD_PTE;
-wire cond_33 = dcacheread_data[0] == `FALSE || fault_before_pte;
-wire cond_34 = ((current_type == TYPE_READ && ~(pipeline_after_read_empty)) || (current_type == TYPE_CODE && (~(pipeline_after_prefetch_empty) || pr_reset_waiting))) &&
+ assign cond_7 = ~(rd_reset) && tlbread_do && ~(read_pf) && ~(read_ac);
+ assign cond_8 = ~(pr_reset) && tlbcoderequest_do && ~(code_pf) && ~(tlbcode_do);
+ assign cond_9 = state == STATE_WRITE_DOUBLE;
+ assign cond_10 = write_double_state == WRITE_DOUBLE_CHECK;
+ assign cond_11 = state == STATE_WRITE_WAIT;
+ assign cond_12 = dcachewrite_done;
+ assign cond_13 = state == STATE_READ_WAIT;
+ assign cond_14 = dcacheread_done;
+ assign cond_15 = state == STATE_READ_CHECK;
+ assign cond_16 = cr0_pg;
+ assign cond_17 = ~(cr0_pg) || translate_valid;
+ assign cond_18 = cr0_pg && fault;
+ assign cond_19 = state == STATE_WRITE_CHECK;
+ assign cond_20 = translate_valid && write_double_state != WRITE_DOUBLE_NONE;
+ assign cond_21 = state == STATE_CHECK_CHECK;
+ assign cond_22 = state == STATE_CODE_CHECK;
+ assign cond_23 = pr_reset || pr_reset_waiting;
+ assign cond_24 = state == STATE_LOAD_PDE;
+ assign cond_25 = dcacheread_data[0] == `FALSE;
+ assign cond_26 = current_type == TYPE_CODE && ~(pr_reset) && ~(pr_reset_waiting);
+ assign cond_27 = current_type == TYPE_CHECK;
+ assign cond_28 = current_type == TYPE_WRITE;
+ assign cond_29 = current_type == TYPE_READ;
+ assign cond_30 = state == STATE_LOAD_PTE_START;
+ assign cond_31 = state == STATE_RETRY;
+ assign cond_32 = state == STATE_LOAD_PTE;
+ assign cond_33 = dcacheread_data[0] == `FALSE || fault_before_pte;
+ assign cond_34 = ((current_type == TYPE_READ && ~(pipeline_after_read_empty)) || (current_type == TYPE_CODE && (~(pipeline_after_prefetch_empty) || pr_reset_waiting))) &&
                  (pde[5] == `FALSE || dcacheread_data[5] == `FALSE || (dcacheread_data[6] == `FALSE && rw));
-wire cond_35 = state == STATE_LOAD_PTE_END;
-wire cond_36 = pde[5] == `FALSE;
-wire cond_37 = pte[5] == `FALSE || (pte[6] == `FALSE && rw);
-wire cond_38 = current_type == TYPE_WRITE && write_double_state != WRITE_DOUBLE_NONE;
-wire cond_39 = state == STATE_READ_WAIT_START;
-wire cond_40 = state == STATE_SAVE_PDE;
-wire cond_41 = state == STATE_SAVE_PTE_START;
-wire cond_42 = state == STATE_WRITE_WAIT_START;
-wire cond_43 = state == STATE_SAVE_PTE;
+ assign cond_35 = state == STATE_LOAD_PTE_END;
+ assign cond_36 = pde[5] == `FALSE;
+ assign cond_37 = pte[5] == `FALSE || (pte[6] == `FALSE && rw);
+ assign cond_38 = current_type == TYPE_WRITE && write_double_state != WRITE_DOUBLE_NONE;
+ assign cond_39 = state == STATE_READ_WAIT_START;
+ assign cond_40 = state == STATE_SAVE_PDE;
+ assign cond_41 = state == STATE_SAVE_PTE_START;
+ assign cond_42 = state == STATE_WRITE_WAIT_START;
+ assign cond_43 = state == STATE_SAVE_PTE;
 //======================================================== saves
-wire [1:0] current_type_to_reg =
+ assign current_type_to_reg =
     (cond_15 && ~cond_17)? (   TYPE_READ) :
     (cond_19 && ~cond_17)? (   TYPE_WRITE) :
     (cond_21 && ~cond_17)? (   TYPE_CHECK) :
     (cond_22 && ~cond_23 && ~cond_17)? (   TYPE_CODE) :
     current_type;
-wire  read_pf_to_reg =
+ assign read_pf_to_reg =
     (cond_0)? (       `FALSE) :
     (cond_15 && cond_17 && cond_18)? (            `TRUE) :
     (cond_24 && cond_14 && cond_25 && ~cond_26 && ~cond_27 && ~cond_28 && cond_29)? (                `TRUE) :
     (cond_32 && cond_14 && cond_33 && ~cond_26 && ~cond_27 && ~cond_28 && cond_29)? (            `TRUE) :
     read_pf;
-wire [31:0] pde_to_reg =
+ assign pde_to_reg =
     (cond_24 && cond_14)? ( dcacheread_data[31:0]) :
     pde;
-wire  write_pf_to_reg =
+ assign write_pf_to_reg =
     (cond_0)? (      `FALSE) :
     (cond_19 && cond_17 && cond_18)? (                `TRUE) :
     (cond_24 && cond_14 && cond_25 && ~cond_26 && ~cond_27 && cond_28)? (               `TRUE) :
     (cond_32 && cond_14 && cond_33 && ~cond_26 && ~cond_27 && cond_28)? (               `TRUE) :
     write_pf;
-wire [4:0] state_to_reg =
+ assign state_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && cond_4)? (  STATE_WRITE_CHECK) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && cond_5)? (  STATE_CHECK_CHECK) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && ~cond_5 && ~cond_6 && cond_7)? (  STATE_READ_CHECK) :
@@ -116,44 +117,44 @@ wire [4:0] state_to_reg =
     (cond_43 && cond_12 && ~cond_28 && cond_29)? ( STATE_READ_WAIT) :
     (cond_43 && cond_12 && ~cond_28 && ~cond_29)? ( STATE_IDLE) :
     state;
-wire [31:0] tlb_read_pf_cr2_to_reg =
+ assign tlb_read_pf_cr2_to_reg =
     (cond_15 && cond_17 && cond_18)? (        linear) :
     (cond_24 && cond_14 && cond_25 && ~cond_26 && ~cond_27 && ~cond_28 && cond_29)? (        linear) :
     (cond_32 && cond_14 && cond_33 && ~cond_26 && ~cond_27 && ~cond_28 && cond_29)? (        linear) :
     tlb_read_pf_cr2;
-wire [31:0] tlb_code_pf_cr2_to_reg =
+ assign tlb_code_pf_cr2_to_reg =
     (cond_22 && ~cond_23 && cond_17 && cond_18)? (       linear) :
     (cond_24 && cond_14 && cond_25 && cond_26)? (        linear) :
     (cond_32 && cond_14 && cond_33 && cond_26)? (        linear) :
     tlb_code_pf_cr2;
-wire  check_pf_to_reg =
+ assign check_pf_to_reg =
     (cond_21 && cond_17 && cond_18)? (               `TRUE) :
     (cond_24 && cond_14 && cond_25 && ~cond_26 && cond_27)? (               `TRUE) :
     (cond_32 && cond_14 && cond_33 && ~cond_26 && cond_27)? (               `TRUE) :
     check_pf;
-wire  su_to_reg =
+ assign su_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && cond_4)? (             tlbwrite_cpl == 2'd3) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && cond_5)? (             `FALSE) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && ~cond_5 && ~cond_6 && cond_7)? (             tlbread_cpl == 2'd3) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && ~cond_5 && ~cond_6 && ~cond_7 && cond_8)? (             tlbcoderequest_su) :
     su;
-wire [15:0] tlb_check_pf_error_code_to_reg =
+ assign tlb_check_pf_error_code_to_reg =
     (cond_21 && cond_17 && cond_18)? ({ 13'd0, su, rw, `TRUE }) :
     (cond_24 && cond_14 && cond_25 && ~cond_26 && cond_27)? ({ 13'd0, su, rw, `FALSE }) :
     (cond_32 && cond_14 && cond_33 && ~cond_26 && cond_27)? ({ 13'd0, su, rw, dcacheread_data[0] }) :
     tlb_check_pf_error_code;
-wire [15:0] tlb_write_pf_error_code_to_reg =
+ assign tlb_write_pf_error_code_to_reg =
     (cond_19 && cond_17 && cond_18)? ( { 13'd0, su, rw, `TRUE }) :
     (cond_24 && cond_14 && cond_25 && ~cond_26 && ~cond_27 && cond_28)? ({ 13'd0, su, rw, `FALSE }) :
     (cond_32 && cond_14 && cond_33 && ~cond_26 && ~cond_27 && cond_28)? ({ 13'd0, su, rw, dcacheread_data[0] }) :
     tlb_write_pf_error_code;
-wire [31:0] write_double_linear_to_reg =
+ assign write_double_linear_to_reg =
     (cond_9 && cond_10)? ( linear) :
     write_double_linear;
-wire  tlbcode_cache_disable_to_reg =
+ assign tlbcode_cache_disable_to_reg =
     (cond_22 && ~cond_23 && cond_17 && ~cond_18)? (   cr0_cd || translate_pcd || memtype_cache_disable) :
     tlbcode_cache_disable;
-wire [31:0] linear_to_reg =
+ assign linear_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && cond_4)? ( tlbwrite_address) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && cond_5)? ( tlbcheck_address) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && ~cond_5 && ~cond_6 && cond_7)? ( tlbread_address) :
@@ -161,47 +162,47 @@ wire [31:0] linear_to_reg =
     (cond_9 && cond_10)? ( { linear[31:12], 12'd0 } + 32'h00001000) :
     (cond_9 && ~cond_10)? ( write_double_linear) :
     linear;
-wire [15:0] tlb_code_pf_error_code_to_reg =
+ assign tlb_code_pf_error_code_to_reg =
     (cond_22 && ~cond_23 && cond_17 && cond_18)? ({ 13'd0, su, rw, `TRUE }) :
     (cond_24 && cond_14 && cond_25 && cond_26)? ( { 13'd0, su, rw, `FALSE }) :
     (cond_32 && cond_14 && cond_33 && cond_26)? ( { 13'd0, su, rw, dcacheread_data[0] }) :
     tlb_code_pf_error_code;
-wire  tlbcode_do_to_reg =
+ assign tlbcode_do_to_reg =
     (cond_0)? (    `FALSE) :
     (cond_22 && ~cond_23 && cond_17 && ~cond_18)? ( `TRUE) :
     tlbcode_do;
-wire  wp_to_reg =
+ assign wp_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && cond_4)? (             cr0_wp) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && cond_5)? (             cr0_wp) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && ~cond_5 && ~cond_6 && cond_7)? (             cr0_wp) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && ~cond_5 && ~cond_6 && ~cond_7 && cond_8)? (             cr0_wp) :
     wp;
-wire  tlbcheck_done_to_reg =
+ assign tlbcheck_done_to_reg =
     (cond_0)? ( `FALSE) :
     (cond_21 && cond_17 && ~cond_18)? ( `TRUE) :
     tlbcheck_done;
-wire [31:0] tlb_write_pf_cr2_to_reg =
+ assign tlb_write_pf_cr2_to_reg =
     (cond_19 && cond_17 && cond_18)? (        linear) :
     (cond_24 && cond_14 && cond_25 && ~cond_26 && ~cond_27 && cond_28)? (       linear) :
     (cond_32 && cond_14 && cond_33 && ~cond_26 && ~cond_27 && cond_28)? (       linear) :
     tlb_write_pf_cr2;
-wire  read_ac_to_reg =
+ assign read_ac_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && ~cond_5 && cond_6)? ( `TRUE) :
     read_ac;
-wire [31:0] pte_to_reg =
+ assign pte_to_reg =
     (cond_32 && cond_14)? ( dcacheread_data[31:0]) :
     pte;
-wire [31:0] tlb_check_pf_cr2_to_reg =
+ assign tlb_check_pf_cr2_to_reg =
     (cond_21 && cond_17 && cond_18)? (       linear) :
     (cond_24 && cond_14 && cond_25 && ~cond_26 && cond_27)? (       linear) :
     (cond_32 && cond_14 && cond_33 && ~cond_26 && cond_27)? (       linear) :
     tlb_check_pf_cr2;
-wire [15:0] tlb_read_pf_error_code_to_reg =
+ assign tlb_read_pf_error_code_to_reg =
     (cond_15 && cond_17 && cond_18)? ( { 13'd0, su, rw, `TRUE }) :
     (cond_24 && cond_14 && cond_25 && ~cond_26 && ~cond_27 && ~cond_28 && cond_29)? ( { 13'd0, su, rw, `FALSE }) :
     (cond_32 && cond_14 && cond_33 && ~cond_26 && ~cond_27 && ~cond_28 && cond_29)? ( { 13'd0, su, rw, dcacheread_data[0] }) :
     tlb_read_pf_error_code;
-wire [1:0] write_double_state_to_reg =
+ assign write_double_state_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && cond_4)? ( (cr0_pg && tlbwrite_length != tlbwrite_length_full && { 1'b0, tlbwrite_address[11:0] } + { 10'd0, tlbwrite_length_full } >= 13'h1000)? WRITE_DOUBLE_CHECK : WRITE_DOUBLE_NONE) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && cond_5)? ( WRITE_DOUBLE_NONE) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && ~cond_5 && ~cond_6 && cond_7)? ( WRITE_DOUBLE_NONE) :
@@ -209,110 +210,110 @@ wire [1:0] write_double_state_to_reg =
     (cond_9 && cond_10)? ( WRITE_DOUBLE_RESTART) :
     (cond_9 && ~cond_10)? ( WRITE_DOUBLE_NONE) :
     write_double_state;
-wire  write_ac_to_reg =
+ assign write_ac_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && cond_3)? ( `TRUE) :
     write_ac;
-wire [31:0] tlbcode_physical_to_reg =
+ assign tlbcode_physical_to_reg =
     (cond_22 && ~cond_23 && cond_17 && ~cond_18)? (        memtype_physical) :
     tlbcode_physical;
-wire  rw_to_reg =
+ assign rw_to_reg =
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && cond_4)? (             `TRUE) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && cond_5)? (             tlbcheck_rw) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && ~cond_5 && ~cond_6 && cond_7)? (             tlbread_rmw) :
     (cond_0 && ~cond_1 && ~cond_2 && ~cond_3 && ~cond_4 && ~cond_5 && ~cond_6 && ~cond_7 && cond_8)? (             `FALSE) :
     rw;
-wire  code_pf_to_reg =
+ assign code_pf_to_reg =
     (cond_22 && ~cond_23 && cond_17 && cond_18)? (                `TRUE) :
     (cond_24 && cond_14 && cond_25 && cond_26)? (                `TRUE) :
     (cond_32 && cond_14 && cond_33 && cond_26)? (                `TRUE) :
     code_pf;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) current_type <= 2'd0;
+always @(posedge clk) begin
+    if(rst) current_type <= 2'd0;
     else              current_type <= current_type_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) pde <= 32'd0;
+always @(posedge clk) begin
+    if(rst) pde <= 32'd0;
     else              pde <= pde_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) state <= 5'd0;
+always @(posedge clk) begin
+    if(rst) state <= 5'd0;
     else              state <= state_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlb_read_pf_cr2 <= 32'd0;
+always @(posedge clk) begin
+    if(rst) tlb_read_pf_cr2 <= 32'd0;
     else              tlb_read_pf_cr2 <= tlb_read_pf_cr2_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlb_code_pf_cr2 <= 32'd0;
+always @(posedge clk) begin
+    if(rst) tlb_code_pf_cr2 <= 32'd0;
     else              tlb_code_pf_cr2 <= tlb_code_pf_cr2_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) su <= 1'd0;
+always @(posedge clk) begin
+    if(rst) su <= 1'd0;
     else              su <= su_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlb_check_pf_error_code <= 16'd0;
+always @(posedge clk) begin
+    if(rst) tlb_check_pf_error_code <= 16'd0;
     else              tlb_check_pf_error_code <= tlb_check_pf_error_code_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlb_write_pf_error_code <= 16'd0;
+always @(posedge clk) begin
+    if(rst) tlb_write_pf_error_code <= 16'd0;
     else              tlb_write_pf_error_code <= tlb_write_pf_error_code_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) write_double_linear <= 32'd0;
+always @(posedge clk) begin
+    if(rst) write_double_linear <= 32'd0;
     else              write_double_linear <= write_double_linear_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlbcode_cache_disable <= 1'd0;
+always @(posedge clk) begin
+    if(rst) tlbcode_cache_disable <= 1'd0;
     else              tlbcode_cache_disable <= tlbcode_cache_disable_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) linear <= 32'd0;
+always @(posedge clk) begin
+    if(rst) linear <= 32'd0;
     else              linear <= linear_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlb_code_pf_error_code <= 16'd0;
+always @(posedge clk) begin
+    if(rst) tlb_code_pf_error_code <= 16'd0;
     else              tlb_code_pf_error_code <= tlb_code_pf_error_code_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlbcode_do <= 1'd0;
+always @(posedge clk) begin
+    if(rst) tlbcode_do <= 1'd0;
     else              tlbcode_do <= tlbcode_do_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) wp <= 1'd0;
+always @(posedge clk) begin
+    if(rst) wp <= 1'd0;
     else              wp <= wp_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlbcheck_done <= 1'd0;
+always @(posedge clk) begin
+    if(rst) tlbcheck_done <= 1'd0;
     else              tlbcheck_done <= tlbcheck_done_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlb_write_pf_cr2 <= 32'd0;
+always @(posedge clk) begin
+    if(rst) tlb_write_pf_cr2 <= 32'd0;
     else              tlb_write_pf_cr2 <= tlb_write_pf_cr2_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) pte <= 32'd0;
+always @(posedge clk) begin
+    if(rst) pte <= 32'd0;
     else              pte <= pte_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlb_check_pf_cr2 <= 32'd0;
+always @(posedge clk) begin
+    if(rst) tlb_check_pf_cr2 <= 32'd0;
     else              tlb_check_pf_cr2 <= tlb_check_pf_cr2_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlb_read_pf_error_code <= 16'd0;
+always @(posedge clk) begin
+    if(rst) tlb_read_pf_error_code <= 16'd0;
     else              tlb_read_pf_error_code <= tlb_read_pf_error_code_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) write_double_state <= 2'd0;
+always @(posedge clk) begin
+    if(rst) write_double_state <= 2'd0;
     else              write_double_state <= write_double_state_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) tlbcode_physical <= 32'd0;
+always @(posedge clk) begin
+    if(rst) tlbcode_physical <= 32'd0;
     else              tlbcode_physical <= tlbcode_physical_to_reg;
 end
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) rw <= 1'd0;
+always @(posedge clk) begin
+    if(rst) rw <= 1'd0;
     else              rw <= rw_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/autogen/write_commands.v b/rtl/ao486/autogen/write_commands.v
index d56c435..06b2654 100644
--- a/rtl/ao486/autogen/write_commands.v
+++ b/rtl/ao486/autogen/write_commands.v
@@ -1,9 +1,290 @@
+reg  [31:0] wr_task_switch_linear_reg;
 wire [15:0] wr_IRET_to_v86_es;
 wire [15:0] wr_IRET_to_v86_cs;
 wire [15:0] wr_IRET_to_v86_ss;
 wire [15:0] wr_IRET_to_v86_ds;
 wire [15:0] wr_IRET_to_v86_fs;
 wire [15:0] wr_IRET_to_v86_gs;
+wire [31:0] wr_ecx_minus_1;
+wire [31:0] wr_task_switch_linear;
+wire [31:0] wr_task_switch_linear_next;
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire cond_12;
+wire cond_13;
+wire cond_14;
+wire cond_15;
+wire cond_16;
+wire cond_17;
+wire cond_18;
+wire cond_19;
+wire cond_20;
+wire cond_21;
+wire cond_22;
+wire cond_23;
+wire cond_24;
+wire cond_25;
+wire cond_26;
+wire cond_27;
+wire cond_28;
+wire cond_29;
+wire cond_30;
+wire cond_31;
+wire cond_32;
+wire cond_33;
+wire cond_34;
+wire cond_35;
+wire cond_36;
+wire cond_37;
+wire cond_38;
+wire cond_39;
+wire cond_40;
+wire cond_41;
+wire cond_42;
+wire cond_43;
+wire cond_44;
+wire cond_45;
+wire cond_46;
+wire cond_47;
+wire cond_48;
+wire cond_49;
+wire cond_50;
+wire cond_51;
+wire cond_52;
+wire cond_53;
+wire cond_54;
+wire cond_55;
+wire cond_56;
+wire cond_57;
+wire cond_58;
+wire cond_59;
+wire cond_60;
+wire cond_61;
+wire cond_62;
+wire cond_63;
+wire cond_64;
+wire cond_65;
+wire cond_66;
+wire cond_67;
+wire cond_68;
+wire cond_69;
+wire cond_70;
+wire cond_71;
+wire cond_72;
+wire cond_73;
+wire cond_74;
+wire cond_75;
+wire cond_76;
+wire cond_77;
+wire cond_78;
+wire cond_79;
+wire cond_80;
+wire cond_81;
+wire cond_82;
+wire cond_83;
+wire cond_84;
+wire cond_85;
+wire cond_86;
+wire cond_87;
+wire cond_88;
+wire cond_89;
+wire cond_90;
+wire cond_91;
+wire cond_92;
+wire cond_93;
+wire cond_94;
+wire cond_95;
+wire cond_96;
+wire cond_97;
+wire cond_98;
+wire cond_99;
+wire cond_100;
+wire cond_101;
+wire cond_102;
+wire cond_103;
+wire cond_104;
+wire cond_105;
+wire cond_106;
+wire cond_107;
+wire cond_108;
+wire cond_109;
+wire cond_110;
+wire cond_111;
+wire cond_112;
+wire cond_113;
+wire cond_114;
+wire cond_115;
+wire cond_116;
+wire cond_117;
+wire cond_118;
+wire cond_119;
+wire cond_120;
+wire cond_121;
+wire cond_122;
+wire cond_123;
+wire cond_124;
+wire cond_125;
+wire cond_126;
+wire cond_127;
+wire cond_128;
+wire cond_129;
+wire cond_130;
+wire cond_131;
+wire cond_132;
+wire cond_133;
+wire cond_134;
+wire cond_135;
+wire cond_136;
+wire cond_137;
+wire cond_138;
+wire cond_139;
+wire cond_140;
+wire cond_141;
+wire cond_142;
+wire cond_143;
+wire cond_144;
+wire cond_145;
+wire cond_146;
+wire cond_147;
+wire cond_148;
+wire cond_149;
+wire cond_150;
+wire cond_151;
+wire cond_152;
+wire cond_153;
+wire cond_154;
+wire cond_155;
+wire cond_156;
+wire cond_157;
+wire cond_158;
+wire cond_159;
+wire cond_160;
+wire cond_161;
+wire cond_162;
+wire cond_163;
+wire cond_164;
+wire cond_165;
+wire cond_166;
+wire cond_167;
+wire cond_168;
+wire cond_169;
+wire cond_170;
+wire cond_171;
+wire cond_172;
+wire cond_173;
+wire cond_174;
+wire cond_175;
+wire cond_176;
+wire cond_177;
+wire cond_178;
+wire cond_179;
+wire cond_180;
+wire cond_181;
+wire cond_182;
+wire cond_183;
+wire cond_184;
+wire cond_185;
+wire cond_186;
+wire cond_187;
+wire cond_188;
+wire cond_189;
+wire cond_190;
+wire cond_191;
+wire cond_192;
+wire cond_193;
+wire cond_194;
+wire cond_195;
+wire cond_196;
+wire cond_197;
+wire cond_198;
+wire cond_199;
+wire cond_200;
+wire cond_201;
+wire cond_202;
+wire cond_203;
+wire cond_204;
+wire cond_205;
+wire cond_206;
+wire cond_207;
+wire cond_208;
+wire cond_209;
+wire cond_210;
+wire cond_211;
+wire cond_212;
+wire cond_213;
+wire cond_214;
+wire cond_215;
+wire cond_216;
+wire cond_217;
+wire cond_218;
+wire cond_219;
+wire cond_220;
+wire cond_221;
+wire cond_222;
+wire cond_223;
+wire cond_224;
+wire cond_225;
+wire cond_226;
+wire cond_227;
+wire cond_228;
+wire cond_229;
+wire cond_230;
+wire cond_231;
+wire cond_232;
+wire cond_233;
+wire cond_234;
+wire cond_235;
+wire cond_236;
+wire cond_237;
+wire cond_238;
+wire cond_239;
+wire cond_240;
+wire cond_241;
+wire cond_242;
+wire cond_243;
+wire cond_244;
+wire cond_245;
+wire cond_246;
+wire cond_247;
+wire cond_248;
+wire cond_249;
+wire cond_250;
+wire cond_251;
+wire cond_252;
+wire cond_253;
+wire cond_254;
+wire cond_255;
+wire cond_256;
+wire cond_257;
+wire cond_258;
+wire cond_259;
+wire cond_260;
+wire cond_261;
+wire cond_262;
+wire cond_263;
+wire cond_264;
+wire cond_265;
+wire cond_266;
+wire cond_267;
+wire cond_268;
+wire cond_269;
+wire cond_270;
+wire cond_271;
+wire cond_272;
+wire cond_273;
+wire cond_274;
+wire [1:0] wr_task_rpl_to_reg ;
+
 assign wr_IRET_to_v86_es = exe_buffer_shifted[79:64];
 assign wr_IRET_to_v86_cs = glob_param_1[15:0];
 assign wr_IRET_to_v86_ss = exe_buffer_shifted[111:96];
@@ -11,293 +292,289 @@ assign wr_IRET_to_v86_ds = exe_buffer_shifted[47:32];
 assign wr_IRET_to_v86_fs = exe_buffer_shifted[15:0];
 assign wr_IRET_to_v86_gs = exe_buffer[15:0];
 
-wire [31:0] wr_ecx_minus_1;
 assign wr_ecx_minus_1 = ecx - 32'd1;
 
-wire [31:0] wr_task_switch_linear;
-wire [31:0] wr_task_switch_linear_next;
-reg  [31:0] wr_task_switch_linear_reg;
 assign wr_task_switch_linear = (wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_9 && tr_cache[`DESC_BITS_TYPE] <= 4'd3)?     tr_base + 32'd14 : (wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_9 && tr_cache[`DESC_BITS_TYPE] > 4'd3)?      tr_base + 32'h20 : wr_task_switch_linear_next;
 assign wr_task_switch_linear_next = (tr_cache[`DESC_BITS_TYPE] <= 4'd3)?    wr_task_switch_linear_reg + 32'd2 : wr_task_switch_linear_reg + 32'd4;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0)                                                               wr_task_switch_linear_reg <= 32'd0; else if(wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_9)    wr_task_switch_linear_reg <= wr_task_switch_linear; else if(wr_ready)                                                               wr_task_switch_linear_reg <= wr_task_switch_linear_next;
+always @(posedge clk) begin if(rst)                                                               wr_task_switch_linear_reg <= 32'd0; else if(wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_9)    wr_task_switch_linear_reg <= wr_task_switch_linear; else if(wr_ready)                                                               wr_task_switch_linear_reg <= wr_task_switch_linear_next;
 end
 
 //======================================================== conditions
-wire cond_0 = wr_cmd == `CMD_XADD && wr_cmdex == `CMDEX_XADD_FIRST;
-wire cond_1 = wr_dst_is_memory && ~(write_for_wr_ready);
-wire cond_2 = wr_cmd == `CMD_XADD && wr_cmdex == `CMDEX_XADD_LAST;
-wire cond_3 = wr_modregrm_mod != 2'b11 || wr_modregrm_reg != wr_modregrm_rm;
-wire cond_4 = wr_cmd == `CMD_JCXZ;
-wire cond_5 = result_signals[0];
-wire cond_6 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_Ep_STEP_0 || wr_cmdex == `CMDEX_CALL_Ap_STEP_0);
-wire cond_7 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_Ep_STEP_1 || wr_cmdex == `CMDEX_CALL_Ap_STEP_1);
-wire cond_8 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_real_v8086_STEP_0 || wr_cmdex == `CMDEX_CALL_real_v8086_STEP_1);
-wire cond_9 = ~(write_for_wr_ready);
-wire cond_10 = ~(wr_push_ss_fault);
-wire cond_11 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_Ev_STEP_0 || wr_cmdex == `CMDEX_CALL_Jv_STEP_0);
-wire cond_12 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_Ev_Jv_STEP_1 || wr_cmdex == `CMDEX_CALL_real_v8086_STEP_3);
-wire cond_13 = wr_cmd == `CMD_CALL && wr_cmdex == `CMDEX_CALL_real_v8086_STEP_2;
-wire cond_14 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_protected_seg_STEP_0 || wr_cmdex == `CMDEX_CALL_protected_seg_STEP_1);
-wire cond_15 = ~(wr_new_push_ss_fault);
-wire cond_16 = wr_cmd == `CMD_CALL && wr_cmdex == `CMDEX_CALL_protected_seg_STEP_2;
-wire cond_17 = wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_task_switch_STEP_0;
-wire cond_18 = wr_cmd == `CMD_CALL_2 && (wr_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_2 || wr_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_3);
-wire cond_19 = wr_cmd == `CMD_CALL_3 && ( wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_4 || wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_5 || wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_6 || wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_7);
-wire cond_20 = wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_7;
-wire cond_21 = wr_cmd == `CMD_PUSH_MOV_SEG && { wr_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_implicit;
-wire cond_22 = write_for_wr_ready && ~(wr_push_ss_fault);
-wire cond_23 = wr_cmd == `CMD_PUSH_MOV_SEG && { wr_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_modregrm;
-wire cond_24 = wr_cmd == `CMD_NEG;
-wire cond_25 = wr_cmd == `CMD_Jcc;
-wire cond_26 = wr_cmd == `CMD_INVD && wr_cmdex == `CMDEX_INVD_STEP_0;
-wire cond_27 = wr_cmd == `CMD_INVD && wr_cmdex == `CMDEX_INVD_STEP_1;
-wire cond_28 = wr_cmd == `CMD_INVLPG && wr_cmdex == `CMDEX_INVLPG_STEP_0;
-wire cond_29 = wr_cmd == `CMD_INVLPG && wr_cmdex == `CMDEX_INVLPG_STEP_1;
-wire cond_30 = wr_cmd == `CMD_io_allow && (wr_cmdex == `CMDEX_io_allow_1 || wr_cmdex == `CMDEX_io_allow_2);
-wire cond_31 = wr_cmd == `CMD_HLT && wr_cmdex == `CMDEX_HLT_STEP_0;
-wire cond_32 = wr_cmd == `CMD_SCAS;
-wire cond_33 = ~(wr_string_ignore);
-wire cond_34 = wr_prefix_group_1_rep != 2'd0;
-wire cond_35 = wr_string_ignore || wr_string_zf_finish;
-wire cond_36 = ~(wr_string_ignore) && ~(wr_string_zf_finish) && wr_prefix_group_1_rep != 2'd0;
-wire cond_37 = wr_cmd == `CMD_INC_DEC;
-wire cond_38 = wr_cmd == `CMD_RET_near && wr_cmdex != `CMDEX_RET_near_LAST;
-wire cond_39 = wr_cmd == `CMD_ARPL;
-wire cond_40 = wr_cmd == `CMD_BSWAP;
-wire cond_41 = wr_cmd == `CMD_LxS && wr_cmdex != `CMDEX_LxS_STEP_LAST;
-wire cond_42 = wr_cmd == `CMD_LxS && wr_cmdex == `CMDEX_LxS_STEP_LAST;
-wire cond_43 = (wr_cmd == `CMD_MOV_to_seg || wr_cmd == `CMD_LLDT || wr_cmd == `CMD_LTR) && wr_cmdex == `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1;
-wire cond_44 = (wr_cmd == `CMD_MOV_to_seg || wr_cmd == `CMD_LLDT || wr_cmd == `CMD_LTR) && wr_cmdex == `CMDEX_MOV_to_seg_LLDT_LTR_STEP_LAST;
-wire cond_45 = wr_cmd == `CMD_MOV_to_seg && wr_decoder[13:11] == `SEGMENT_SS;
-wire cond_46 = wr_cmd == `CMD_CLC;
-wire cond_47 = wr_cmd == `CMD_CMC;
-wire cond_48 = wr_cmd == `CMD_CLD;
-wire cond_49 = wr_cmd == `CMD_STC;
-wire cond_50 = wr_cmd == `CMD_STD;
-wire cond_51 = wr_cmd == `CMD_SAHF;
-wire cond_52 = wr_cmd == `CMD_int_2  && wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_2;
-wire cond_53 = wr_cmd == `CMD_int_2  && wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_3;
-wire cond_54 = wr_cmd == `CMD_int_2 && ( wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_4 || wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_5 || wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_6 || wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_7 || wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_8 || wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_9);
-wire cond_55 = wr_cmd == `CMD_int_3 && ( wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_0 || wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_1 || wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_2 || wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_3);
-wire cond_56 = (wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_2 && ~(exc_push_error)) || wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_3;
-wire cond_57 = wr_cmd == `CMD_int && wr_cmdex == `CMDEX_int_STEP_0;
-wire cond_58 = wr_cmd == `CMD_int && wr_cmdex == `CMDEX_int_STEP_1;
-wire cond_59 = wr_cmd == `CMD_int && (wr_cmdex == `CMDEX_int_real_STEP_3 || wr_cmdex == `CMDEX_int_real_STEP_4);
-wire cond_60 = wr_cmd == `CMD_int && wr_cmdex == `CMDEX_int_real_STEP_5;
-wire cond_61 = wr_cmd == `CMD_int && (wr_cmdex == `CMDEX_int_protected_STEP_0 || wr_cmdex == `CMDEX_int_protected_STEP_1 || wr_cmdex == `CMDEX_int_protected_STEP_2);
-wire cond_62 = wr_cmd == `CMD_int_2 && wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_5;
-wire cond_63 = wr_cmd == `CMD_int_3 && wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_6;
-wire cond_64 = v8086_mode;
-wire cond_65 = wr_cmd == `CMD_int && (wr_cmdex == `CMDEX_int_real_STEP_0 || wr_cmdex == `CMDEX_int_real_STEP_1 || wr_cmdex == `CMDEX_int_real_STEP_2);
-wire cond_66 = wr_cmd == `CMD_AAM || wr_cmd == `CMD_AAD;
-wire cond_67 = wr_cmd == `CMD_load_seg && wr_cmdex == `CMDEX_load_seg_STEP_1;
-wire cond_68 = real_mode;
-wire cond_69 = protected_mode && glob_param_1[15:2] == 14'd0;
-wire cond_70 = wr_cmd == `CMD_load_seg && wr_cmdex == `CMDEX_load_seg_STEP_2;
-wire cond_71 = ~(protected_mode && (glob_param_1[15:2] == 14'd0 || glob_param_1[`MC_PARAM_1_FLAG_NO_WRITE_BIT]));
-wire cond_72 = glob_param_1[18:16] == `SEGMENT_TR || (glob_param_1[18:16] < `SEGMENT_LDT && `DESC_IS_NOT_ACCESSED(glob_descriptor));
-wire cond_73 = glob_param_1[18:16] == `SEGMENT_TR;
-wire cond_74 = glob_param_1[18:16] == `SEGMENT_LDT || (glob_param_1[18:16] < `SEGMENT_LDT && `DESC_IS_ACCESSED(glob_descriptor));
-wire cond_75 = wr_cmd == `CMD_POP_seg && wr_cmdex == `CMDEX_POP_seg_STEP_1;
-wire cond_76 = wr_cmd == `CMD_POP_seg && wr_cmdex == `CMDEX_POP_seg_STEP_LAST;
-wire cond_77 = wr_decoder[5:3] == `SEGMENT_SS;
-wire cond_78 = { wr_cmd[6:2], 2'd0 } == `CMD_BTx;
-wire cond_79 = wr_cmd[1:0] != 2'd0;
-wire cond_80 = wr_cmd == `CMD_IRET && wr_cmdex <= `CMDEX_IRET_real_v86_STEP_2;
-wire cond_81 = wr_cmdex == `CMDEX_IRET_real_v86_STEP_0;
-wire cond_82 = wr_cmd == `CMD_IRET && wr_cmdex == `CMDEX_IRET_real_v86_STEP_3;
-wire cond_83 = wr_operand_32bit;
-wire cond_84 = wr_cmd == `CMD_IRET && (wr_cmdex == `CMDEX_IRET_protected_STEP_0 || wr_cmdex == `CMDEX_IRET_task_switch_STEP_0 || wr_cmdex == `CMDEX_IRET_task_switch_STEP_1);
-wire cond_85 = wr_cmd == `CMD_IRET && wr_cmdex >= `CMDEX_IRET_protected_STEP_1 && wr_cmdex <= `CMDEX_IRET_protected_STEP_3;
-wire cond_86 = wr_cmd == `CMD_IRET && wr_cmdex >= `CMDEX_IRET_protected_to_v86_STEP_0 && wr_cmdex <= `CMDEX_IRET_protected_to_v86_STEP_4;
-wire cond_87 = wr_cmd == `CMD_IRET && wr_cmdex == `CMDEX_IRET_protected_to_v86_STEP_5;
-wire cond_88 = wr_cmd == `CMD_IRET_2 && wr_cmdex == `CMDEX_IRET_2_protected_to_v86_STEP_6;
-wire cond_89 = wr_cmd == `CMD_IRET_2 && wr_cmdex == `CMDEX_IRET_2_protected_same_STEP_1;
-wire cond_90 = cpl <= iopl;
-wire cond_91 = cpl == 2'd0;
-wire cond_92 = wr_cmd == `CMD_IRET_2 && wr_cmdex >= `CMDEX_IRET_2_protected_outer_STEP_0 && wr_cmdex <= `CMDEX_IRET_2_protected_outer_STEP_2;
-wire cond_93 = wr_cmd == `CMD_IRET_2 && wr_cmdex == `CMDEX_IRET_2_protected_outer_STEP_4;
-wire cond_94 = wr_task_rpl <= iopl;
-wire cond_95 = wr_task_rpl == 2'd0;
-wire cond_96 = wr_cmd == `CMD_POP && wr_cmdex == `CMDEX_POP_implicit;
-wire cond_97 = wr_cmd == `CMD_POP && wr_cmdex == `CMDEX_POP_modregrm_STEP_0;
-wire cond_98 = wr_cmd == `CMD_POP && wr_cmdex == `CMDEX_POP_modregrm_STEP_1;
-wire cond_99 = ~(wr_dst_is_memory) || write_for_wr_ready;
-wire cond_100 = wr_cmd == `CMD_IDIV || wr_cmd == `CMD_DIV;
-wire cond_101 = ~(wr_is_8bit);
-wire cond_102 = wr_cmd == `CMD_Shift;
-wire cond_103 = ~(result_signals[4]);
-wire cond_104 = result_signals[3];
-wire cond_105 = result_signals[2];
-wire cond_106 = wr_cmd == `CMD_CMPS && wr_cmdex == `CMDEX_CMPS_FIRST;
-wire cond_107 = wr_cmd == `CMD_CMPS && wr_cmdex == `CMDEX_CMPS_LAST;
-wire cond_108 = wr_string_ignore || wr_string_zf_finish || wr_prefix_group_1_rep == 2'd0;
-wire cond_109 = wr_cmd == `CMD_control_reg && wr_cmdex == `CMDEX_control_reg_SMSW_STEP_0;
-wire cond_110 = wr_cmd == `CMD_control_reg && wr_cmdex == `CMDEX_control_reg_LMSW_STEP_0;
-wire cond_111 = cr0_pe ^ result2[0];
-wire cond_112 = wr_cmd == `CMD_control_reg && wr_cmdex == `CMDEX_control_reg_MOV_store_STEP_0;
-wire cond_113 = wr_cmd == `CMD_control_reg && wr_cmdex == `CMDEX_control_reg_MOV_load_STEP_0;
-wire cond_114 = wr_decoder[13:11] == 3'd0;
-wire cond_115 = (cr0_pe ^ result2[0]) || (cr0_wp ^ result2[16]) || (cr0_pg ^ result[31]);
-wire cond_116 = cr0_pe && result2[0] == 1'b0;
-wire cond_117 = wr_decoder[13:11] == 3'd2;
-wire cond_118 = wr_decoder[13:11] == 3'd3;
-wire cond_119 = (wr_cmd == `CMD_LGDT || wr_cmd == `CMD_LIDT);
-wire cond_120 = wr_cmdex == `CMDEX_LGDT_LIDT_STEP_1;
-wire cond_121 = wr_cmd == `CMD_LGDT;
-wire cond_122 = wr_cmd == `CMD_LIDT;
-wire cond_123 = wr_cmdex == `CMDEX_LGDT_LIDT_STEP_2;
-wire cond_124 = wr_cmd == `CMD_PUSHA;
-wire cond_125 = wr_cmdex[2:0] == 3'd0;
-wire cond_126 = wr_cmdex[2:0] < 3'd7;
-wire cond_127 = wr_cmdex[2:0] == 3'd7 && write_for_wr_ready && ~(wr_push_ss_fault);
-wire cond_128 = wr_cmd == `CMD_SETcc;
-wire cond_129 = wr_cmd == `CMD_CMPXCHG;
-wire cond_130 = wr_cmd == `CMD_ENTER && wr_cmdex == `CMDEX_ENTER_FIRST;
-wire cond_131 = wr_cmd == `CMD_ENTER && wr_cmdex == `CMDEX_ENTER_LAST;
-wire cond_132 = wr_cmd == `CMD_ENTER && (wr_cmdex == `CMDEX_ENTER_PUSH || wr_cmdex == `CMDEX_ENTER_LOOP);
-wire cond_133 = wr_cmd == `CMD_IMUL;
-wire cond_134 = wr_dst_is_edx_eax;
-wire cond_135 = wr_cmd == `CMD_LEAVE;
-wire cond_136 = { wr_cmd[6:1], 1'd0 } == `CMD_SHxD;
-wire cond_137 = wr_cmd == `CMD_WBINVD && wr_cmdex == `CMDEX_WBINVD_STEP_0;
-wire cond_138 = wr_cmd == `CMD_WBINVD && wr_cmdex == `CMDEX_WBINVD_STEP_1;
-wire cond_139 = { wr_cmd[6:3], 3'd0 } == `CMD_Arith;
-wire cond_140 = wr_cmd[2:0] != 3'b111 && wr_dst_is_memory && ~(write_for_wr_ready);
-wire cond_141 = wr_cmd[2:0] != 3'b111;
-wire cond_142 = wr_cmd == `CMD_MUL;
-wire cond_143 = wr_cmd == `CMD_LOOP;
-wire cond_144 = wr_address_16bit;
-wire cond_145 = wr_cmd == `CMD_TEST;
-wire cond_146 = wr_cmd == `CMD_CLTS;
-wire cond_147 = wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_STEP_1;
-wire cond_148 = wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_STEP_2;
-wire cond_149 = wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_real_STEP_3;
-wire cond_150 = wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_outer_STEP_3;
-wire cond_151 = wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_outer_STEP_4;
-wire cond_152 = wr_cmd == `CMD_LODS;
-wire cond_153 = wr_string_ignore || wr_string_finish;
-wire cond_154 = ~(wr_string_ignore) && ~(wr_string_finish) && wr_prefix_group_1_rep != 2'd0;
-wire cond_155 = wr_cmd == `CMD_XCHG && wr_cmdex == `CMDEX_XCHG_implicit;
-wire cond_156 = wr_cmd == `CMD_XCHG && wr_cmdex == `CMDEX_XCHG_modregrm;
-wire cond_157 = wr_cmd == `CMD_XCHG && wr_cmdex == `CMDEX_XCHG_modregrm_LAST;
-wire cond_158 = wr_cmd == `CMD_PUSH;
-wire cond_159 = wr_cmd == `CMD_INT_INTO && wr_cmdex == `CMDEX_INT_INTO_INT_STEP_0;
-wire cond_160 = wr_cmd == `CMD_INT_INTO && wr_cmdex == `CMDEX_INT_INTO_INT3_STEP_0;
-wire cond_161 = wr_cmd == `CMD_INT_INTO && wr_cmdex == `CMDEX_INT_INTO_INT1_STEP_0;
-wire cond_162 = wr_cmd == `CMD_INT_INTO && wr_cmdex == `CMDEX_INT_INTO_INTO_STEP_0;
-wire cond_163 = oflag;
-wire cond_164 = wr_cmd == `CMD_CPUID;
-wire cond_165 = eax == 32'd0;
-wire cond_166 = eax != 32'd0;
-wire cond_167 = wr_cmd == `CMD_IN;
-wire cond_168 = ~(io_allow_check_needed) || wr_cmdex == `CMDEX_IN_protected;
-wire cond_169 = wr_cmd == `CMD_NOT;
-wire cond_170 = (wr_cmd == `CMD_LAR || wr_cmd == `CMD_LSL || wr_cmd == `CMD_VERR || wr_cmd == `CMD_VERW) && (wr_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_1 || wr_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_2);
-wire cond_171 = (wr_cmd == `CMD_LAR || wr_cmd == `CMD_LSL) && wr_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_LAST;
-wire cond_172 = wr_dst_is_reg;
-wire cond_173 = (wr_cmd == `CMD_VERR || wr_cmd == `CMD_VERW) && wr_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_LAST;
-wire cond_174 = (wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_same_STEP_3) || (wr_cmd == `CMD_IRET_2  && wr_cmdex == `CMDEX_IRET_2_protected_same_STEP_0) || (wr_cmd == `CMD_CALL_2  && wr_cmdex == `CMDEX_CALL_2_protected_seg_STEP_3) || (wr_cmd == `CMD_CALL_2  && wr_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_2) || (wr_cmd == `CMD_JMP     && wr_cmdex == `CMDEX_JMP_protected_seg_STEP_0) || (wr_cmd == `CMD_JMP_2   && wr_cmdex == `CMDEX_JMP_2_call_gate_STEP_2) || (wr_cmd == `CMD_int_2   && wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_4);
-wire cond_175 = `DESC_IS_NOT_ACCESSED(glob_descriptor);
-wire cond_176 = wr_cmd != `CMD_JMP && wr_cmd != `CMD_JMP_2 && wr_cmd != `CMD_int_2;
-wire cond_177 = (wr_cmd == `CMD_CALL_3 && wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_9) || (wr_cmd == `CMD_int_3  && wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_4);
-wire cond_178 = (wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_same_STEP_4) || (wr_cmd == `CMD_CALL_2  && wr_cmdex == `CMDEX_CALL_2_protected_seg_STEP_4) || (wr_cmd == `CMD_CALL_2  && wr_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_3) || (wr_cmd == `CMD_CALL_3  && wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_10) || (wr_cmd == `CMD_JMP     && wr_cmdex == `CMDEX_JMP_protected_seg_STEP_1) || (wr_cmd == `CMD_JMP_2   && wr_cmdex == `CMDEX_JMP_2_call_gate_STEP_3);
-wire cond_179 = (wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_outer_STEP_5) || (wr_cmd == `CMD_IRET_2  && wr_cmdex == `CMDEX_IRET_2_protected_outer_STEP_3);
-wire cond_180 = (wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_outer_STEP_6) || (wr_cmd == `CMD_IRET_2  && wr_cmdex == `CMDEX_IRET_2_protected_outer_STEP_5) || (wr_cmd == `CMD_CALL_3  && wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_8) || (wr_cmd == `CMD_int_3   && wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_5);
-wire cond_181 = `DESC_IS_NOT_ACCESSED(glob_descriptor) && glob_param_1[15:2] != 14'd0;
-wire cond_182 = (wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_outer_STEP_7) ||  + (wr_cmd == `CMD_IRET_2 && wr_cmdex == `CMDEX_IRET_2_protected_outer_STEP_6);
-wire cond_183 = (wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_protected_STEP_0 || wr_cmdex == `CMDEX_CALL_protected_STEP_1)) || (wr_cmd == `CMD_JMP  && (wr_cmdex == `CMDEX_JMP_protected_STEP_0  || wr_cmdex == `CMDEX_JMP_protected_STEP_1));
-wire cond_184 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_task_gate_STEP_0) || (wr_cmd == `CMD_JMP    && wr_cmdex == `CMDEX_JMP_task_gate_STEP_0) || (wr_cmd == `CMD_int    && wr_cmdex == `CMDEX_int_task_gate_STEP_0);
-wire cond_185 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_task_gate_STEP_1) || (wr_cmd == `CMD_JMP    && wr_cmdex == `CMDEX_JMP_task_gate_STEP_1) || (wr_cmd == `CMD_int    && wr_cmdex == `CMDEX_int_task_gate_STEP_1);
-wire cond_186 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_call_gate_STEP_0) || (wr_cmd == `CMD_int    && wr_cmdex == `CMDEX_int_int_trap_gate_STEP_0);
-wire cond_187 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_call_gate_STEP_1) || (wr_cmd == `CMD_int    && wr_cmdex == `CMDEX_int_int_trap_gate_STEP_1);
-wire cond_188 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_call_gate_STEP_2) || (wr_cmd == `CMD_int    && wr_cmdex == `CMDEX_int_int_trap_gate_STEP_2);
-wire cond_189 = (wr_cmd == `CMD_CALL_2 && (wr_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_0 || wr_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_1)) || (wr_cmd == `CMD_int_2 && (wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_0 || wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_1 || wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_2 || wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_3));
-wire cond_190 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_0) || (wr_cmd == `CMD_int_2  && wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_0);
-wire cond_191 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_1) || (wr_cmd == `CMD_int_2  && wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_1);
-wire cond_192 = wr_cmd == `CMD_STOS;
-wire cond_193 = ~(wr_string_es_fault);
-wire cond_194 = wr_string_finish;
-wire cond_195 = wr_string_ignore;
-wire cond_196 = wr_cmd == `CMD_INS;
-wire cond_197 = wr_cmdex == `CMDEX_INS_real_1 || wr_cmdex == `CMDEX_INS_protected_1;
-wire cond_198 = wr_string_finish || wr_prefix_group_1_rep == 2'd0;
-wire cond_199 = wr_cmd == `CMD_OUTS;
-wire cond_200 = io_allow_check_needed && wr_cmdex == `CMDEX_OUTS_first;
-wire cond_201 = ~(write_io_for_wr_ready);
-wire cond_202 = wr_cmd == `CMD_PUSHF;
-wire cond_203 = wr_cmd == `CMD_JMP && (wr_cmdex == `CMDEX_JMP_Jv_STEP_0 || wr_cmdex == `CMDEX_JMP_Ev_STEP_0);
-wire cond_204 = wr_cmd == `CMD_JMP && (wr_cmdex == `CMDEX_JMP_Ev_Jv_STEP_1 || wr_cmdex == `CMDEX_JMP_real_v8086_STEP_1);
-wire cond_205 = wr_cmd == `CMD_JMP && (wr_cmdex == `CMDEX_JMP_Ep_STEP_0 || wr_cmdex == `CMDEX_JMP_Ap_STEP_0 ||  +  wr_cmdex == `CMDEX_JMP_Ep_STEP_1 || wr_cmdex == `CMDEX_JMP_Ap_STEP_1);
-wire cond_206 = wr_cmd == `CMD_JMP && wr_cmdex == `CMDEX_JMP_real_v8086_STEP_0;
-wire cond_207 = wr_cmd == `CMD_JMP && wr_cmdex == `CMDEX_JMP_task_switch_STEP_0;
-wire cond_208 = wr_cmd == `CMD_JMP_2 && wr_cmdex == `CMDEX_JMP_2_call_gate_STEP_0;
-wire cond_209 = wr_cmd == `CMD_JMP_2 && wr_cmdex == `CMDEX_JMP_2_call_gate_STEP_1;
-wire cond_210 = wr_cmd == `CMD_OUT;
-wire cond_211 = ~(io_allow_check_needed) || wr_cmdex == `CMDEX_OUT_protected;
-wire cond_212 = wr_cmd == `CMD_MOV;
-wire cond_213 = wr_cmd == `CMD_LAHF;
-wire cond_214 = wr_cmd == `CMD_CBW;
-wire cond_215 = wr_cmd == `CMD_CWD;
-wire cond_216 = wr_cmd == `CMD_POPF && wr_cmdex == `CMDEX_POPF_STEP_0;
-wire cond_217 = (protected_mode && cpl == 2'd0) || real_mode;
-wire cond_218 = (protected_mode && cpl <= iopl) || v8086_mode || real_mode;
-wire cond_219 = wr_cmd == `CMD_CLI;
-wire cond_220 = wr_cmd == `CMD_STI;
-wire cond_221 = iflag == `FALSE;
-wire cond_222 = wr_cmd == `CMD_BOUND && wr_cmdex == `CMDEX_BOUND_STEP_FIRST;
-wire cond_223 = wr_cmd == `CMD_SALC && wr_cmdex == `CMDEX_SALC_STEP_0;
-wire cond_224 = cflag;
-wire cond_225 = wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_1;
-wire cond_226 = wr_cmd == `CMD_task_switch && (wr_cmdex == `CMDEX_task_switch_STEP_2 || wr_cmdex == `CMDEX_task_switch_STEP_3 || wr_cmdex == `CMDEX_task_switch_STEP_4 || wr_cmdex == `CMDEX_task_switch_STEP_5);
-wire cond_227 = wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_6;
-wire cond_228 = glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_JUMP || glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_IRET;
-wire cond_229 = wr_cmd == `CMD_task_switch && (wr_cmdex == `CMDEX_task_switch_STEP_7 || wr_cmdex == `CMDEX_task_switch_STEP_8);
-wire cond_230 = wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_9;
-wire cond_231 = wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_10;
-wire cond_232 = wr_cmd == `CMD_task_switch_2 && wr_cmdex <= `CMDEX_task_switch_2_STEP_13;
-wire cond_233 = tr_cache[`DESC_BITS_TYPE] > 4'd3 || wr_cmdex <= `CMDEX_task_switch_2_STEP_11;
-wire cond_234 = wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_11;
-wire cond_235 = glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_CALL || glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_INT;
-wire cond_236 = wr_cmd == `CMD_task_switch && wr_cmdex >= `CMDEX_task_switch_STEP_12 && wr_cmdex <= `CMDEX_task_switch_STEP_14;
-wire cond_237 = wr_cmd == `CMD_task_switch_3;
-wire cond_238 = wr_cmd == `CMD_task_switch_4 && wr_cmdex == `CMDEX_task_switch_4_STEP_0;
-wire cond_239 = glob_param_1[`TASK_SWITCH_SOURCE_BITS] != `TASK_SWITCH_FROM_IRET;
-wire cond_240 = wr_cmd == `CMD_task_switch_4 && wr_cmdex == `CMDEX_task_switch_4_STEP_1;
-wire cond_241 = glob_descriptor[`DESC_BITS_TYPE] >= 4'd9 && cr0_pg && cr3 != exe_buffer_shifted[463:432];
-wire cond_242 = wr_cmd == `CMD_task_switch_4 && wr_cmdex == `CMDEX_task_switch_4_STEP_2;
-wire cond_243 = glob_param_2[2:0] == 3'b000;
-wire cond_244 = wr_cmd == `CMD_task_switch_4 && wr_cmdex >= `CMDEX_task_switch_4_STEP_3 && wr_cmdex <= `CMDEX_task_switch_4_STEP_8;
-wire cond_245 = wr_cmdex == `CMDEX_task_switch_4_STEP_3;
-wire cond_246 = glob_param_2[1:0] == 2'b00 && ~(v8086_mode) && `DESC_IS_NOT_ACCESSED(glob_descriptor);
-wire cond_247 = wr_cmdex == `CMDEX_task_switch_4_STEP_4;
-wire cond_248 = wr_cmdex == `CMDEX_task_switch_4_STEP_5;
-wire cond_249 = wr_cmdex == `CMDEX_task_switch_4_STEP_6;
-wire cond_250 = wr_cmdex == `CMDEX_task_switch_4_STEP_7;
-wire cond_251 = glob_param_2[1:0] == 2'b00 && `DESC_IS_ACCESSED(glob_descriptor);
-wire cond_252 = glob_param_2[1:0] != 2'b00;
-wire cond_253 = wr_cmd == `CMD_task_switch_4 && wr_cmdex == `CMDEX_task_switch_4_STEP_9;
-wire cond_254 = glob_param_3[16];
-wire cond_255 = wr_cmd == `CMD_task_switch_4 && wr_cmdex == `CMDEX_task_switch_4_STEP_10;
-wire cond_256 = glob_param_3[17] && task_trap[0];
-wire cond_257 = wr_cmd == `CMD_LEA;
-wire cond_258 = (wr_cmd == `CMD_SGDT || wr_cmd == `CMD_SIDT);
-wire cond_259 = wr_cmdex == `CMDEX_SGDT_SIDT_STEP_1;
-wire cond_260 = wr_cmdex == `CMDEX_SGDT_SIDT_STEP_2;
-wire cond_261 = wr_cmd == `CMD_MOVS;
-wire cond_262 = wr_cmd == `CMD_MOVSX || wr_cmd == `CMD_MOVZX;
-wire cond_263 = wr_cmd == `CMD_POPA;
-wire cond_264 = wr_cmdex[2:0] == 3'd7;
-wire cond_265 = wr_cmd == `CMD_debug_reg && wr_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0;
-wire cond_266 = wr_cmd == `CMD_debug_reg && wr_cmdex == `CMDEX_debug_reg_MOV_load_STEP_0;
-wire cond_267 = wr_decoder[13:11] == 3'd1;
-wire cond_268 = (wr_decoder[13:11] == 3'd4 || wr_decoder[13:11] == 3'd6);
-wire cond_269 = (wr_decoder[13:11] == 3'd5 || wr_decoder[13:11] == 3'd7);
-wire cond_270 = wr_cmd == `CMD_debug_reg && wr_cmdex == `CMDEX_debug_reg_MOV_load_STEP_1;
-wire cond_271 = wr_cmd == `CMD_XLAT;
-wire cond_272 = wr_cmd == `CMD_AAA || wr_cmd == `CMD_AAS;
-wire cond_273 = wr_cmd == `CMD_DAA || wr_cmd == `CMD_DAS;
-wire cond_274 = { wr_cmd[6:1], 1'd0 } == `CMD_BSx;
+ assign cond_0 = wr_cmd == `CMD_XADD && wr_cmdex == `CMDEX_XADD_FIRST;
+ assign cond_1 = wr_dst_is_memory && ~(write_for_wr_ready);
+ assign cond_2 = wr_cmd == `CMD_XADD && wr_cmdex == `CMDEX_XADD_LAST;
+ assign cond_3 = wr_modregrm_mod != 2'b11 || wr_modregrm_reg != wr_modregrm_rm;
+ assign cond_4 = wr_cmd == `CMD_JCXZ;
+ assign cond_5 = result_signals[0];
+ assign cond_6 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_Ep_STEP_0 || wr_cmdex == `CMDEX_CALL_Ap_STEP_0);
+ assign cond_7 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_Ep_STEP_1 || wr_cmdex == `CMDEX_CALL_Ap_STEP_1);
+ assign cond_8 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_real_v8086_STEP_0 || wr_cmdex == `CMDEX_CALL_real_v8086_STEP_1);
+ assign cond_9 = ~(write_for_wr_ready);
+ assign cond_10 = ~(wr_push_ss_fault);
+ assign cond_11 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_Ev_STEP_0 || wr_cmdex == `CMDEX_CALL_Jv_STEP_0);
+ assign cond_12 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_Ev_Jv_STEP_1 || wr_cmdex == `CMDEX_CALL_real_v8086_STEP_3);
+ assign cond_13 = wr_cmd == `CMD_CALL && wr_cmdex == `CMDEX_CALL_real_v8086_STEP_2;
+ assign cond_14 = wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_protected_seg_STEP_0 || wr_cmdex == `CMDEX_CALL_protected_seg_STEP_1);
+ assign cond_15 = ~(wr_new_push_ss_fault);
+ assign cond_16 = wr_cmd == `CMD_CALL && wr_cmdex == `CMDEX_CALL_protected_seg_STEP_2;
+ assign cond_17 = wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_task_switch_STEP_0;
+ assign cond_18 = wr_cmd == `CMD_CALL_2 && (wr_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_2 || wr_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_3);
+ assign cond_19 = wr_cmd == `CMD_CALL_3 && ( wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_4 || wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_5 || wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_6 || wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_7);
+ assign cond_20 = wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_7;
+ assign cond_21 = wr_cmd == `CMD_PUSH_MOV_SEG && { wr_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_implicit;
+ assign cond_22 = write_for_wr_ready && ~(wr_push_ss_fault);
+ assign cond_23 = wr_cmd == `CMD_PUSH_MOV_SEG && { wr_cmdex[3], 3'b0 } == `CMDEX_PUSH_MOV_SEG_modregrm;
+ assign cond_24 = wr_cmd == `CMD_NEG;
+ assign cond_25 = wr_cmd == `CMD_Jcc;
+ assign cond_26 = wr_cmd == `CMD_INVD && wr_cmdex == `CMDEX_INVD_STEP_0;
+ assign cond_27 = wr_cmd == `CMD_INVD && wr_cmdex == `CMDEX_INVD_STEP_1;
+ assign cond_28 = wr_cmd == `CMD_INVLPG && wr_cmdex == `CMDEX_INVLPG_STEP_0;
+ assign cond_29 = wr_cmd == `CMD_INVLPG && wr_cmdex == `CMDEX_INVLPG_STEP_1;
+ assign cond_30 = wr_cmd == `CMD_io_allow && (wr_cmdex == `CMDEX_io_allow_1 || wr_cmdex == `CMDEX_io_allow_2);
+ assign cond_31 = wr_cmd == `CMD_HLT && wr_cmdex == `CMDEX_HLT_STEP_0;
+ assign cond_32 = wr_cmd == `CMD_SCAS;
+ assign cond_33 = ~(wr_string_ignore);
+ assign cond_34 = wr_prefix_group_1_rep != 2'd0;
+ assign cond_35 = wr_string_ignore || wr_string_zf_finish;
+ assign cond_36 = ~(wr_string_ignore) && ~(wr_string_zf_finish) && wr_prefix_group_1_rep != 2'd0;
+ assign cond_37 = wr_cmd == `CMD_INC_DEC;
+ assign cond_38 = wr_cmd == `CMD_RET_near && wr_cmdex != `CMDEX_RET_near_LAST;
+ assign cond_39 = wr_cmd == `CMD_ARPL;
+ assign cond_40 = wr_cmd == `CMD_BSWAP;
+ assign cond_41 = wr_cmd == `CMD_LxS && wr_cmdex != `CMDEX_LxS_STEP_LAST;
+ assign cond_42 = wr_cmd == `CMD_LxS && wr_cmdex == `CMDEX_LxS_STEP_LAST;
+ assign cond_43 = (wr_cmd == `CMD_MOV_to_seg || wr_cmd == `CMD_LLDT || wr_cmd == `CMD_LTR) && wr_cmdex == `CMDEX_MOV_to_seg_LLDT_LTR_STEP_1;
+ assign cond_44 = (wr_cmd == `CMD_MOV_to_seg || wr_cmd == `CMD_LLDT || wr_cmd == `CMD_LTR) && wr_cmdex == `CMDEX_MOV_to_seg_LLDT_LTR_STEP_LAST;
+ assign cond_45 = wr_cmd == `CMD_MOV_to_seg && wr_decoder[13:11] == `SEGMENT_SS;
+ assign cond_46 = wr_cmd == `CMD_CLC;
+ assign cond_47 = wr_cmd == `CMD_CMC;
+ assign cond_48 = wr_cmd == `CMD_CLD;
+ assign cond_49 = wr_cmd == `CMD_STC;
+ assign cond_50 = wr_cmd == `CMD_STD;
+ assign cond_51 = wr_cmd == `CMD_SAHF;
+ assign cond_52 = wr_cmd == `CMD_int_2  && wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_2;
+ assign cond_53 = wr_cmd == `CMD_int_2  && wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_3;
+ assign cond_54 = wr_cmd == `CMD_int_2 && ( wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_4 || wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_5 || wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_6 || wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_7 || wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_8 || wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_9);
+ assign cond_55 = wr_cmd == `CMD_int_3 && ( wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_0 || wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_1 || wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_2 || wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_3);
+ assign cond_56 = (wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_2 && ~(exc_push_error)) || wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_3;
+ assign cond_57 = wr_cmd == `CMD_int && wr_cmdex == `CMDEX_int_STEP_0;
+ assign cond_58 = wr_cmd == `CMD_int && wr_cmdex == `CMDEX_int_STEP_1;
+ assign cond_59 = wr_cmd == `CMD_int && (wr_cmdex == `CMDEX_int_real_STEP_3 || wr_cmdex == `CMDEX_int_real_STEP_4);
+ assign cond_60 = wr_cmd == `CMD_int && wr_cmdex == `CMDEX_int_real_STEP_5;
+ assign cond_61 = wr_cmd == `CMD_int && (wr_cmdex == `CMDEX_int_protected_STEP_0 || wr_cmdex == `CMDEX_int_protected_STEP_1 || wr_cmdex == `CMDEX_int_protected_STEP_2);
+ assign cond_62 = wr_cmd == `CMD_int_2 && wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_5;
+ assign cond_63 = wr_cmd == `CMD_int_3 && wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_6;
+ assign cond_64 = v8086_mode;
+ assign cond_65 = wr_cmd == `CMD_int && (wr_cmdex == `CMDEX_int_real_STEP_0 || wr_cmdex == `CMDEX_int_real_STEP_1 || wr_cmdex == `CMDEX_int_real_STEP_2);
+ assign cond_66 = wr_cmd == `CMD_AAM || wr_cmd == `CMD_AAD;
+ assign cond_67 = wr_cmd == `CMD_load_seg && wr_cmdex == `CMDEX_load_seg_STEP_1;
+ assign cond_68 = real_mode;
+ assign cond_69 = protected_mode && glob_param_1[15:2] == 14'd0;
+ assign cond_70 = wr_cmd == `CMD_load_seg && wr_cmdex == `CMDEX_load_seg_STEP_2;
+ assign cond_71 = ~(protected_mode && (glob_param_1[15:2] == 14'd0 || glob_param_1[`MC_PARAM_1_FLAG_NO_WRITE_BIT]));
+ assign cond_72 = glob_param_1[18:16] == `SEGMENT_TR || (glob_param_1[18:16] < `SEGMENT_LDT && `DESC_IS_NOT_ACCESSED(glob_descriptor));
+ assign cond_73 = glob_param_1[18:16] == `SEGMENT_TR;
+ assign cond_74 = glob_param_1[18:16] == `SEGMENT_LDT || (glob_param_1[18:16] < `SEGMENT_LDT && `DESC_IS_ACCESSED(glob_descriptor));
+ assign cond_75 = wr_cmd == `CMD_POP_seg && wr_cmdex == `CMDEX_POP_seg_STEP_1;
+ assign cond_76 = wr_cmd == `CMD_POP_seg && wr_cmdex == `CMDEX_POP_seg_STEP_LAST;
+ assign cond_77 = wr_decoder[5:3] == `SEGMENT_SS;
+ assign cond_78 = { wr_cmd[6:2], 2'd0 } == `CMD_BTx;
+ assign cond_79 = wr_cmd[1:0] != 2'd0;
+ assign cond_80 = wr_cmd == `CMD_IRET && wr_cmdex <= `CMDEX_IRET_real_v86_STEP_2;
+ assign cond_81 = wr_cmdex == `CMDEX_IRET_real_v86_STEP_0;
+ assign cond_82 = wr_cmd == `CMD_IRET && wr_cmdex == `CMDEX_IRET_real_v86_STEP_3;
+ assign cond_83 = wr_operand_32bit;
+ assign cond_84 = wr_cmd == `CMD_IRET && (wr_cmdex == `CMDEX_IRET_protected_STEP_0 || wr_cmdex == `CMDEX_IRET_task_switch_STEP_0 || wr_cmdex == `CMDEX_IRET_task_switch_STEP_1);
+ assign cond_85 = wr_cmd == `CMD_IRET && wr_cmdex >= `CMDEX_IRET_protected_STEP_1 && wr_cmdex <= `CMDEX_IRET_protected_STEP_3;
+ assign cond_86 = wr_cmd == `CMD_IRET && wr_cmdex >= `CMDEX_IRET_protected_to_v86_STEP_0 && wr_cmdex <= `CMDEX_IRET_protected_to_v86_STEP_4;
+ assign cond_87 = wr_cmd == `CMD_IRET && wr_cmdex == `CMDEX_IRET_protected_to_v86_STEP_5;
+ assign cond_88 = wr_cmd == `CMD_IRET_2 && wr_cmdex == `CMDEX_IRET_2_protected_to_v86_STEP_6;
+ assign cond_89 = wr_cmd == `CMD_IRET_2 && wr_cmdex == `CMDEX_IRET_2_protected_same_STEP_1;
+ assign cond_90 = cpl <= iopl;
+ assign cond_91 = cpl == 2'd0;
+ assign cond_92 = wr_cmd == `CMD_IRET_2 && wr_cmdex >= `CMDEX_IRET_2_protected_outer_STEP_0 && wr_cmdex <= `CMDEX_IRET_2_protected_outer_STEP_2;
+ assign cond_93 = wr_cmd == `CMD_IRET_2 && wr_cmdex == `CMDEX_IRET_2_protected_outer_STEP_4;
+ assign cond_94 = wr_task_rpl <= iopl;
+ assign cond_95 = wr_task_rpl == 2'd0;
+ assign cond_96 = wr_cmd == `CMD_POP && wr_cmdex == `CMDEX_POP_implicit;
+ assign cond_97 = wr_cmd == `CMD_POP && wr_cmdex == `CMDEX_POP_modregrm_STEP_0;
+ assign cond_98 = wr_cmd == `CMD_POP && wr_cmdex == `CMDEX_POP_modregrm_STEP_1;
+ assign cond_99 = ~(wr_dst_is_memory) || write_for_wr_ready;
+ assign cond_100 = wr_cmd == `CMD_IDIV || wr_cmd == `CMD_DIV;
+ assign cond_101 = ~(wr_is_8bit);
+ assign cond_102 = wr_cmd == `CMD_Shift;
+ assign cond_103 = ~(result_signals[4]);
+ assign cond_104 = result_signals[3];
+ assign cond_105 = result_signals[2];
+ assign cond_106 = wr_cmd == `CMD_CMPS && wr_cmdex == `CMDEX_CMPS_FIRST;
+ assign cond_107 = wr_cmd == `CMD_CMPS && wr_cmdex == `CMDEX_CMPS_LAST;
+ assign cond_108 = wr_string_ignore || wr_string_zf_finish || wr_prefix_group_1_rep == 2'd0;
+ assign cond_109 = wr_cmd == `CMD_control_reg && wr_cmdex == `CMDEX_control_reg_SMSW_STEP_0;
+ assign cond_110 = wr_cmd == `CMD_control_reg && wr_cmdex == `CMDEX_control_reg_LMSW_STEP_0;
+ assign cond_111 = cr0_pe ^ result2[0];
+ assign cond_112 = wr_cmd == `CMD_control_reg && wr_cmdex == `CMDEX_control_reg_MOV_store_STEP_0;
+ assign cond_113 = wr_cmd == `CMD_control_reg && wr_cmdex == `CMDEX_control_reg_MOV_load_STEP_0;
+ assign cond_114 = wr_decoder[13:11] == 3'd0;
+ assign cond_115 = (cr0_pe ^ result2[0]) || (cr0_wp ^ result2[16]) || (cr0_pg ^ result[31]);
+ assign cond_116 = cr0_pe && result2[0] == 1'b0;
+ assign cond_117 = wr_decoder[13:11] == 3'd2;
+ assign cond_118 = wr_decoder[13:11] == 3'd3;
+ assign cond_119 = (wr_cmd == `CMD_LGDT || wr_cmd == `CMD_LIDT);
+ assign cond_120 = wr_cmdex == `CMDEX_LGDT_LIDT_STEP_1;
+ assign cond_121 = wr_cmd == `CMD_LGDT;
+ assign cond_122 = wr_cmd == `CMD_LIDT;
+ assign cond_123 = wr_cmdex == `CMDEX_LGDT_LIDT_STEP_2;
+ assign cond_124 = wr_cmd == `CMD_PUSHA;
+ assign cond_125 = wr_cmdex[2:0] == 3'd0;
+ assign cond_126 = wr_cmdex[2:0] < 3'd7;
+ assign cond_127 = wr_cmdex[2:0] == 3'd7 && write_for_wr_ready && ~(wr_push_ss_fault);
+ assign cond_128 = wr_cmd == `CMD_SETcc;
+ assign cond_129 = wr_cmd == `CMD_CMPXCHG;
+ assign cond_130 = wr_cmd == `CMD_ENTER && wr_cmdex == `CMDEX_ENTER_FIRST;
+ assign cond_131 = wr_cmd == `CMD_ENTER && wr_cmdex == `CMDEX_ENTER_LAST;
+ assign cond_132 = wr_cmd == `CMD_ENTER && (wr_cmdex == `CMDEX_ENTER_PUSH || wr_cmdex == `CMDEX_ENTER_LOOP);
+ assign cond_133 = wr_cmd == `CMD_IMUL;
+ assign cond_134 = wr_dst_is_edx_eax;
+ assign cond_135 = wr_cmd == `CMD_LEAVE;
+ assign cond_136 = { wr_cmd[6:1], 1'd0 } == `CMD_SHxD;
+ assign cond_137 = wr_cmd == `CMD_WBINVD && wr_cmdex == `CMDEX_WBINVD_STEP_0;
+ assign cond_138 = wr_cmd == `CMD_WBINVD && wr_cmdex == `CMDEX_WBINVD_STEP_1;
+ assign cond_139 = { wr_cmd[6:3], 3'd0 } == `CMD_Arith;
+ assign cond_140 = wr_cmd[2:0] != 3'b111 && wr_dst_is_memory && ~(write_for_wr_ready);
+ assign cond_141 = wr_cmd[2:0] != 3'b111;
+ assign cond_142 = wr_cmd == `CMD_MUL;
+ assign cond_143 = wr_cmd == `CMD_LOOP;
+ assign cond_144 = wr_address_16bit;
+ assign cond_145 = wr_cmd == `CMD_TEST;
+ assign cond_146 = wr_cmd == `CMD_CLTS;
+ assign cond_147 = wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_STEP_1;
+ assign cond_148 = wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_STEP_2;
+ assign cond_149 = wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_real_STEP_3;
+ assign cond_150 = wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_outer_STEP_3;
+ assign cond_151 = wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_outer_STEP_4;
+ assign cond_152 = wr_cmd == `CMD_LODS;
+ assign cond_153 = wr_string_ignore || wr_string_finish;
+ assign cond_154 = ~(wr_string_ignore) && ~(wr_string_finish) && wr_prefix_group_1_rep != 2'd0;
+ assign cond_155 = wr_cmd == `CMD_XCHG && wr_cmdex == `CMDEX_XCHG_implicit;
+ assign cond_156 = wr_cmd == `CMD_XCHG && wr_cmdex == `CMDEX_XCHG_modregrm;
+ assign cond_157 = wr_cmd == `CMD_XCHG && wr_cmdex == `CMDEX_XCHG_modregrm_LAST;
+ assign cond_158 = wr_cmd == `CMD_PUSH;
+ assign cond_159 = wr_cmd == `CMD_INT_INTO && wr_cmdex == `CMDEX_INT_INTO_INT_STEP_0;
+ assign cond_160 = wr_cmd == `CMD_INT_INTO && wr_cmdex == `CMDEX_INT_INTO_INT3_STEP_0;
+ assign cond_161 = wr_cmd == `CMD_INT_INTO && wr_cmdex == `CMDEX_INT_INTO_INT1_STEP_0;
+ assign cond_162 = wr_cmd == `CMD_INT_INTO && wr_cmdex == `CMDEX_INT_INTO_INTO_STEP_0;
+ assign cond_163 = oflag;
+ assign cond_164 = wr_cmd == `CMD_CPUID;
+ assign cond_165 = eax == 32'd0;
+ assign cond_166 = eax != 32'd0;
+ assign cond_167 = wr_cmd == `CMD_IN;
+ assign cond_168 = ~(io_allow_check_needed) || wr_cmdex == `CMDEX_IN_protected;
+ assign cond_169 = wr_cmd == `CMD_NOT;
+ assign cond_170 = (wr_cmd == `CMD_LAR || wr_cmd == `CMD_LSL || wr_cmd == `CMD_VERR || wr_cmd == `CMD_VERW) && (wr_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_1 || wr_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_2);
+ assign cond_171 = (wr_cmd == `CMD_LAR || wr_cmd == `CMD_LSL) && wr_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_LAST;
+ assign cond_172 = wr_dst_is_reg;
+ assign cond_173 = (wr_cmd == `CMD_VERR || wr_cmd == `CMD_VERW) && wr_cmdex == `CMDEX_LAR_LSL_VERR_VERW_STEP_LAST;
+ assign cond_174 = (wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_same_STEP_3) || (wr_cmd == `CMD_IRET_2  && wr_cmdex == `CMDEX_IRET_2_protected_same_STEP_0) || (wr_cmd == `CMD_CALL_2  && wr_cmdex == `CMDEX_CALL_2_protected_seg_STEP_3) || (wr_cmd == `CMD_CALL_2  && wr_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_2) || (wr_cmd == `CMD_JMP     && wr_cmdex == `CMDEX_JMP_protected_seg_STEP_0) || (wr_cmd == `CMD_JMP_2   && wr_cmdex == `CMDEX_JMP_2_call_gate_STEP_2) || (wr_cmd == `CMD_int_2   && wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_4);
+ assign cond_175 = `DESC_IS_NOT_ACCESSED(glob_descriptor);
+ assign cond_176 = wr_cmd != `CMD_JMP && wr_cmd != `CMD_JMP_2 && wr_cmd != `CMD_int_2;
+ assign cond_177 = (wr_cmd == `CMD_CALL_3 && wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_9) || (wr_cmd == `CMD_int_3  && wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_4);
+ assign cond_178 = (wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_same_STEP_4) || (wr_cmd == `CMD_CALL_2  && wr_cmdex == `CMDEX_CALL_2_protected_seg_STEP_4) || (wr_cmd == `CMD_CALL_2  && wr_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_3) || (wr_cmd == `CMD_CALL_3  && wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_10) || (wr_cmd == `CMD_JMP     && wr_cmdex == `CMDEX_JMP_protected_seg_STEP_1) || (wr_cmd == `CMD_JMP_2   && wr_cmdex == `CMDEX_JMP_2_call_gate_STEP_3);
+ assign cond_179 = (wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_outer_STEP_5) || (wr_cmd == `CMD_IRET_2  && wr_cmdex == `CMDEX_IRET_2_protected_outer_STEP_3);
+ assign cond_180 = (wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_outer_STEP_6) || (wr_cmd == `CMD_IRET_2  && wr_cmdex == `CMDEX_IRET_2_protected_outer_STEP_5) || (wr_cmd == `CMD_CALL_3  && wr_cmdex == `CMDEX_CALL_3_call_gate_more_STEP_8) || (wr_cmd == `CMD_int_3   && wr_cmdex == `CMDEX_int_3_int_trap_gate_more_STEP_5);
+ assign cond_181 = `DESC_IS_NOT_ACCESSED(glob_descriptor) && glob_param_1[15:2] != 14'd0;
+ assign cond_182 = (wr_cmd == `CMD_RET_far && wr_cmdex == `CMDEX_RET_far_outer_STEP_7) ||  + (wr_cmd == `CMD_IRET_2 && wr_cmdex == `CMDEX_IRET_2_protected_outer_STEP_6);
+ assign cond_183 = (wr_cmd == `CMD_CALL && (wr_cmdex == `CMDEX_CALL_protected_STEP_0 || wr_cmdex == `CMDEX_CALL_protected_STEP_1)) || (wr_cmd == `CMD_JMP  && (wr_cmdex == `CMDEX_JMP_protected_STEP_0  || wr_cmdex == `CMDEX_JMP_protected_STEP_1));
+ assign cond_184 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_task_gate_STEP_0) || (wr_cmd == `CMD_JMP    && wr_cmdex == `CMDEX_JMP_task_gate_STEP_0) || (wr_cmd == `CMD_int    && wr_cmdex == `CMDEX_int_task_gate_STEP_0);
+ assign cond_185 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_task_gate_STEP_1) || (wr_cmd == `CMD_JMP    && wr_cmdex == `CMDEX_JMP_task_gate_STEP_1) || (wr_cmd == `CMD_int    && wr_cmdex == `CMDEX_int_task_gate_STEP_1);
+ assign cond_186 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_call_gate_STEP_0) || (wr_cmd == `CMD_int    && wr_cmdex == `CMDEX_int_int_trap_gate_STEP_0);
+ assign cond_187 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_call_gate_STEP_1) || (wr_cmd == `CMD_int    && wr_cmdex == `CMDEX_int_int_trap_gate_STEP_1);
+ assign cond_188 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_call_gate_STEP_2) || (wr_cmd == `CMD_int    && wr_cmdex == `CMDEX_int_int_trap_gate_STEP_2);
+ assign cond_189 = (wr_cmd == `CMD_CALL_2 && (wr_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_0 || wr_cmdex == `CMDEX_CALL_2_call_gate_same_STEP_1)) || (wr_cmd == `CMD_int_2 && (wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_0 || wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_1 || wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_2 || wr_cmdex == `CMDEX_int_2_int_trap_gate_same_STEP_3));
+ assign cond_190 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_0) || (wr_cmd == `CMD_int_2  && wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_0);
+ assign cond_191 = (wr_cmd == `CMD_CALL_2 && wr_cmdex == `CMDEX_CALL_2_call_gate_more_STEP_1) || (wr_cmd == `CMD_int_2  && wr_cmdex == `CMDEX_int_2_int_trap_gate_more_STEP_1);
+ assign cond_192 = wr_cmd == `CMD_STOS;
+ assign cond_193 = ~(wr_string_es_fault);
+ assign cond_194 = wr_string_finish;
+ assign cond_195 = wr_string_ignore;
+ assign cond_196 = wr_cmd == `CMD_INS;
+ assign cond_197 = wr_cmdex == `CMDEX_INS_real_1 || wr_cmdex == `CMDEX_INS_protected_1;
+ assign cond_198 = wr_string_finish || wr_prefix_group_1_rep == 2'd0;
+ assign cond_199 = wr_cmd == `CMD_OUTS;
+ assign cond_200 = io_allow_check_needed && wr_cmdex == `CMDEX_OUTS_first;
+ assign cond_201 = ~(write_io_for_wr_ready);
+ assign cond_202 = wr_cmd == `CMD_PUSHF;
+ assign cond_203 = wr_cmd == `CMD_JMP && (wr_cmdex == `CMDEX_JMP_Jv_STEP_0 || wr_cmdex == `CMDEX_JMP_Ev_STEP_0);
+ assign cond_204 = wr_cmd == `CMD_JMP && (wr_cmdex == `CMDEX_JMP_Ev_Jv_STEP_1 || wr_cmdex == `CMDEX_JMP_real_v8086_STEP_1);
+ assign cond_205 = wr_cmd == `CMD_JMP && (wr_cmdex == `CMDEX_JMP_Ep_STEP_0 || wr_cmdex == `CMDEX_JMP_Ap_STEP_0 ||  +  wr_cmdex == `CMDEX_JMP_Ep_STEP_1 || wr_cmdex == `CMDEX_JMP_Ap_STEP_1);
+ assign cond_206 = wr_cmd == `CMD_JMP && wr_cmdex == `CMDEX_JMP_real_v8086_STEP_0;
+ assign cond_207 = wr_cmd == `CMD_JMP && wr_cmdex == `CMDEX_JMP_task_switch_STEP_0;
+ assign cond_208 = wr_cmd == `CMD_JMP_2 && wr_cmdex == `CMDEX_JMP_2_call_gate_STEP_0;
+ assign cond_209 = wr_cmd == `CMD_JMP_2 && wr_cmdex == `CMDEX_JMP_2_call_gate_STEP_1;
+ assign cond_210 = wr_cmd == `CMD_OUT;
+ assign cond_211 = ~(io_allow_check_needed) || wr_cmdex == `CMDEX_OUT_protected;
+ assign cond_212 = wr_cmd == `CMD_MOV;
+ assign cond_213 = wr_cmd == `CMD_LAHF;
+ assign cond_214 = wr_cmd == `CMD_CBW;
+ assign cond_215 = wr_cmd == `CMD_CWD;
+ assign cond_216 = wr_cmd == `CMD_POPF && wr_cmdex == `CMDEX_POPF_STEP_0;
+ assign cond_217 = (protected_mode && cpl == 2'd0) || real_mode;
+ assign cond_218 = (protected_mode && cpl <= iopl) || v8086_mode || real_mode;
+ assign cond_219 = wr_cmd == `CMD_CLI;
+ assign cond_220 = wr_cmd == `CMD_STI;
+ assign cond_221 = iflag == `FALSE;
+ assign cond_222 = wr_cmd == `CMD_BOUND && wr_cmdex == `CMDEX_BOUND_STEP_FIRST;
+ assign cond_223 = wr_cmd == `CMD_SALC && wr_cmdex == `CMDEX_SALC_STEP_0;
+ assign cond_224 = cflag;
+ assign cond_225 = wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_1;
+ assign cond_226 = wr_cmd == `CMD_task_switch && (wr_cmdex == `CMDEX_task_switch_STEP_2 || wr_cmdex == `CMDEX_task_switch_STEP_3 || wr_cmdex == `CMDEX_task_switch_STEP_4 || wr_cmdex == `CMDEX_task_switch_STEP_5);
+ assign cond_227 = wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_6;
+ assign cond_228 = glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_JUMP || glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_IRET;
+ assign cond_229 = wr_cmd == `CMD_task_switch && (wr_cmdex == `CMDEX_task_switch_STEP_7 || wr_cmdex == `CMDEX_task_switch_STEP_8);
+ assign cond_230 = wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_9;
+ assign cond_231 = wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_10;
+ assign cond_232 = wr_cmd == `CMD_task_switch_2 && wr_cmdex <= `CMDEX_task_switch_2_STEP_13;
+ assign cond_233 = tr_cache[`DESC_BITS_TYPE] > 4'd3 || wr_cmdex <= `CMDEX_task_switch_2_STEP_11;
+ assign cond_234 = wr_cmd == `CMD_task_switch && wr_cmdex == `CMDEX_task_switch_STEP_11;
+ assign cond_235 = glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_CALL || glob_param_1[`TASK_SWITCH_SOURCE_BITS] == `TASK_SWITCH_FROM_INT;
+ assign cond_236 = wr_cmd == `CMD_task_switch && wr_cmdex >= `CMDEX_task_switch_STEP_12 && wr_cmdex <= `CMDEX_task_switch_STEP_14;
+ assign cond_237 = wr_cmd == `CMD_task_switch_3;
+ assign cond_238 = wr_cmd == `CMD_task_switch_4 && wr_cmdex == `CMDEX_task_switch_4_STEP_0;
+ assign cond_239 = glob_param_1[`TASK_SWITCH_SOURCE_BITS] != `TASK_SWITCH_FROM_IRET;
+ assign cond_240 = wr_cmd == `CMD_task_switch_4 && wr_cmdex == `CMDEX_task_switch_4_STEP_1;
+ assign cond_241 = glob_descriptor[`DESC_BITS_TYPE] >= 4'd9 && cr0_pg && cr3 != exe_buffer_shifted[463:432];
+ assign cond_242 = wr_cmd == `CMD_task_switch_4 && wr_cmdex == `CMDEX_task_switch_4_STEP_2;
+ assign cond_243 = glob_param_2[2:0] == 3'b000;
+ assign cond_244 = wr_cmd == `CMD_task_switch_4 && wr_cmdex >= `CMDEX_task_switch_4_STEP_3 && wr_cmdex <= `CMDEX_task_switch_4_STEP_8;
+ assign cond_245 = wr_cmdex == `CMDEX_task_switch_4_STEP_3;
+ assign cond_246 = glob_param_2[1:0] == 2'b00 && ~(v8086_mode) && `DESC_IS_NOT_ACCESSED(glob_descriptor);
+ assign cond_247 = wr_cmdex == `CMDEX_task_switch_4_STEP_4;
+ assign cond_248 = wr_cmdex == `CMDEX_task_switch_4_STEP_5;
+ assign cond_249 = wr_cmdex == `CMDEX_task_switch_4_STEP_6;
+ assign cond_250 = wr_cmdex == `CMDEX_task_switch_4_STEP_7;
+ assign cond_251 = glob_param_2[1:0] == 2'b00 && `DESC_IS_ACCESSED(glob_descriptor);
+ assign cond_252 = glob_param_2[1:0] != 2'b00;
+ assign cond_253 = wr_cmd == `CMD_task_switch_4 && wr_cmdex == `CMDEX_task_switch_4_STEP_9;
+ assign cond_254 = glob_param_3[16];
+ assign cond_255 = wr_cmd == `CMD_task_switch_4 && wr_cmdex == `CMDEX_task_switch_4_STEP_10;
+ assign cond_256 = glob_param_3[17] && task_trap[0];
+ assign cond_257 = wr_cmd == `CMD_LEA;
+ assign cond_258 = (wr_cmd == `CMD_SGDT || wr_cmd == `CMD_SIDT);
+ assign cond_259 = wr_cmdex == `CMDEX_SGDT_SIDT_STEP_1;
+ assign cond_260 = wr_cmdex == `CMDEX_SGDT_SIDT_STEP_2;
+ assign cond_261 = wr_cmd == `CMD_MOVS;
+ assign cond_262 = wr_cmd == `CMD_MOVSX || wr_cmd == `CMD_MOVZX;
+ assign cond_263 = wr_cmd == `CMD_POPA;
+ assign cond_264 = wr_cmdex[2:0] == 3'd7;
+ assign cond_265 = wr_cmd == `CMD_debug_reg && wr_cmdex == `CMDEX_debug_reg_MOV_store_STEP_0;
+ assign cond_266 = wr_cmd == `CMD_debug_reg && wr_cmdex == `CMDEX_debug_reg_MOV_load_STEP_0;
+ assign cond_267 = wr_decoder[13:11] == 3'd1;
+ assign cond_268 = (wr_decoder[13:11] == 3'd4 || wr_decoder[13:11] == 3'd6);
+ assign cond_269 = (wr_decoder[13:11] == 3'd5 || wr_decoder[13:11] == 3'd7);
+ assign cond_270 = wr_cmd == `CMD_debug_reg && wr_cmdex == `CMDEX_debug_reg_MOV_load_STEP_1;
+ assign cond_271 = wr_cmd == `CMD_XLAT;
+ assign cond_272 = wr_cmd == `CMD_AAA || wr_cmd == `CMD_AAS;
+ assign cond_273 = wr_cmd == `CMD_DAA || wr_cmd == `CMD_DAS;
+ assign cond_274 = { wr_cmd[6:1], 1'd0 } == `CMD_BSx;
 //======================================================== saves
 assign gdtr_limit_to_reg =
     (cond_119 && cond_121 && cond_120)? ( result2[15:0]) :
@@ -588,7 +865,7 @@ assign edi_to_reg =
 assign dr6_bt_to_reg =
     (cond_266 && cond_268)? (     result2[15]) :
     dr6_bt;
-wire [1:0] wr_task_rpl_to_reg =
+ assign wr_task_rpl_to_reg =
     (cond_179)? ( cpl) :
     (cond_240)? ( task_cs[1:0]) :
     wr_task_rpl;
@@ -870,8 +1147,8 @@ assign idflag_to_reg =
     (cond_240)? ( task_eflags[21]) :
     idflag;
 //======================================================== always
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) wr_task_rpl <= 2'd0;
+always @(posedge clk) begin
+    if(rst) wr_task_rpl <= 2'd0;
     else              wr_task_rpl <= wr_task_rpl_to_reg;
 end
 //======================================================== sets
diff --git a/rtl/ao486/avalon_io.v b/rtl/ao486/avalon_io.v
index e591ce4..3515cbd 100644
--- a/rtl/ao486/avalon_io.v
+++ b/rtl/ao486/avalon_io.v
@@ -30,7 +30,7 @@
 
 module avalon_io(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //io_read
     input               io_read_do,
@@ -65,19 +65,37 @@ module avalon_io(
 
 //------------------------------------------------------------------------------
 
+localparam [2:0] STATE_IDLE      = 3'd0;
+localparam [2:0] STATE_WRITE_1   = 3'd1;
+localparam [2:0] STATE_WRITE_2   = 3'd2;
+localparam [2:0] STATE_READ_1    = 3'd3;
+localparam [2:0] STATE_READ_2    = 3'd4;
 reg [2:0] state;
-
 reg       was_readdatavalid;
-
 reg       avalon_io_read_reg;
 reg       avalon_io_write_reg;
+wire address_out_of_bounds;
+wire [31:0] avalon_io_readdata_final ;
+wire [3:0]  write_1_byteenable;
+wire [3:0]  write_2_byteenable;
+wire [31:0] write_1_data;
+wire [31:0] write_2_data;
+wire        write_two_stage;
+wire [15:0] write_address_next;
+wire [3:0]  read_1_byteenable;
+wire [3:0]  read_2_byteenable;
+wire        read_two_stage;
+wire [15:0] read_address_next;
+wire [31:0] read_data_1;
+wire [31:0] read_data_2;
+wire _unused_ok;
 
 assign avalon_io_read  = (address_out_of_bounds)? 1'b0 : avalon_io_read_reg;
 assign avalon_io_write = (address_out_of_bounds)? 1'b0 : avalon_io_write_reg;
 
 //------------------------------------------------------------------------------
 
-wire address_out_of_bounds =
+ assign address_out_of_bounds =
     (avalon_io_address >= 16'h0010 && avalon_io_address < 16'h0020) ||
     (avalon_io_address == 16'h0020 && avalon_io_byteenable[1:0] == 2'b00) ||
     (avalon_io_address >= 16'h0024 && avalon_io_address < 16'h0040) ||
@@ -96,7 +114,7 @@ wire address_out_of_bounds =
     (avalon_io_address >= 16'h03F8 && avalon_io_address < 16'h8888) ||
     (avalon_io_address >= 16'h8890);
     
-wire [31:0] avalon_io_readdata_final =
+ assign avalon_io_readdata_final =
     (address_out_of_bounds)?            32'hFFFFFFFF :
     (avalon_io_address == 16'h0020)?    { 16'hFFFF, avalon_io_readdata[15:0] } :
     (avalon_io_address == 16'h0070)?    { 16'hFFFF, avalon_io_readdata[15:0] } :
@@ -106,27 +124,10 @@ wire [31:0] avalon_io_readdata_final =
 
 //------------------------------------------------------------------------------
 
-wire [3:0]  write_1_byteenable;
-wire [3:0]  write_2_byteenable;
-wire [31:0] write_1_data;
-wire [31:0] write_2_data;
-wire        write_two_stage;
-wire [15:0] write_address_next;
 
-wire [3:0]  read_1_byteenable;
-wire [3:0]  read_2_byteenable;
-wire        read_two_stage;
-wire [15:0] read_address_next;
-wire [31:0] read_data_1;
-wire [31:0] read_data_2;
 
 //------------------------------------------------------------------------------
 
-localparam [2:0] STATE_IDLE      = 3'd0;
-localparam [2:0] STATE_WRITE_1   = 3'd1;
-localparam [2:0] STATE_WRITE_2   = 3'd2;
-localparam [2:0] STATE_READ_1    = 3'd3;
-localparam [2:0] STATE_READ_2    = 3'd4;
 
 //------------------------------------------------------------------------------
 
@@ -210,7 +211,7 @@ assign read_data_2 =
 //------------------------------------------------------------------------------
 
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, write_address_next[1:0], read_address_next[1:0], 1'b0 };
+ assign _unused_ok = &{ 1'b0, write_address_next[1:0], read_address_next[1:0], 1'b0 };
 // synthesis translate_on
 
 //------------------------------------------------------------------------------
diff --git a/rtl/ao486/exception.v b/rtl/ao486/exception.v
index b4c603b..2ea67cf 100644
--- a/rtl/ao486/exception.v
+++ b/rtl/ao486/exception.v
@@ -30,7 +30,7 @@
 
 module exception(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //exception indicators
     input               dec_gp_fault,
@@ -143,46 +143,71 @@ module exception(
 );
 
 //------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-
+`define EXCEPTION_TYPE_BENIGN           2'd0
+`define EXCEPTION_TYPE_CONTRIBUTORY     2'd1
+`define EXCEPTION_TYPE_PAGE_FAULT       2'd2
+`define EXCEPTION_TYPE_DOUBLE_FAULT     2'd3
+reg         external;
+reg [1:0]   count;
+reg [1:0]   last_type;
+reg [31:0]  trap_eip;
+reg         shutdown;
+reg         interrupt_load;
+reg         interrupt_string_in_progress;
+reg [8:0]   exc_vector_full;
 wire        exception_init;
 wire        exception_start;
-
 wire        active_dec;
 wire        active_rd;
 wire        active_exe;
 wire        active_wr;
-
 wire [31:0] exception_eip_from_wr;
+wire [7:0]  vector;
+wire [15:0] error_code;
+wire        push_error;
+wire        class_trap;
+wire        class_abort;
+wire [1:0]  exception_type;
+wire        shutdown_start;
+
+//------------------------------------------------------------------------------
+
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire exc_soft_int_to_reg;
+wire exc_push_error_to_reg;
+wire [1:0] count_to_reg ;
+wire [31:0] exc_eip_to_reg ;
+wire external_to_reg;
+wire [1:0] last_type_to_reg ;
+wire [8:0] exc_vector_full_to_reg ;
+wire [15:0] exc_error_code_to_reg ;
+wire exc_soft_int_ib_to_reg;
+wire shutdown_to_reg;
+
 
 //------------------------------------------------------------------------------
 
-reg         external;
-reg [1:0]   count;
-reg [1:0]   last_type;
 
-reg [31:0]  trap_eip;
 
-reg         shutdown;
 
-reg         interrupt_load;
-reg         interrupt_string_in_progress;
 
-reg [8:0]   exc_vector_full;
 
 //------------------------------------------------------------------------------
 
-wire [7:0]  vector;
-wire [15:0] error_code;
-wire        push_error;
 
-wire        class_trap;
-wire        class_abort;
 
-wire [1:0]  exception_type;
 
-wire        shutdown_start;
 
 //------------------------------------------------------------------------------
 
@@ -214,8 +239,8 @@ assign exc_pf_check= active_exe && exe_trigger_pf_fault;
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               exc_vector_full <= 9'd0;
+always @(posedge clk) begin
+    if(rst)                               exc_vector_full <= 9'd0;
     
     else if(active_wr && wr_new_push_ss_fault)      exc_vector_full <= { 1'b1, `EXCEPTION_SS };
     else if(active_wr && wr_string_es_fault)        exc_vector_full <= { 1'b1, `EXCEPTION_GP };
@@ -253,8 +278,8 @@ always @(posedge clk or negedge rst_n) begin
     else                                            exc_vector_full <= exc_vector_full_to_reg; //set if(exception_init || wr_debug_init || interrupt_done)
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           exc_error_code <= 16'd0;
+always @(posedge clk) begin
+    if(rst)                           exc_error_code <= 16'd0;
     
     else if(active_wr && write_ac_fault)        exc_error_code <= 16'd0;
     else if(active_wr && write_page_fault)      exc_error_code <= tlb_write_pf_error_code;
@@ -273,26 +298,26 @@ always @(posedge clk or negedge rst_n) begin
     else                                        exc_error_code <= exc_error_code_to_reg; //set if(exception_init || wr_debug_init || interrupt_done)
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               exc_push_error <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               exc_push_error <= `FALSE;
     else if(active_wr && wr_int)    exc_push_error <= `FALSE;
     else                            exc_push_error <= exc_push_error_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               exc_soft_int <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               exc_soft_int <= `FALSE;
     else if(active_wr && wr_int)    exc_soft_int <= wr_int_soft_int;
     else                            exc_soft_int <= exc_soft_int_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               exc_soft_int_ib <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               exc_soft_int_ib <= `FALSE;
     else if(active_wr && wr_int)    exc_soft_int_ib <= wr_int_soft_int_ib;
     else                            exc_soft_int_ib <= exc_soft_int_ib_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   exc_load <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   exc_load <= `FALSE;
     else                exc_load <= exception_start || interrupt_done;
 end
 
@@ -300,28 +325,28 @@ end
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   external <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   external <= 1'b0;
     else if(wr_exception_external_set)  external <= `TRUE;
     else if(wr_exception_finished)      external <= `FALSE;
     else                                external <= external_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   count <= 2'b0;
+always @(posedge clk) begin
+    if(rst)                   count <= 2'b0;
     else if(wr_exception_finished)      count <= 2'd0;
     else                                count <= count_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   last_type <= 2'b0;
+always @(posedge clk) begin
+    if(rst)   last_type <= 2'b0;
     else                last_type <= last_type_to_reg;
 end
 
 assign exception_eip_from_wr = wr_eip  - { 28'd0, wr_consumed };
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)      exc_eip <= 32'd0;
+always @(posedge clk) begin
+    if(rst)      exc_eip <= 32'd0;
     else if(active_wr)     exc_eip <= exception_eip_from_wr;
     else if(active_exe)    exc_eip <= exe_eip - { 28'd0, exe_consumed };
     else if(active_rd)     exc_eip <= rd_eip  - { 28'd0, rd_consumed };
@@ -329,16 +354,16 @@ always @(posedge clk or negedge rst_n) begin
     else                   exc_eip <= exc_eip_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)      trap_eip <= 32'd0;
+always @(posedge clk) begin
+    if(rst)      trap_eip <= 32'd0;
     else if(active_wr)     trap_eip <= wr_eip;
     else if(active_exe)    trap_eip <= exe_eip;
     else if(active_rd)     trap_eip <= rd_eip;
     else if(active_dec)    trap_eip <= dec_eip;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   shutdown <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   shutdown <= `FALSE;
     else                shutdown <= shutdown_to_reg;
 end
 
@@ -361,10 +386,6 @@ assign class_trap  = (vector == `EXCEPTION_BP) || (vector == `EXCEPTION_OF);
 
 assign class_abort = (vector == `EXCEPTION_MC);
 
-`define EXCEPTION_TYPE_BENIGN           2'd0
-`define EXCEPTION_TYPE_CONTRIBUTORY     2'd1
-`define EXCEPTION_TYPE_PAGE_FAULT       2'd2
-`define EXCEPTION_TYPE_DOUBLE_FAULT     2'd3
 
 assign exception_type =
     (vector == `EXCEPTION_DE) || (vector >= `EXCEPTION_TS && vector <= `EXCEPTION_GP)?  `EXCEPTION_TYPE_CONTRIBUTORY :
@@ -378,19 +399,19 @@ assign shutdown_start = count > 2'd2 || (count > 2'd0 && last_type == `EXCEPTION
 
 // interrupt_vector[7:0], interrupt_done; 
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               interrupt_done <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               interrupt_done <= `FALSE;
     else if(wr_interrupt_possible)  interrupt_done <= `TRUE;
     else                            interrupt_done <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           interrupt_load <= `FALSE;
+always @(posedge clk) begin
+    if(rst)           interrupt_load <= `FALSE;
     else                        interrupt_load <= interrupt_done;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               interrupt_string_in_progress <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                                               interrupt_string_in_progress <= `FALSE;
     else if(wr_interrupt_possible && wr_string_in_progress_final)   interrupt_string_in_progress <= `TRUE;
     else if(wr_interrupt_possible)                                  interrupt_string_in_progress <= `FALSE;
 end
diff --git a/rtl/ao486/global_regs.v b/rtl/ao486/global_regs.v
index e520b37..201bae9 100644
--- a/rtl/ao486/global_regs.v
+++ b/rtl/ao486/global_regs.v
@@ -28,7 +28,7 @@
 
 module global_regs(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               glob_param_1_set,
     input       [31:0]  glob_param_1_value,
@@ -76,38 +76,38 @@ assign glob_desc_2_limit = glob_descriptor_2[`DESC_BIT_G]? { glob_descriptor_2[5
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           glob_param_1 <= 32'd0;
+always @(posedge clk) begin
+    if(rst)           glob_param_1 <= 32'd0;
     else if(glob_param_1_set)   glob_param_1 <= glob_param_1_value;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           glob_param_2 <= 32'd0;
+always @(posedge clk) begin
+    if(rst)           glob_param_2 <= 32'd0;
     else if(glob_param_2_set)   glob_param_2 <= glob_param_2_value;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           glob_param_3 <= 32'd0;
+always @(posedge clk) begin
+    if(rst)           glob_param_3 <= 32'd0;
     else if(glob_param_3_set)   glob_param_3 <= glob_param_3_value;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           glob_param_4 <= 32'd0;
+always @(posedge clk) begin
+    if(rst)           glob_param_4 <= 32'd0;
     else if(glob_param_4_set)   glob_param_4 <= glob_param_4_value;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           glob_param_5 <= 32'd0;
+always @(posedge clk) begin
+    if(rst)           glob_param_5 <= 32'd0;
     else if(glob_param_5_set)   glob_param_5 <= glob_param_5_value;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               glob_descriptor <= 64'd0;
+always @(posedge clk) begin
+    if(rst)               glob_descriptor <= 64'd0;
     else if(glob_descriptor_set)    glob_descriptor <= glob_descriptor_value;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               glob_descriptor_2 <= 64'd0;
+always @(posedge clk) begin
+    if(rst)               glob_descriptor_2 <= 64'd0;
     else if(glob_descriptor_2_set)  glob_descriptor_2 <= glob_descriptor_2_value;
 end
 
diff --git a/rtl/ao486/memory/avalon_mem.v b/rtl/ao486/memory/avalon_mem.v
index b9d1821..789d566 100644
--- a/rtl/ao486/memory/avalon_mem.v
+++ b/rtl/ao486/memory/avalon_mem.v
@@ -31,7 +31,7 @@
 module avalon_mem(
     // global
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //RESP:
     input               writeburst_do,
diff --git a/rtl/ao486/memory/cache_data_ram.v b/rtl/ao486/memory/cache_data_ram.v
index 802a721..45a7fd3 100644
--- a/rtl/ao486/memory/cache_data_ram.v
+++ b/rtl/ao486/memory/cache_data_ram.v
@@ -28,7 +28,7 @@
 
 module cache_data_ram(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input [31:0]        address,
     
@@ -49,8 +49,8 @@ reg [7:0] last_address;
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   last_address <= 8'd0;
+always @(posedge clk) begin
+    if(rst)   last_address <= 8'd0;
     else if(read_do)    last_address <= address[11:4];
 end
 
diff --git a/rtl/ao486/memory/dcache.v b/rtl/ao486/memory/dcache.v
index c22ce33..98cbb56 100644
--- a/rtl/ao486/memory/dcache.v
+++ b/rtl/ao486/memory/dcache.v
@@ -31,7 +31,7 @@
 module dcache(
     // global
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //RESP:
     input               dcacheread_do,
@@ -109,18 +109,6 @@ module dcache(
 
 //------------------------------------------------------------------------------
 
-reg [31:0]  address;
-reg         cache_disable;
-reg [3:0]   length;
-
-reg         write_through;
-reg [31:0]  write_data;
-
-reg         is_write;
-reg [2:0]   state;
-
-//------------------------------------------------------------------------------
-
 localparam [2:0] STATE_IDLE          = 3'd0;
 localparam [2:0] STATE_READ_CHECK    = 3'd1;
 localparam [2:0] STATE_READ_BURST    = 3'd2;
@@ -128,87 +116,60 @@ localparam [2:0] STATE_WRITE_BACK    = 3'd3;
 localparam [2:0] STATE_READ_LINE     = 3'd4;
 localparam [2:0] STATE_WRITE_CHECK   = 3'd5;
 localparam [2:0] STATE_WRITE_THROUGH = 3'd6;
-
-//------------------------------------------------------------------------------
-
+reg [31:0]  address;
+reg         cache_disable;
+reg [3:0]   length;
+reg         write_through;
+reg [31:0]  write_data;
+reg         is_write;
+reg [2:0]   state;
 wire        wbinvdread_do;
 wire [7:0]  wbinvdread_address;
-
 wire            dcache_writeline_do;
 wire [31:0]     dcache_writeline_address;
 wire [127:0]    dcache_writeline_line;
-
-//------------------------------------------------------------------------------
-
-assign writeline_do         = dcache_writeline_do || control_ram_writeline_do;
-assign writeline_address    = (dcache_writeline_do)? dcache_writeline_address : control_ram_writeline_address;
-assign writeline_line       = (dcache_writeline_do)? dcache_writeline_line    : control_ram_writeline_line;
-
-assign dcache_busy = state != STATE_IDLE;
-
-//------------------------------------------------------------------------------
-
 wire [31:0] control_ram_address;
 wire        control_ram_read_do;
 wire        control_ram_write_do;
 wire [10:0] control_ram_data;
 wire [10:0] control_ram_q;
-
 wire            control_ram_writeline_do;
 wire [31:0]     control_ram_writeline_address;
 wire [127:0]    control_ram_writeline_line;
-
-//------------------------------------------------------------------------------
-
 wire         matched;
 wire [1:0]   matched_index;
 wire [127:0] matched_data_line;
-
 wire [1:0]   plru_index;
 wire [147:0] plru_data_line;
-
 wire [10:0]  control_after_match;
 wire [10:0]  control_after_line_read;
 wire [10:0]  control_after_write_to_existing;
 wire [10:0]  control_after_write_to_new;
-
 wire         writeback_needed;
-
-//------------------------------------------------------------------------------
-
 wire [63:0] read_from_line;
 wire [1:0]  read_burst_dword_length;
 wire [3:0]  read_burst_byte_length;
 wire [63:0] read_from_burst;
-
-//------------------------------------------------------------------------------
-
 wire [127:0] line_merged;
 wire [1:0]   write_burst_dword_length;
 wire [3:0]   write_burst_byteenable_0;
 wire [3:0]   write_burst_byteenable_1;
 wire [55:0]  write_burst_data;
-
-//------------------------------------------------------------------------------
-
 wire            data_ram0_read_do;
 wire [31:0]     data_ram0_address;
 wire            data_ram0_write_do;
 wire [127:0]    data_ram0_data;
 wire [147:0]    data_ram0_q;
-
 wire            data_ram1_read_do;
 wire [31:0]     data_ram1_address;
 wire            data_ram1_write_do;
 wire [127:0]    data_ram1_data;
 wire [147:0]    data_ram1_q;
-
 wire            data_ram2_read_do;
 wire [31:0]     data_ram2_address;
 wire            data_ram2_write_do;
 wire [127:0]    data_ram2_data;
 wire [147:0]    data_ram2_q;
-
 wire            data_ram3_read_do;
 wire [31:0]     data_ram3_address;
 wire            data_ram3_write_do;
@@ -217,6 +178,43 @@ wire [147:0]    data_ram3_q;
 
 //------------------------------------------------------------------------------
 
+
+//------------------------------------------------------------------------------
+
+
+
+//------------------------------------------------------------------------------
+
+assign writeline_do         = dcache_writeline_do || control_ram_writeline_do;
+assign writeline_address    = (dcache_writeline_do)? dcache_writeline_address : control_ram_writeline_address;
+assign writeline_line       = (dcache_writeline_do)? dcache_writeline_line    : control_ram_writeline_line;
+
+assign dcache_busy = state != STATE_IDLE;
+
+//------------------------------------------------------------------------------
+
+
+
+//------------------------------------------------------------------------------
+
+
+
+
+
+//------------------------------------------------------------------------------
+
+
+//------------------------------------------------------------------------------
+
+
+//------------------------------------------------------------------------------
+
+
+
+
+
+//------------------------------------------------------------------------------
+
 dcache_matched dcache_matched_inst(
     .address    (address),  //input [31:0]
     
@@ -274,7 +272,7 @@ dcache_write dcache_write_inst(
 
 dcache_control_ram dcache_control_ram_inst(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
     
     .address        (control_ram_address),      //input [31:0]
     .data           (control_ram_data),         //input [10:0]
@@ -318,7 +316,7 @@ dcache_control_ram dcache_control_ram_inst(
 
 cache_data_ram cache_data_ram0_inst(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
                                        
     .read_do        (data_ram0_read_do),
     .address        (data_ram0_address),
@@ -332,7 +330,7 @@ cache_data_ram cache_data_ram0_inst(
 
 cache_data_ram cache_data_ram1_inst(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
                                        
     .read_do    (data_ram1_read_do),
     .address    (data_ram1_address),
@@ -346,7 +344,7 @@ cache_data_ram cache_data_ram1_inst(
 
 cache_data_ram cache_data_ram2_inst(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
                                        
     .read_do        (data_ram2_read_do),
     .address        (data_ram2_address),
@@ -358,7 +356,7 @@ cache_data_ram cache_data_ram2_inst(
 
 cache_data_ram cache_data_ram3_inst(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
                                        
     .read_do        (data_ram3_read_do),
     .address        (data_ram3_address),
diff --git a/rtl/ao486/memory/dcache_control_ram.v b/rtl/ao486/memory/dcache_control_ram.v
index 90368ff..d16dc40 100644
--- a/rtl/ao486/memory/dcache_control_ram.v
+++ b/rtl/ao486/memory/dcache_control_ram.v
@@ -30,7 +30,7 @@
 
 module dcache_control_ram(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input [31:0]        address,
     
@@ -78,32 +78,36 @@ module dcache_control_ram(
 
 //------------------------------------------------------------------------------
 
+localparam [1:0] STATE_IDLE   = 2'd0;
+localparam [1:0] STATE_INVD   = 2'd1;
+localparam [1:0] STATE_WBINVD = 2'd2;
 reg [1:0]   state;
-
 reg [7:0]   last_address;
-
 reg         after_invalidate;
-
 reg         init_done;
-
 reg [7:0]   invd_counter;
-
 reg [9:0]   wbinvd_counter;
+wire [10:0]     ram_q_a;
+wire            start_wbinvd;
+wire            wbinvd_write_control;
+wire [9:0]      wbinvd_counter_next;
+wire            wbinvd_valid;
+wire [147:0]    wbinvd_line;
+wire _unused_ok;
+
+
+
+
+
 
 
 //------------------------------------------------------------------------------
 
-wire [10:0]     ram_q_a;
 
-wire            start_wbinvd;
 
-wire            wbinvd_write_control;
 
-wire [9:0]      wbinvd_counter_next;
 
-wire            wbinvd_valid;
 
-wire [147:0]    wbinvd_line;
 
 //------------------------------------------------------------------------------
 
@@ -127,8 +131,8 @@ assign wbinvd_line =
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   last_address <= 8'd0;
+always @(posedge clk) begin
+    if(rst)   last_address <= 8'd0;
     else if(read_do)    last_address <= address[11:4];
 end
 
@@ -137,9 +141,6 @@ end
 
 //------------------------------------------------------------------------------
 
-localparam [1:0] STATE_IDLE   = 2'd0;
-localparam [1:0] STATE_INVD   = 2'd1;
-localparam [1:0] STATE_WBINVD = 2'd2;
 
 //------------------------------------------------------------------------------
 
@@ -168,7 +169,7 @@ dcache_control_ram_inst(
 //------------------------------------------------------------------------------
 
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, address[31:12], address[3:0], 1'b0 };
+ assign _unused_ok = &{ 1'b0, address[31:12], address[3:0], 1'b0 };
 // synthesis translate_on
 
 //------------------------------------------------------------------------------
diff --git a/rtl/ao486/memory/dcache_to_icache_fifo.v b/rtl/ao486/memory/dcache_to_icache_fifo.v
index 084633a..cb94b1b 100644
--- a/rtl/ao486/memory/dcache_to_icache_fifo.v
+++ b/rtl/ao486/memory/dcache_to_icache_fifo.v
@@ -28,7 +28,7 @@
 
 module dcache_to_icache_fifo(
     input           clk,
-    input           rst_n,
+    input           rst,
     
     //RESP:
     input           dcachetoicache_write_do,
@@ -53,7 +53,7 @@ simple_fifo #(
 )
 dcache_to_icache_fifo_inst (
     .clk        (clk),      //input
-    .rst_n      (rst_n),    //input
+    .rst      (rst),    //input
     .sclr       (1'b0),     //input
     
     .rdreq      (dcachetoicache_accept_do),             //input
diff --git a/rtl/ao486/memory/icache.v b/rtl/ao486/memory/icache.v
index 586028f..0bc2f9c 100644
--- a/rtl/ao486/memory/icache.v
+++ b/rtl/ao486/memory/icache.v
@@ -30,7 +30,7 @@
 
 module icache(
     input           clk,
-    input           rst_n,
+    input           rst,
     
     //RESP:
     input           pr_reset,
@@ -77,88 +77,92 @@ module icache(
 
 //------------------------------------------------------------------------------
 
-//------------------------------------------------------------------------------
-
+localparam [1:0] STATE_IDLE             = 2'd0;
+localparam [1:0] STATE_INVALIDATE_WRITE = 2'd1;
+localparam [1:0] STATE_CHECK            = 2'd2;
+localparam [1:0] STATE_READ             = 2'd3;
 reg [1:0]   state;
 reg [31:0]  address;
 reg [4:0]   length;
 reg         cache_disable;
 reg [11:0]  partial_length;
 reg         reset_waiting;
-
-//------------------------------------------------------------------------------
-
 wire [4:0] partial_length_current;
-
-//------------------------------------------------------------------------------
-
-localparam [1:0] STATE_IDLE             = 2'd0;
-localparam [1:0] STATE_INVALIDATE_WRITE = 2'd1;
-localparam [1:0] STATE_CHECK            = 2'd2;
-localparam [1:0] STATE_READ             = 2'd3;
-
-//------------------------------------------------------------------------------
-
-//MIN(partial_length, length_saved)
-assign partial_length_current =
-    ({ 2'b0, partial_length[2:0] } > length)? length : { 2'b0, partial_length[2:0] };
-    
-
-//------------------------------------------------------------------------------
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           reset_waiting <= `FALSE;
-    else if(pr_reset && state != STATE_IDLE)    reset_waiting <= `TRUE;
-    else if(state == STATE_IDLE)                reset_waiting <= `FALSE;
-end
-
-//------------------------------------------------------------------------------
-
 wire [127:0] matched_data_line;
 wire [6:0]   control_after_invalidate_write;
 wire [6:0]   control_after_match;
 wire [6:0]   control_after_line_read;
 wire         matched;
 wire [1:0]   plru_index;
-
-//------------------------------------------------------------------------------
-
 wire [11:0]     length_burst;
 wire [11:0]     length_line;
 wire [135:0]    prefetch_line;
 wire [135:0]    prefetch_partial;
-
-//------------------------------------------------------------------------------
-
 wire        control_ram_read_do;
 wire [31:0] control_ram_address;
 wire        control_ram_write_do;
 wire [6:0]  control_ram_data;
 wire [6:0]  control_ram_q;
-
 wire            data_ram0_read_do;
 wire [31:0]     data_ram0_address;
 wire            data_ram0_write_do;
 wire [127:0]    data_ram0_data;
 wire [147:0]    data_ram0_q;
-
 wire            data_ram1_read_do;
 wire [31:0]     data_ram1_address;
 wire            data_ram1_write_do;
 wire [127:0]    data_ram1_data;
 wire [147:0]    data_ram1_q;
-
 wire            data_ram2_read_do;
 wire [31:0]     data_ram2_address;
 wire            data_ram2_write_do;
 wire [127:0]    data_ram2_data;
 wire [147:0]    data_ram2_q;
-
 wire            data_ram3_read_do;
 wire [31:0]     data_ram3_address;
 wire            data_ram3_write_do;
 wire [127:0]    data_ram3_data;
 wire [147:0]    data_ram3_q;
+   
+//------------------------------------------------------------------------------
+
+
+//------------------------------------------------------------------------------
+
+
+
+
+
+
+
+
+   
+//------------------------------------------------------------------------------
+
+
+//------------------------------------------------------------------------------
+
+//MIN(partial_length, length_saved)
+assign partial_length_current =
+    ({ 2'b0, partial_length[2:0] } > length)? length : { 2'b0, partial_length[2:0] };
+    
+
+//------------------------------------------------------------------------------
+
+always @(posedge clk) begin
+    if(rst)                           reset_waiting <= `FALSE;
+    else if(pr_reset && state != STATE_IDLE)    reset_waiting <= `TRUE;
+    else if(state == STATE_IDLE)                reset_waiting <= `FALSE;
+end
+
+//------------------------------------------------------------------------------
+
+   
+//------------------------------------------------------------------------------
+
+   
+//------------------------------------------------------------------------------
+
 
 //------------------------------------------------------------------------------
 
@@ -205,7 +209,7 @@ icache_read icache_read_inst(
     
 icache_control_ram icache_control_ram_inst(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
     
     .address        (control_ram_address),  //input [31:0]
                                            
@@ -227,7 +231,7 @@ icache_control_ram icache_control_ram_inst(
 
 cache_data_ram cache_data_ram0_inst(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
     
     .address        (data_ram0_address),        //input [31:0]
     
@@ -244,7 +248,7 @@ cache_data_ram cache_data_ram0_inst(
 
 cache_data_ram cache_data_ram1_inst(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
     
     .address        (data_ram1_address),        //input [31:0]
     
@@ -261,7 +265,7 @@ cache_data_ram cache_data_ram1_inst(
 
 cache_data_ram cache_data_ram2_inst(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
     
     .address        (data_ram2_address),        //input [31:0]
     
@@ -278,7 +282,7 @@ cache_data_ram cache_data_ram2_inst(
 
 cache_data_ram cache_data_ram3_inst(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
     
     .address        (data_ram3_address),        //input [31:0]
     
diff --git a/rtl/ao486/memory/icache_control_ram.v b/rtl/ao486/memory/icache_control_ram.v
index a6fa086..a8b2299 100644
--- a/rtl/ao486/memory/icache_control_ram.v
+++ b/rtl/ao486/memory/icache_control_ram.v
@@ -30,7 +30,7 @@
 
 module icache_control_ram(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input [31:0]        address,
     
@@ -73,8 +73,8 @@ assign q = (~(init_done) || state == STATE_INVD || after_invalidate)? 7'd0 : ram
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   last_address <= 8'd0;
+always @(posedge clk) begin
+    if(rst)   last_address <= 8'd0;
     else if(read_do)    last_address <= address[11:4];
 end
 
diff --git a/rtl/ao486/memory/link_dcacheread.v b/rtl/ao486/memory/link_dcacheread.v
index 5ed24fb..c0e3113 100644
--- a/rtl/ao486/memory/link_dcacheread.v
+++ b/rtl/ao486/memory/link_dcacheread.v
@@ -30,7 +30,7 @@
 
 module link_dcacheread(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     // dcacheread REQ
     input               req_dcacheread_do,
@@ -68,15 +68,15 @@ assign save  = req_dcacheread_do && ~(resp_dcacheread_done);
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               current_do <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               current_do <= `FALSE;
     else if(save)                   current_do <= req_dcacheread_do;
     else if(resp_dcacheread_done)   current_do <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) length        <= 4'd0;  else if(save) length        <= req_dcacheread_length;        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cache_disable <= 1'b0;  else if(save) cache_disable <= req_dcacheread_cache_disable; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) address       <= 32'd0; else if(save) address       <= req_dcacheread_address;       end
+always @(posedge clk) begin if(rst) length        <= 4'd0;  else if(save) length        <= req_dcacheread_length;        end
+always @(posedge clk) begin if(rst) cache_disable <= 1'b0;  else if(save) cache_disable <= req_dcacheread_cache_disable; end
+always @(posedge clk) begin if(rst) address       <= 32'd0; else if(save) address       <= req_dcacheread_address;       end
 
 //------------------------------------------------------------------------------
 
diff --git a/rtl/ao486/memory/link_dcachewrite.v b/rtl/ao486/memory/link_dcachewrite.v
index 77653a0..f97ee56 100644
--- a/rtl/ao486/memory/link_dcachewrite.v
+++ b/rtl/ao486/memory/link_dcachewrite.v
@@ -31,7 +31,7 @@
 
 module link_dcachewrite(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     // dcachewrite REQ
     input               req_dcachewrite_do,
@@ -75,20 +75,20 @@ assign save  = req_dcachewrite_do && ~(resp_dcachewrite_done) && ~(req_dcachewri
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               current_do <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               current_do <= `FALSE;
     else if(save)                   current_do <= req_dcachewrite_do;
     else if(resp_dcachewrite_done)  current_do <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) length        <= 3'd0;  else if(save) length        <= req_dcachewrite_length;        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cache_disable <= 1'b0;  else if(save) cache_disable <= req_dcachewrite_cache_disable; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) address       <= 32'd0; else if(save) address       <= req_dcachewrite_address;       end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) write_through <= 1'b0;  else if(save) write_through <= req_dcachewrite_write_through; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) data          <= 32'd0; else if(save) data          <= req_dcachewrite_data;          end
+always @(posedge clk) begin if(rst) length        <= 3'd0;  else if(save) length        <= req_dcachewrite_length;        end
+always @(posedge clk) begin if(rst) cache_disable <= 1'b0;  else if(save) cache_disable <= req_dcachewrite_cache_disable; end
+always @(posedge clk) begin if(rst) address       <= 32'd0; else if(save) address       <= req_dcachewrite_address;       end
+always @(posedge clk) begin if(rst) write_through <= 1'b0;  else if(save) write_through <= req_dcachewrite_write_through; end
+always @(posedge clk) begin if(rst) data          <= 32'd0; else if(save) data          <= req_dcachewrite_data;          end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               done_delayed <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               done_delayed <= `FALSE;
     else                            done_delayed <= resp_dcachewrite_done;
 end
 
diff --git a/rtl/ao486/memory/link_readburst.v b/rtl/ao486/memory/link_readburst.v
index 841384f..a6d0e7d 100644
--- a/rtl/ao486/memory/link_readburst.v
+++ b/rtl/ao486/memory/link_readburst.v
@@ -30,7 +30,7 @@
 
 module link_readburst(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     // readburst REQ
     input               req_readburst_do,
@@ -68,15 +68,15 @@ assign save  = req_readburst_do && ~(resp_readburst_done);
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               current_do <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               current_do <= `FALSE;
     else if(save)                   current_do <= req_readburst_do;
     else if(resp_readburst_done)    current_do <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) address      <= 32'd0; else if(save) address      <= req_readburst_address;      end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dword_length <= 2'd0;  else if(save) dword_length <= req_readburst_dword_length; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) byte_length  <= 4'd0;  else if(save) byte_length  <= req_readburst_byte_length;  end
+always @(posedge clk) begin if(rst) address      <= 32'd0; else if(save) address      <= req_readburst_address;      end
+always @(posedge clk) begin if(rst) dword_length <= 2'd0;  else if(save) dword_length <= req_readburst_dword_length; end
+always @(posedge clk) begin if(rst) byte_length  <= 4'd0;  else if(save) byte_length  <= req_readburst_byte_length;  end
 
 //------------------------------------------------------------------------------
 
diff --git a/rtl/ao486/memory/link_readcode.v b/rtl/ao486/memory/link_readcode.v
index 6e0a23e..e9809f6 100644
--- a/rtl/ao486/memory/link_readcode.v
+++ b/rtl/ao486/memory/link_readcode.v
@@ -30,7 +30,7 @@
 
 module link_readcode(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     // readcode REQ
     input               req_readcode_do,
@@ -66,13 +66,13 @@ assign save  = req_readcode_do && ~(resp_readcode_done);
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               current_do <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               current_do <= `FALSE;
     else if(save)                   current_do <= req_readcode_do;
     else if(resp_readcode_done)     current_do <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) address <= 32'd0; else if(save) address <= req_readcode_address; end
+always @(posedge clk) begin if(rst) address <= 32'd0; else if(save) address <= req_readcode_address; end
 
 //------------------------------------------------------------------------------
 
diff --git a/rtl/ao486/memory/link_readline.v b/rtl/ao486/memory/link_readline.v
index 7804f46..7926e9b 100644
--- a/rtl/ao486/memory/link_readline.v
+++ b/rtl/ao486/memory/link_readline.v
@@ -30,7 +30,7 @@
 
 module link_readline(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     // readline REQ
     input               req_readline_do,
@@ -62,13 +62,13 @@ assign save  = req_readline_do && ~(resp_readline_done);
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               current_do <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               current_do <= `FALSE;
     else if(save)                   current_do <= req_readline_do;
     else if(resp_readline_done)     current_do <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) address <= 32'd0; else if(save) address <= req_readline_address;      end
+always @(posedge clk) begin if(rst) address <= 32'd0; else if(save) address <= req_readline_address;      end
 
 //------------------------------------------------------------------------------
 
diff --git a/rtl/ao486/memory/link_writeburst.v b/rtl/ao486/memory/link_writeburst.v
index d770342..ed9090c 100644
--- a/rtl/ao486/memory/link_writeburst.v
+++ b/rtl/ao486/memory/link_writeburst.v
@@ -31,7 +31,7 @@
 
 module link_writeburst(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     // writeburst REQ
     input               req_writeburst_do,
@@ -75,20 +75,20 @@ assign save  = req_writeburst_do && ~(resp_writeburst_done) && ~(req_writeburst_
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               current_do <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               current_do <= `FALSE;
     else if(save)                   current_do <= req_writeburst_do;
     else if(resp_writeburst_done)   current_do <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) address      <= 32'd0; else if(save) address      <= req_writeburst_address;      end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dword_length <= 2'd0;  else if(save) dword_length <= req_writeburst_dword_length; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) byteenable_0 <= 4'd0;  else if(save) byteenable_0 <= req_writeburst_byteenable_0; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) byteenable_1 <= 4'd0;  else if(save) byteenable_1 <= req_writeburst_byteenable_1; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) data         <= 56'd0; else if(save) data         <= req_writeburst_data;         end
+always @(posedge clk) begin if(rst) address      <= 32'd0; else if(save) address      <= req_writeburst_address;      end
+always @(posedge clk) begin if(rst) dword_length <= 2'd0;  else if(save) dword_length <= req_writeburst_dword_length; end
+always @(posedge clk) begin if(rst) byteenable_0 <= 4'd0;  else if(save) byteenable_0 <= req_writeburst_byteenable_0; end
+always @(posedge clk) begin if(rst) byteenable_1 <= 4'd0;  else if(save) byteenable_1 <= req_writeburst_byteenable_1; end
+always @(posedge clk) begin if(rst) data         <= 56'd0; else if(save) data         <= req_writeburst_data;         end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               done_delayed <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               done_delayed <= `FALSE;
     else                            done_delayed <= resp_writeburst_done;
 end
 
diff --git a/rtl/ao486/memory/link_writeline.v b/rtl/ao486/memory/link_writeline.v
index ff862db..b3bffc1 100644
--- a/rtl/ao486/memory/link_writeline.v
+++ b/rtl/ao486/memory/link_writeline.v
@@ -31,7 +31,7 @@
 
 module link_writeline(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     // writeline REQ
     input               req_writeline_do,
@@ -66,17 +66,17 @@ assign save  = req_writeline_do && ~(resp_writeline_done) && ~(req_writeline_don
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               current_do <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               current_do <= `FALSE;
     else if(save)                   current_do <= req_writeline_do;
     else if(resp_writeline_done)    current_do <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) address      <= 32'd0;  else if(save) address <= req_writeline_address; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) line         <= 128'd0; else if(save) line    <= req_writeline_line;    end
+always @(posedge clk) begin if(rst) address      <= 32'd0;  else if(save) address <= req_writeline_address; end
+always @(posedge clk) begin if(rst) line         <= 128'd0; else if(save) line    <= req_writeline_line;    end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               done_delayed <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               done_delayed <= `FALSE;
     else                            done_delayed <= resp_writeline_done;
 end
 
diff --git a/rtl/ao486/memory/memory.v b/rtl/ao486/memory/memory.v
index ef88334..ff84a1e 100644
--- a/rtl/ao486/memory/memory.v
+++ b/rtl/ao486/memory/memory.v
@@ -28,7 +28,7 @@
 
 module memory(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //REQ:
     input               read_do,
@@ -160,7 +160,6 @@ wire [1:0]  req_writeburst_dword_length;
 wire [3:0]  req_writeburst_byteenable_0;
 wire [3:0]  req_writeburst_byteenable_1;
 wire [55:0] req_writeburst_data;
-
 wire        resp_writeburst_do;
 wire        resp_writeburst_done;
 wire [31:0] resp_writeburst_address;
@@ -168,10 +167,126 @@ wire [1:0]  resp_writeburst_dword_length;
 wire [3:0]  resp_writeburst_byteenable_0;
 wire [3:0]  resp_writeburst_byteenable_1;
 wire [55:0] resp_writeburst_data;
+wire         req_writeline_do;
+wire         req_writeline_done;
+wire [31:0]  req_writeline_address;
+wire [127:0] req_writeline_line;
+wire         resp_writeline_do;
+wire         resp_writeline_done;
+wire [31:0]  resp_writeline_address;
+wire [127:0] resp_writeline_line;
+wire         req_readburst_do;
+wire         req_readburst_done;
+wire [31:0]  req_readburst_address;
+wire [1:0]   req_readburst_dword_length;
+wire [3:0]   req_readburst_byte_length;
+wire [95:0]  req_readburst_data;
+wire         resp_readburst_do;
+wire         resp_readburst_done;
+wire [31:0]  resp_readburst_address;
+wire [1:0]   resp_readburst_dword_length;
+wire [3:0]   resp_readburst_byte_length;
+wire [95:0]  resp_readburst_data;
+wire         req_readline_do;
+wire         req_readline_done;
+wire [31:0]  req_readline_address;
+wire [127:0] req_readline_line;
+wire         resp_readline_do;
+wire         resp_readline_done;
+wire [31:0]  resp_readline_address;
+wire [127:0] resp_readline_line;
+wire         req_readcode_do;
+wire         req_readcode_done;
+wire [31:0]  req_readcode_address;
+wire [127:0] req_readcode_line;
+wire [31:0]  req_readcode_partial;
+wire         req_readcode_partial_done;
+wire         resp_readcode_do;
+wire         resp_readcode_done;
+wire [31:0]  resp_readcode_address;
+wire [127:0] resp_readcode_line;
+wire [31:0]  resp_readcode_partial;
+wire         resp_readcode_partial_done;
+wire             req_dcacheread_do;
+wire             req_dcacheread_done;
+wire [3:0]       req_dcacheread_length;
+wire             req_dcacheread_cache_disable;
+wire [31:0]      req_dcacheread_address;
+wire [63:0]      req_dcacheread_data;
+wire             resp_dcacheread_do;
+wire             resp_dcacheread_done;
+wire [3:0]       resp_dcacheread_length;
+wire             resp_dcacheread_cache_disable;
+wire [31:0]      resp_dcacheread_address;
+wire [63:0]      resp_dcacheread_data;
+wire               req_dcachewrite_do;
+wire               req_dcachewrite_done;
+wire   [2:0]       req_dcachewrite_length;
+wire               req_dcachewrite_cache_disable;
+wire   [31:0]      req_dcachewrite_address;
+wire               req_dcachewrite_write_through;
+wire   [31:0]      req_dcachewrite_data;
+wire              resp_dcachewrite_do;
+wire              resp_dcachewrite_done;
+wire  [2:0]       resp_dcachewrite_length;
+wire              resp_dcachewrite_cache_disable;
+wire  [31:0]      resp_dcachewrite_address;
+wire              resp_dcachewrite_write_through;
+wire  [31:0]      resp_dcachewrite_data;
+wire         tlbread_do;
+wire         tlbread_done;
+wire         tlbread_page_fault;
+wire         tlbread_ac_fault;
+wire         tlbread_retry;
+wire [1:0]   tlbread_cpl;
+wire [31:0]  tlbread_address;
+wire [3:0]   tlbread_length;
+wire [3:0]   tlbread_length_full;
+wire         tlbread_lock;
+wire         tlbread_rmw;
+wire [63:0]  tlbread_data;
+wire         tlbwrite_do;
+wire         tlbwrite_done;
+wire         tlbwrite_page_fault;
+wire         tlbwrite_ac_fault;
+wire [1:0]   tlbwrite_cpl;
+wire [31:0]  tlbwrite_address;
+wire [2:0]   tlbwrite_length;
+wire [2:0]   tlbwrite_length_full;
+wire         tlbwrite_lock;
+wire         tlbwrite_rmw;
+wire [31:0]  tlbwrite_data;
+wire        dcachetoicache_write_do;
+wire [31:0] dcachetoicache_write_address;
+wire        dcachetoicache_accept_do;
+wire [31:0] dcachetoicache_accept_address;
+wire        dcachetoicache_accept_empty;
+wire        icacheread_do;
+wire [31:0] icacheread_address;
+wire [4:0]  icacheread_length; // takes into account: page size and cs segment limit
+wire        icacheread_cache_disable;
+wire            prefetchfifo_write_do;
+wire [135:0]    prefetchfifo_write_data;
+wire            prefetched_do;
+wire [4:0]      prefetched_length;
+wire [31:0]     prefetch_address;
+wire [4:0]      prefetch_length;
+wire            prefetch_su;
+wire            prefetchfifo_signal_limit_do;
+wire            prefetchfifo_signal_pf_do;
+wire [4:0]      prefetchfifo_used;
+wire            tlbcoderequest_do;
+wire [31:0]     tlbcoderequest_address;
+wire            tlbcoderequest_su;
+wire            tlbcode_do;
+wire [31:0]     tlbcode_linear;
+wire [31:0]     tlbcode_physical;
+wire            tlbcode_cache_disable;
+
 
 link_writeburst link_writeburst_inst(
     .clk                            (clk),
-    .rst_n                          (rst_n),
+    .rst                          (rst),
     
     // writeburst REQ
     .req_writeburst_do              (req_writeburst_do),            //input
@@ -196,19 +311,11 @@ link_writeburst link_writeburst_inst(
 
 //------------------------------------------------------------------------------
 
-wire         req_writeline_do;
-wire         req_writeline_done;
-wire [31:0]  req_writeline_address;
-wire [127:0] req_writeline_line;
     
-wire         resp_writeline_do;
-wire         resp_writeline_done;
-wire [31:0]  resp_writeline_address;
-wire [127:0] resp_writeline_line;
 
 link_writeline link_writeline_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     // writeline REQ
     .req_writeline_do       (req_writeline_do),         //input
@@ -227,23 +334,11 @@ link_writeline link_writeline_inst(
 
 //------------------------------------------------------------------------------
 
-wire         req_readburst_do;
-wire         req_readburst_done;
-wire [31:0]  req_readburst_address;
-wire [1:0]   req_readburst_dword_length;
-wire [3:0]   req_readburst_byte_length;
-wire [95:0]  req_readburst_data;
 
-wire         resp_readburst_do;
-wire         resp_readburst_done;
-wire [31:0]  resp_readburst_address;
-wire [1:0]   resp_readburst_dword_length;
-wire [3:0]   resp_readburst_byte_length;
-wire [95:0]  resp_readburst_data;
 
 link_readburst link_readburst_inst(
     .clk                    (clk),
-    .rst_n                  (rst_n),
+    .rst                  (rst),
     
     // readburst REQ
     .req_readburst_do               (req_readburst_do),             //input
@@ -267,19 +362,11 @@ link_readburst link_readburst_inst(
 //------------------------------------------------------------------------------
 
 
-wire         req_readline_do;
-wire         req_readline_done;
-wire [31:0]  req_readline_address;
-wire [127:0] req_readline_line;
     
-wire         resp_readline_do;
-wire         resp_readline_done;
-wire [31:0]  resp_readline_address;
-wire [127:0] resp_readline_line;
 
 link_readline link_readline_inst(
     .clk                    (clk),
-    .rst_n                  (rst_n),
+    .rst                  (rst),
     
     // readline REQ
     .req_readline_do        (req_readline_do),      //input
@@ -298,23 +385,11 @@ link_readline link_readline_inst(
 
 //------------------------------------------------------------------------------
 
-wire         req_readcode_do;
-wire         req_readcode_done;
-wire [31:0]  req_readcode_address;
-wire [127:0] req_readcode_line;
-wire [31:0]  req_readcode_partial;
-wire         req_readcode_partial_done;
     
-wire         resp_readcode_do;
-wire         resp_readcode_done;
-wire [31:0]  resp_readcode_address;
-wire [127:0] resp_readcode_line;
-wire [31:0]  resp_readcode_partial;
-wire         resp_readcode_partial_done;
 
 link_readcode link_readcode_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     // readcode REQ
     .req_readcode_do                (req_readcode_do),            //input
@@ -337,23 +412,11 @@ link_readcode link_readcode_inst(
 
 //------------------------------------------------------------------------------
 
-wire             req_dcacheread_do;
-wire             req_dcacheread_done;
-wire [3:0]       req_dcacheread_length;
-wire             req_dcacheread_cache_disable;
-wire [31:0]      req_dcacheread_address;
-wire [63:0]      req_dcacheread_data;
 
-wire             resp_dcacheread_do;
-wire             resp_dcacheread_done;
-wire [3:0]       resp_dcacheread_length;
-wire             resp_dcacheread_cache_disable;
-wire [31:0]      resp_dcacheread_address;
-wire [63:0]      resp_dcacheread_data;
 
 link_dcacheread link_dcacheread_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     // dcacheread REQ
     .req_dcacheread_do                  (req_dcacheread_do),              //input
@@ -376,25 +439,11 @@ link_dcacheread link_dcacheread_inst(
 
 //------------------------------------------------------------------------------
 
-wire               req_dcachewrite_do;
-wire               req_dcachewrite_done;
-wire   [2:0]       req_dcachewrite_length;
-wire               req_dcachewrite_cache_disable;
-wire   [31:0]      req_dcachewrite_address;
-wire               req_dcachewrite_write_through;
-wire   [31:0]      req_dcachewrite_data;
 
-wire              resp_dcachewrite_do;
-wire              resp_dcachewrite_done;
-wire  [2:0]       resp_dcachewrite_length;
-wire              resp_dcachewrite_cache_disable;
-wire  [31:0]      resp_dcachewrite_address;
-wire              resp_dcachewrite_write_through;
-wire  [31:0]      resp_dcachewrite_data;
 
 link_dcachewrite link_dcachewrite_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     // dcachewrite REQ
     .req_dcachewrite_do                 (req_dcachewrite_do),             //input
@@ -419,88 +468,39 @@ link_dcachewrite link_dcachewrite_inst(
 
 //------------------------------------------------------------------------------
 
-wire         tlbread_do;
-wire         tlbread_done;
-wire         tlbread_page_fault;
-wire         tlbread_ac_fault;
-wire         tlbread_retry;
 
-wire [1:0]   tlbread_cpl;
-wire [31:0]  tlbread_address;
-wire [3:0]   tlbread_length;
-wire [3:0]   tlbread_length_full;
-wire         tlbread_lock;
-wire         tlbread_rmw;
-wire [63:0]  tlbread_data;
 
 
 //------------------------------------------------------------------------------
 
-wire         tlbwrite_do;
-wire         tlbwrite_done;
-wire         tlbwrite_page_fault;
-wire         tlbwrite_ac_fault;
 
-wire [1:0]   tlbwrite_cpl;
-wire [31:0]  tlbwrite_address;
-wire [2:0]   tlbwrite_length;
-wire [2:0]   tlbwrite_length_full;
-wire         tlbwrite_lock;
-wire         tlbwrite_rmw;
-wire [31:0]  tlbwrite_data;
 
 //------------------------------------------------------------------------------
 
-wire        dcachetoicache_write_do;
-wire [31:0] dcachetoicache_write_address;
 
 //------------------------------------------------------------------------------
 
-wire        dcachetoicache_accept_do;
-wire [31:0] dcachetoicache_accept_address;
-wire        dcachetoicache_accept_empty;
 
 //------------------------------------------------------------------------------
 
-wire        icacheread_do;
-wire [31:0] icacheread_address;
-wire [4:0]  icacheread_length; // takes into account: page size and cs segment limit
-wire        icacheread_cache_disable;
 
 //------------------------------------------------------------------------------
 
-wire            prefetchfifo_write_do;
-wire [135:0]    prefetchfifo_write_data;
 
 //------------------------------------------------------------------------------
 
-wire            prefetched_do;
-wire [4:0]      prefetched_length;
 
 //------------------------------------------------------------------------------
 
-wire [31:0]     prefetch_address;
-wire [4:0]      prefetch_length;
-wire            prefetch_su;
 
 //------------------------------------------------------------------------------
 
-wire            prefetchfifo_signal_limit_do;
-wire            prefetchfifo_signal_pf_do;
-wire [4:0]      prefetchfifo_used;
 
 //------------------------------------------------------------------------------
 
-wire            tlbcoderequest_do;
-wire [31:0]     tlbcoderequest_address;
-wire            tlbcoderequest_su;
 
 //------------------------------------------------------------------------------
 
-wire            tlbcode_do;
-wire [31:0]     tlbcode_linear;
-wire [31:0]     tlbcode_physical;
-wire            tlbcode_cache_disable;
 
 //------------------------------------------------------------------------------
 
@@ -509,7 +509,7 @@ wire            tlbcode_cache_disable;
 avalon_mem avalon_mem_inst(
     // global
     .clk                        (clk),
-    .rst_n                      (rst_n),
+    .rst                      (rst),
     
     //RESP:
     .writeburst_do              (resp_writeburst_do),           //input
@@ -576,7 +576,7 @@ avalon_mem avalon_mem_inst(
 dcache dcache_inst(
     // global
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     //RESP:
     .dcacheread_do              (resp_dcacheread_do),              //input
@@ -657,7 +657,7 @@ dcache dcache_inst(
 
 dcache_to_icache_fifo dcache_to_icache_fifo_inst(
     .clk            (clk),
-    .rst_n          (rst_n),
+    .rst          (rst),
     
     //RESP:
     .dcachetoicache_write_do        (dcachetoicache_write_do),        //input
@@ -676,7 +676,7 @@ dcache_to_icache_fifo dcache_to_icache_fifo_inst(
 
 icache icache_inst(
     .clk            (clk),
-    .rst_n          (rst_n),
+    .rst          (rst),
     
     //RESP:
     .pr_reset       (pr_reset),   //input
@@ -725,7 +725,7 @@ icache icache_inst(
 memory_read memory_read_inst(
     // global
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     // read step
     .rd_reset           (rd_reset),   //input
@@ -766,7 +766,7 @@ memory_read memory_read_inst(
 
 memory_write memory_write_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     // write step
     .wr_reset           (wr_reset),   //input
@@ -806,7 +806,7 @@ memory_write memory_write_inst(
 
 prefetch prefetch_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     .pr_reset       (pr_reset),   //input
     
@@ -834,7 +834,7 @@ prefetch prefetch_inst(
 
 prefetch_fifo prefetch_fifo_inst(
     .clk            (clk),
-    .rst_n          (rst_n),
+    .rst          (rst),
     
     .pr_reset       (pr_reset),   //input
     
@@ -865,7 +865,7 @@ prefetch_fifo prefetch_fifo_inst(
 
 prefetch_control prefetch_control_inst(
     .clk                    (clk),
-    .rst_n                  (rst_n),
+    .rst                  (rst),
     
     .pr_reset       (pr_reset), //input //same as reset to icache
     
@@ -904,7 +904,7 @@ prefetch_control prefetch_control_inst(
 
 tlb tlb_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
 
     .pr_reset       (pr_reset),   //input
     .rd_reset       (rd_reset),   //input
diff --git a/rtl/ao486/memory/memory_read.v b/rtl/ao486/memory/memory_read.v
index 231fbc2..bc98498 100644
--- a/rtl/ao486/memory/memory_read.v
+++ b/rtl/ao486/memory/memory_read.v
@@ -31,7 +31,7 @@
 module memory_read(
     // global
     input               clk,
-    input               rst_n,
+    input               rst,
     
     // read step
     input               rd_reset,
@@ -125,20 +125,20 @@ assign merged =
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           reset_waiting <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                           reset_waiting <= `FALSE;
     else if(rd_reset && state != STATE_IDLE)    reset_waiting <= `TRUE;
     else if(state == STATE_IDLE)                reset_waiting <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               read_page_fault <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                               read_page_fault <= `FALSE;
     else if(rd_reset)                               read_page_fault <= `FALSE;
     else if(tlbread_page_fault && ~(reset_waiting)) read_page_fault <= `TRUE;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               read_ac_fault <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                               read_ac_fault <= `FALSE;
     else if(rd_reset)                               read_ac_fault <= `FALSE;
     else if(tlbread_ac_fault && ~(reset_waiting))   read_ac_fault <= `TRUE;
 end
@@ -158,7 +158,7 @@ tlbread_length          -- set
 tlbread_length_full     -- constant assign from read
 tlbread_lock            -- constant assign from read
 tlbread_rmw             -- constant assign from read
-*/  
+p*/  
 
 /*******************************************************************************SCRIPT
 
diff --git a/rtl/ao486/memory/memory_write.v b/rtl/ao486/memory/memory_write.v
index 806354d..294f41b 100644
--- a/rtl/ao486/memory/memory_write.v
+++ b/rtl/ao486/memory/memory_write.v
@@ -30,7 +30,7 @@
 
 module memory_write(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     // write step
     input               wr_reset,
@@ -85,6 +85,11 @@ reg         ac_fault;
 
 //------------------------------------------------------------------------------
 
+localparam [1:0] STATE_IDLE        = 2'd0;
+localparam [1:0] STATE_FIRST_WAIT  = 2'd1;
+localparam [1:0] STATE_SECOND      = 2'd2;
+   
+   
 wire [4:0]  left_in_line;
 
 wire [2:0]  length_1;
@@ -114,29 +119,26 @@ assign tlbwrite_rmw         = write_rmw;
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           reset_waiting <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                           reset_waiting <= `FALSE;
     else if(wr_reset && state != STATE_IDLE)    reset_waiting <= `TRUE;
     else if(state == STATE_IDLE)                reset_waiting <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   page_fault <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                                   page_fault <= `FALSE;
     else if(wr_reset)                                   page_fault <= `FALSE;
     else if(tlbwrite_page_fault && ~(reset_waiting))    page_fault <= `TRUE;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               ac_fault <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                               ac_fault <= `FALSE;
     else if(wr_reset)                               ac_fault <= `FALSE;
     else if(tlbwrite_ac_fault && ~(reset_waiting))  ac_fault <= `TRUE;
 end
 
 //------------------------------------------------------------------------------
 
-localparam [1:0] STATE_IDLE        = 2'd0;
-localparam [1:0] STATE_FIRST_WAIT  = 2'd1;
-localparam [1:0] STATE_SECOND      = 2'd2;
 
 //------------------------------------------------------------------------------
 
diff --git a/rtl/ao486/memory/prefetch.v b/rtl/ao486/memory/prefetch.v
index 949c0a9..3431efe 100644
--- a/rtl/ao486/memory/prefetch.v
+++ b/rtl/ao486/memory/prefetch.v
@@ -28,7 +28,7 @@
 
 module prefetch(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               pr_reset,
     
@@ -78,20 +78,20 @@ assign prefetchfifo_signal_limit_do = limit == 32'd0 && limit_signaled == `FALSE
 
 //------------------------------------------------------------------------------
    
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       limit <= `STARTUP_PREFETCH_LIMIT;
+always @(posedge clk) begin
+    if(rst)       limit <= `STARTUP_PREFETCH_LIMIT;
     else if(pr_reset)       limit <= (cs_limit >= prefetch_eip)? cs_limit - prefetch_eip + 32'd1 : 32'd0;
     else if(prefetched_do)  limit <= limit - { 27'd0, length };
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       linear <= `STARTUP_PREFETCH_LINEAR;
+always @(posedge clk) begin
+    if(rst)       linear <= `STARTUP_PREFETCH_LINEAR;
     else if(pr_reset)       linear <= cs_base + prefetch_eip;
     else if(prefetched_do)  linear <= linear + { 27'd0, length };
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       limit_signaled <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                       limit_signaled <= `FALSE;
     else if(pr_reset)                       limit_signaled <= `FALSE;
     else if(prefetchfifo_signal_limit_do)   limit_signaled <= `TRUE;
 end
diff --git a/rtl/ao486/memory/prefetch_control.v b/rtl/ao486/memory/prefetch_control.v
index 63ee918..b9b8720 100644
--- a/rtl/ao486/memory/prefetch_control.v
+++ b/rtl/ao486/memory/prefetch_control.v
@@ -30,7 +30,7 @@
 
 module prefetch_control(
     input           clk,
-    input           rst_n,
+    input           rst,
     
     input           pr_reset, //same as reset to icache
     
diff --git a/rtl/ao486/memory/prefetch_fifo.v b/rtl/ao486/memory/prefetch_fifo.v
index dfe1633..aa2083d 100644
--- a/rtl/ao486/memory/prefetch_fifo.v
+++ b/rtl/ao486/memory/prefetch_fifo.v
@@ -28,7 +28,7 @@
 
 module prefetch_fifo(
     input           clk,
-    input           rst_n,
+    input           rst,
     
     input           pr_reset,
     
@@ -56,33 +56,34 @@ module prefetch_fifo(
 
 //------------------------------------------------------------------------------
 
+wire [135:0] q;
+wire         empty;
+reg        second_processing;
+reg [67:0] second;
+   
 assign prefetchfifo_accept_data = (second_processing)? second : q[67:0];
 
 assign prefetchfifo_accept_empty= empty && second_processing == `FALSE;
 
 //------------------------------------------------------------------------------
 
-wire [135:0] q;
-wire         empty;
 
 //------------------------------------------------------------------------------
 
 //------------------------------------------------------------------------------
 
-reg        second_processing;
-reg [67:0] second;
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                   second_processing <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                                                                                   second_processing <= `FALSE;
     else if(pr_reset)                                                                                   second_processing <= `FALSE;
     else if(prefetchfifo_accept_do && second_processing == `FALSE && q[135:132] != 4'd0 && ~(empty))    second_processing <= `TRUE;
     else if(prefetchfifo_accept_do && second_processing == `TRUE)                                       second_processing <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               second <= 68'd0;
+always @(posedge clk) begin
+    if(rst)                                               second <= 68'd0;
     else if(prefetchfifo_accept_do && second_processing == `FALSE)  second <= q[135:68];
 end
 
@@ -95,7 +96,7 @@ simple_fifo #(
 )
 prefetch_fifo_inst(
     .clk        (clk),      //input
-    .rst_n      (rst_n),    //input
+    .rst      (rst),    //input
     .sclr       (pr_reset), //input
     
     .rdreq      (prefetchfifo_accept_do && second_processing == `FALSE),                                //input
diff --git a/rtl/ao486/memory/tlb.v b/rtl/ao486/memory/tlb.v
index 53a5300..a8a9688 100644
--- a/rtl/ao486/memory/tlb.v
+++ b/rtl/ao486/memory/tlb.v
@@ -30,7 +30,7 @@
 
 module tlb(
     input               clk,
-    input               rst_n,
+    input               rst,
 
     input               pr_reset,
     input               rd_reset,
@@ -154,50 +154,164 @@ module tlb(
 
 //------------------------------------------------------------------------------
 
+localparam [4:0] STATE_IDLE             = 5'd0;
+localparam [4:0] STATE_CODE_CHECK       = 5'd1;
+localparam [4:0] STATE_LOAD_PDE         = 5'd2;
+localparam [4:0] STATE_LOAD_PTE_START   = 5'd3;
+localparam [4:0] STATE_LOAD_PTE         = 5'd4;
+localparam [4:0] STATE_LOAD_PTE_END     = 5'd5;
+localparam [4:0] STATE_SAVE_PDE         = 5'd6;
+localparam [4:0] STATE_SAVE_PTE_START   = 5'd7;
+localparam [4:0] STATE_SAVE_PTE         = 5'd8;
+localparam [4:0] STATE_CHECK_CHECK      = 5'd9;
+localparam [4:0] STATE_WRITE_CHECK      = 5'd10;
+localparam [4:0] STATE_WRITE_WAIT_START = 5'd11;
+localparam [4:0] STATE_WRITE_WAIT       = 5'd12;
+localparam [4:0] STATE_WRITE_DOUBLE     = 5'd13;
+localparam [4:0] STATE_READ_CHECK       = 5'd14;
+localparam [4:0] STATE_READ_WAIT_START  = 5'd15;
+localparam [4:0] STATE_READ_WAIT        = 5'd16;
+localparam [4:0] STATE_RETRY            = 5'd17;
+localparam [1:0] TYPE_CODE  = 2'd0;
+localparam [1:0] TYPE_CHECK = 2'd1;
+localparam [1:0] TYPE_WRITE = 2'd2;
+localparam [1:0] TYPE_READ  = 2'd3;
+localparam [1:0] WRITE_DOUBLE_NONE    = 2'd0;
+localparam [1:0] WRITE_DOUBLE_CHECK   = 2'd1;
+localparam [1:0] WRITE_DOUBLE_RESTART = 2'd2;
 reg [4:0]   state;
-
 reg [31:0]  linear;
 reg         su;
 reg         rw;
 reg         wp;
 reg [1:0]   current_type;
-
 reg [31:0]  pde;
 reg [31:0]  pte;
-
 reg         code_pf;
 reg         check_pf;
-
 reg         write_pf;
 reg         write_ac;
-
 reg         read_pf;
 reg         read_ac;
-
 reg         pr_reset_waiting;
-
 reg         tlbflushall_do_waiting;
-
 reg [1:0]   write_double_state;
 reg [31:0]  write_double_linear;
-
-//------------------------------------------------------------------------------
-
 wire [31:0] memtype_physical;
 wire        memtype_cache_disable;
 wire        memtype_write_transparent;
-
 wire        rw_entry;
 wire        su_entry;
 wire        fault;
-
 wire        rw_entry_before_pte;
 wire        su_entry_before_pte;
 wire        fault_before_pte;
-
 wire [31:0] cr3_base;
 wire        cr3_pwt;
 wire        cr3_pcd;
+wire translate_combined_rw;
+wire translate_combined_su;
+wire tlbregs_tlbflushsingle_do;
+wire tlbregs_tlbflushall_do;
+wire        translate_do;
+wire        translate_valid;
+wire [31:0] translate_physical;
+wire        translate_pwt;
+wire        translate_pcd;
+wire        tlbregs_write_do;
+wire [31:0] tlbregs_write_linear;
+wire [31:0] tlbregs_write_physical;
+wire        tlbregs_write_pwt;
+wire        tlbregs_write_pcd;
+wire        tlbregs_write_combined_rw;
+wire        tlbregs_write_combined_su;
+wire _unused_ok;
+
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire cond_12;
+wire cond_13;
+wire cond_14;
+wire cond_15;
+wire cond_16;
+wire cond_17;
+wire cond_18;
+wire cond_19;
+wire cond_20;
+wire cond_21;
+wire cond_22;
+wire cond_23;
+wire cond_24;
+wire cond_25;
+wire cond_26;
+wire cond_27;
+wire cond_28;
+wire cond_29;
+wire cond_30;
+wire cond_31;
+wire cond_32;
+wire cond_33;
+wire cond_34;
+wire cond_35;
+wire cond_36;
+wire cond_37;
+wire cond_38;
+wire cond_39;
+wire cond_40;
+wire cond_41;
+wire cond_42;
+wire cond_43;
+wire [1:0] current_type_to_reg ;
+wire read_pf_to_reg;
+wire [31:0] pde_to_reg ;
+wire write_pf_to_reg;
+wire [4:0] state_to_reg ;
+wire [31:0] tlb_read_pf_cr2_to_reg ;
+wire [31:0] tlb_code_pf_cr2_to_reg ;
+wire check_pf_to_reg;
+wire su_to_reg;
+wire [15:0] tlb_check_pf_error_code_to_reg ;
+wire [15:0] tlb_write_pf_error_code_to_reg ;
+wire [31:0] write_double_linear_to_reg ;
+wire tlbcode_cache_disable_to_reg;
+wire [31:0] linear_to_reg ;
+wire [15:0] tlb_code_pf_error_code_to_reg ;
+wire tlbcode_do_to_reg;
+wire wp_to_reg;
+wire tlbcheck_done_to_reg;
+wire [31:0] tlb_write_pf_cr2_to_reg ;
+wire read_ac_to_reg;
+wire [31:0] pte_to_reg ;
+wire [31:0] tlb_check_pf_cr2_to_reg ;
+wire [15:0] tlb_read_pf_error_code_to_reg ;
+wire [1:0] write_double_state_to_reg ;
+wire write_ac_to_reg;
+wire [31:0] tlbcode_physical_to_reg ;
+wire rw_to_reg;
+wire code_pf_to_reg;
+
+
+
+
+
+
+
+
+//------------------------------------------------------------------------------
+
+
+
+
 
 assign cr3_base = { cr3[31:12], 12'd0 };
 assign cr3_pwt  = cr3[3];
@@ -241,33 +355,8 @@ assign tlbcode_linear = linear;
 
 //------------------------------------------------------------------------------
 
-localparam [4:0] STATE_IDLE             = 5'd0;
-localparam [4:0] STATE_CODE_CHECK       = 5'd1;
-localparam [4:0] STATE_LOAD_PDE         = 5'd2;
-localparam [4:0] STATE_LOAD_PTE_START   = 5'd3;
-localparam [4:0] STATE_LOAD_PTE         = 5'd4;
-localparam [4:0] STATE_LOAD_PTE_END     = 5'd5;
-localparam [4:0] STATE_SAVE_PDE         = 5'd6;
-localparam [4:0] STATE_SAVE_PTE_START   = 5'd7;
-localparam [4:0] STATE_SAVE_PTE         = 5'd8;
-localparam [4:0] STATE_CHECK_CHECK      = 5'd9;
-localparam [4:0] STATE_WRITE_CHECK      = 5'd10;
-localparam [4:0] STATE_WRITE_WAIT_START = 5'd11;
-localparam [4:0] STATE_WRITE_WAIT       = 5'd12;
-localparam [4:0] STATE_WRITE_DOUBLE     = 5'd13;
-localparam [4:0] STATE_READ_CHECK       = 5'd14;
-localparam [4:0] STATE_READ_WAIT_START  = 5'd15;
-localparam [4:0] STATE_READ_WAIT        = 5'd16;
-localparam [4:0] STATE_RETRY            = 5'd17;
 
-localparam [1:0] TYPE_CODE  = 2'd0;
-localparam [1:0] TYPE_CHECK = 2'd1;
-localparam [1:0] TYPE_WRITE = 2'd2;
-localparam [1:0] TYPE_READ  = 2'd3;
 
-localparam [1:0] WRITE_DOUBLE_NONE    = 2'd0;
-localparam [1:0] WRITE_DOUBLE_CHECK   = 2'd1;
-localparam [1:0] WRITE_DOUBLE_RESTART = 2'd2;
 
 //------------------------------------------------------------------------------
 
@@ -278,29 +367,13 @@ tlb_memtype tlb_memtype_inst(
     .write_transparent  (memtype_write_transparent)     //output
 );
 
-wire translate_combined_rw;
-wire translate_combined_su;
 
-wire tlbregs_tlbflushsingle_do;
-wire tlbregs_tlbflushall_do;
 
-wire        translate_do;
-wire        translate_valid;
-wire [31:0] translate_physical;
-wire        translate_pwt;
-wire        translate_pcd;
 
-wire        tlbregs_write_do;
-wire [31:0] tlbregs_write_linear;
-wire [31:0] tlbregs_write_physical;
-wire        tlbregs_write_pwt;
-wire        tlbregs_write_pcd;
-wire        tlbregs_write_combined_rw;
-wire        tlbregs_write_combined_su;
 
 tlb_regs tlb_regs_inst(
     .clk                        (clk),
-    .rst_n                      (rst_n),
+    .rst                      (rst),
     
     //RESP:
     .tlbflushsingle_do          (tlbregs_tlbflushsingle_do),    //input
@@ -338,50 +411,50 @@ tlb_regs tlb_regs_inst(
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   code_pf <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   code_pf <= `FALSE;
     else if(pr_reset)   code_pf <= `FALSE;
     else                code_pf <= code_pf_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   check_pf <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   check_pf <= `FALSE;
     else if(exe_reset)  check_pf <= `FALSE;
     else                check_pf <= check_pf_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   read_pf <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   read_pf <= `FALSE;
     else if(rd_reset)   read_pf <= `FALSE;
     else                read_pf <= read_pf_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   read_ac <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   read_ac <= `FALSE;
     else if(rd_reset)   read_ac <= `FALSE;
     else                read_ac <= read_ac_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   write_pf <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   write_pf <= `FALSE;
     else if(wr_reset)   write_pf <= `FALSE;
     else                write_pf <= write_pf_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   write_ac <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   write_ac <= `FALSE;
     else if(wr_reset)   write_ac <= `FALSE;
     else                write_ac <= write_ac_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           pr_reset_waiting <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                           pr_reset_waiting <= `FALSE;
     else if(pr_reset && state != STATE_IDLE)    pr_reset_waiting <= `TRUE;
     else if(state == STATE_IDLE)                pr_reset_waiting <= `FALSE;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               tlbflushall_do_waiting <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                               tlbflushall_do_waiting <= `FALSE;
     else if(tlbflushall_do && state != STATE_IDLE)  tlbflushall_do_waiting <= `TRUE;
     else if(tlbregs_tlbflushall_do)                 tlbflushall_do_waiting <= `FALSE;
 end
@@ -389,7 +462,7 @@ end
 //------------------------------------------------------------------------------
 
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, cr3[11:5], cr3[2:0], tlbread_lock, tlbwrite_lock, tlbwrite_rmw, cr3_base[11:0], 1'b0 };
+ assign _unused_ok = &{ 1'b0, cr3[11:5], cr3[2:0], tlbread_lock, tlbwrite_lock, tlbwrite_rmw, cr3_base[11:0], 1'b0 };
 // synthesis translate_on
 
 //------------------------------------------------------------------------------
diff --git a/rtl/ao486/memory/tlb_regs.v b/rtl/ao486/memory/tlb_regs.v
index eab33cf..5fa485d 100644
--- a/rtl/ao486/memory/tlb_regs.v
+++ b/rtl/ao486/memory/tlb_regs.v
@@ -28,7 +28,7 @@
 
 module tlb_regs(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //RESP:
     input               tlbflushsingle_do,
@@ -556,8 +556,8 @@ localparam [30:0] TLB0_VALUE = 31'b0000000000000001000000010001011; //0,1,3,7,15
     
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   plru <= 31'd0;
+always @(posedge clk) begin
+    if(rst)                   plru <= 31'd0;
     else if(tlbflushall_do)             plru <= 31'd0;
     else if(tlb0_write  || tlb0_sel)    plru <= (plru & ~(TLB0_MASK))  | TLB0_VALUE;
     else if(tlb1_write  || tlb1_sel)    plru <= (plru & ~(TLB1_MASK))  | TLB1_VALUE;
@@ -594,38 +594,38 @@ always @(posedge clk or negedge rst_n) begin
 end
 
  
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb0 <= 46'd0;  else if(tlbflushall_do || tlb0_tlbflush)  tlb0  <= 46'd0; else if(tlb0_write)  tlb0  <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb1 <= 46'd0;  else if(tlbflushall_do || tlb1_tlbflush)  tlb1  <= 46'd0; else if(tlb1_write)  tlb1  <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb2 <= 46'd0;  else if(tlbflushall_do || tlb2_tlbflush)  tlb2  <= 46'd0; else if(tlb2_write)  tlb2  <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb3 <= 46'd0;  else if(tlbflushall_do || tlb3_tlbflush)  tlb3  <= 46'd0; else if(tlb3_write)  tlb3  <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb4 <= 46'd0;  else if(tlbflushall_do || tlb4_tlbflush)  tlb4  <= 46'd0; else if(tlb4_write)  tlb4  <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb5 <= 46'd0;  else if(tlbflushall_do || tlb5_tlbflush)  tlb5  <= 46'd0; else if(tlb5_write)  tlb5  <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb6 <= 46'd0;  else if(tlbflushall_do || tlb6_tlbflush)  tlb6  <= 46'd0; else if(tlb6_write)  tlb6  <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb7 <= 46'd0;  else if(tlbflushall_do || tlb7_tlbflush)  tlb7  <= 46'd0; else if(tlb7_write)  tlb7  <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb8 <= 46'd0;  else if(tlbflushall_do || tlb8_tlbflush)  tlb8  <= 46'd0; else if(tlb8_write)  tlb8  <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb9 <= 46'd0;  else if(tlbflushall_do || tlb9_tlbflush)  tlb9  <= 46'd0; else if(tlb9_write)  tlb9  <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb10 <= 46'd0; else if(tlbflushall_do || tlb10_tlbflush) tlb10 <= 46'd0; else if(tlb10_write) tlb10 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb11 <= 46'd0; else if(tlbflushall_do || tlb11_tlbflush) tlb11 <= 46'd0; else if(tlb11_write) tlb11 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb12 <= 46'd0; else if(tlbflushall_do || tlb12_tlbflush) tlb12 <= 46'd0; else if(tlb12_write) tlb12 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb13 <= 46'd0; else if(tlbflushall_do || tlb13_tlbflush) tlb13 <= 46'd0; else if(tlb13_write) tlb13 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb14 <= 46'd0; else if(tlbflushall_do || tlb14_tlbflush) tlb14 <= 46'd0; else if(tlb14_write) tlb14 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb15 <= 46'd0; else if(tlbflushall_do || tlb15_tlbflush) tlb15 <= 46'd0; else if(tlb15_write) tlb15 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb16 <= 46'd0; else if(tlbflushall_do || tlb16_tlbflush) tlb16 <= 46'd0; else if(tlb16_write) tlb16 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb17 <= 46'd0; else if(tlbflushall_do || tlb17_tlbflush) tlb17 <= 46'd0; else if(tlb17_write) tlb17 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb18 <= 46'd0; else if(tlbflushall_do || tlb18_tlbflush) tlb18 <= 46'd0; else if(tlb18_write) tlb18 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb19 <= 46'd0; else if(tlbflushall_do || tlb19_tlbflush) tlb19 <= 46'd0; else if(tlb19_write) tlb19 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb20 <= 46'd0; else if(tlbflushall_do || tlb20_tlbflush) tlb20 <= 46'd0; else if(tlb20_write) tlb20 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb21 <= 46'd0; else if(tlbflushall_do || tlb21_tlbflush) tlb21 <= 46'd0; else if(tlb21_write) tlb21 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb22 <= 46'd0; else if(tlbflushall_do || tlb22_tlbflush) tlb22 <= 46'd0; else if(tlb22_write) tlb22 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb23 <= 46'd0; else if(tlbflushall_do || tlb23_tlbflush) tlb23 <= 46'd0; else if(tlb23_write) tlb23 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb24 <= 46'd0; else if(tlbflushall_do || tlb24_tlbflush) tlb24 <= 46'd0; else if(tlb24_write) tlb24 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb25 <= 46'd0; else if(tlbflushall_do || tlb25_tlbflush) tlb25 <= 46'd0; else if(tlb25_write) tlb25 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb26 <= 46'd0; else if(tlbflushall_do || tlb26_tlbflush) tlb26 <= 46'd0; else if(tlb26_write) tlb26 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb27 <= 46'd0; else if(tlbflushall_do || tlb27_tlbflush) tlb27 <= 46'd0; else if(tlb27_write) tlb27 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb28 <= 46'd0; else if(tlbflushall_do || tlb28_tlbflush) tlb28 <= 46'd0; else if(tlb28_write) tlb28 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb29 <= 46'd0; else if(tlbflushall_do || tlb29_tlbflush) tlb29 <= 46'd0; else if(tlb29_write) tlb29 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb30 <= 46'd0; else if(tlbflushall_do || tlb30_tlbflush) tlb30 <= 46'd0; else if(tlb30_write) tlb30 <= write_data; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tlb31 <= 46'd0; else if(tlbflushall_do || tlb31_tlbflush) tlb31 <= 46'd0; else if(tlb31_write) tlb31 <= write_data; end
+always @(posedge clk) begin if(rst) tlb0 <= 46'd0;  else if(tlbflushall_do || tlb0_tlbflush)  tlb0  <= 46'd0; else if(tlb0_write)  tlb0  <= write_data; end
+always @(posedge clk) begin if(rst) tlb1 <= 46'd0;  else if(tlbflushall_do || tlb1_tlbflush)  tlb1  <= 46'd0; else if(tlb1_write)  tlb1  <= write_data; end
+always @(posedge clk) begin if(rst) tlb2 <= 46'd0;  else if(tlbflushall_do || tlb2_tlbflush)  tlb2  <= 46'd0; else if(tlb2_write)  tlb2  <= write_data; end
+always @(posedge clk) begin if(rst) tlb3 <= 46'd0;  else if(tlbflushall_do || tlb3_tlbflush)  tlb3  <= 46'd0; else if(tlb3_write)  tlb3  <= write_data; end
+always @(posedge clk) begin if(rst) tlb4 <= 46'd0;  else if(tlbflushall_do || tlb4_tlbflush)  tlb4  <= 46'd0; else if(tlb4_write)  tlb4  <= write_data; end
+always @(posedge clk) begin if(rst) tlb5 <= 46'd0;  else if(tlbflushall_do || tlb5_tlbflush)  tlb5  <= 46'd0; else if(tlb5_write)  tlb5  <= write_data; end
+always @(posedge clk) begin if(rst) tlb6 <= 46'd0;  else if(tlbflushall_do || tlb6_tlbflush)  tlb6  <= 46'd0; else if(tlb6_write)  tlb6  <= write_data; end
+always @(posedge clk) begin if(rst) tlb7 <= 46'd0;  else if(tlbflushall_do || tlb7_tlbflush)  tlb7  <= 46'd0; else if(tlb7_write)  tlb7  <= write_data; end
+always @(posedge clk) begin if(rst) tlb8 <= 46'd0;  else if(tlbflushall_do || tlb8_tlbflush)  tlb8  <= 46'd0; else if(tlb8_write)  tlb8  <= write_data; end
+always @(posedge clk) begin if(rst) tlb9 <= 46'd0;  else if(tlbflushall_do || tlb9_tlbflush)  tlb9  <= 46'd0; else if(tlb9_write)  tlb9  <= write_data; end
+always @(posedge clk) begin if(rst) tlb10 <= 46'd0; else if(tlbflushall_do || tlb10_tlbflush) tlb10 <= 46'd0; else if(tlb10_write) tlb10 <= write_data; end
+always @(posedge clk) begin if(rst) tlb11 <= 46'd0; else if(tlbflushall_do || tlb11_tlbflush) tlb11 <= 46'd0; else if(tlb11_write) tlb11 <= write_data; end
+always @(posedge clk) begin if(rst) tlb12 <= 46'd0; else if(tlbflushall_do || tlb12_tlbflush) tlb12 <= 46'd0; else if(tlb12_write) tlb12 <= write_data; end
+always @(posedge clk) begin if(rst) tlb13 <= 46'd0; else if(tlbflushall_do || tlb13_tlbflush) tlb13 <= 46'd0; else if(tlb13_write) tlb13 <= write_data; end
+always @(posedge clk) begin if(rst) tlb14 <= 46'd0; else if(tlbflushall_do || tlb14_tlbflush) tlb14 <= 46'd0; else if(tlb14_write) tlb14 <= write_data; end
+always @(posedge clk) begin if(rst) tlb15 <= 46'd0; else if(tlbflushall_do || tlb15_tlbflush) tlb15 <= 46'd0; else if(tlb15_write) tlb15 <= write_data; end
+always @(posedge clk) begin if(rst) tlb16 <= 46'd0; else if(tlbflushall_do || tlb16_tlbflush) tlb16 <= 46'd0; else if(tlb16_write) tlb16 <= write_data; end
+always @(posedge clk) begin if(rst) tlb17 <= 46'd0; else if(tlbflushall_do || tlb17_tlbflush) tlb17 <= 46'd0; else if(tlb17_write) tlb17 <= write_data; end
+always @(posedge clk) begin if(rst) tlb18 <= 46'd0; else if(tlbflushall_do || tlb18_tlbflush) tlb18 <= 46'd0; else if(tlb18_write) tlb18 <= write_data; end
+always @(posedge clk) begin if(rst) tlb19 <= 46'd0; else if(tlbflushall_do || tlb19_tlbflush) tlb19 <= 46'd0; else if(tlb19_write) tlb19 <= write_data; end
+always @(posedge clk) begin if(rst) tlb20 <= 46'd0; else if(tlbflushall_do || tlb20_tlbflush) tlb20 <= 46'd0; else if(tlb20_write) tlb20 <= write_data; end
+always @(posedge clk) begin if(rst) tlb21 <= 46'd0; else if(tlbflushall_do || tlb21_tlbflush) tlb21 <= 46'd0; else if(tlb21_write) tlb21 <= write_data; end
+always @(posedge clk) begin if(rst) tlb22 <= 46'd0; else if(tlbflushall_do || tlb22_tlbflush) tlb22 <= 46'd0; else if(tlb22_write) tlb22 <= write_data; end
+always @(posedge clk) begin if(rst) tlb23 <= 46'd0; else if(tlbflushall_do || tlb23_tlbflush) tlb23 <= 46'd0; else if(tlb23_write) tlb23 <= write_data; end
+always @(posedge clk) begin if(rst) tlb24 <= 46'd0; else if(tlbflushall_do || tlb24_tlbflush) tlb24 <= 46'd0; else if(tlb24_write) tlb24 <= write_data; end
+always @(posedge clk) begin if(rst) tlb25 <= 46'd0; else if(tlbflushall_do || tlb25_tlbflush) tlb25 <= 46'd0; else if(tlb25_write) tlb25 <= write_data; end
+always @(posedge clk) begin if(rst) tlb26 <= 46'd0; else if(tlbflushall_do || tlb26_tlbflush) tlb26 <= 46'd0; else if(tlb26_write) tlb26 <= write_data; end
+always @(posedge clk) begin if(rst) tlb27 <= 46'd0; else if(tlbflushall_do || tlb27_tlbflush) tlb27 <= 46'd0; else if(tlb27_write) tlb27 <= write_data; end
+always @(posedge clk) begin if(rst) tlb28 <= 46'd0; else if(tlbflushall_do || tlb28_tlbflush) tlb28 <= 46'd0; else if(tlb28_write) tlb28 <= write_data; end
+always @(posedge clk) begin if(rst) tlb29 <= 46'd0; else if(tlbflushall_do || tlb29_tlbflush) tlb29 <= 46'd0; else if(tlb29_write) tlb29 <= write_data; end
+always @(posedge clk) begin if(rst) tlb30 <= 46'd0; else if(tlbflushall_do || tlb30_tlbflush) tlb30 <= 46'd0; else if(tlb30_write) tlb30 <= write_data; end
+always @(posedge clk) begin if(rst) tlb31 <= 46'd0; else if(tlbflushall_do || tlb31_tlbflush) tlb31 <= 46'd0; else if(tlb31_write) tlb31 <= write_data; end
 
 //------------------------------------------------------------------------------
 
diff --git a/rtl/ao486/pipeline/decode.v b/rtl/ao486/pipeline/decode.v
index 8a4c8e0..17e3334 100644
--- a/rtl/ao486/pipeline/decode.v
+++ b/rtl/ao486/pipeline/decode.v
@@ -28,7 +28,7 @@
 
 module decode(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               dec_reset,
     
@@ -175,7 +175,7 @@ wire        prefix_group_1_lock;
 
 decode_prefix decode_prefix_inst(
     .clk                        (clk),
-    .rst_n                      (rst_n),
+    .rst                      (rst),
     
     .cs_cache                   (cs_cache),                 //input [63:0]
     .dec_is_modregrm            (dec_is_modregrm),          //input
@@ -203,7 +203,7 @@ decode_prefix decode_prefix_inst(
 
 decode_regs decode_regs_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     .dec_reset          (dec_reset),        //input
     
@@ -301,13 +301,13 @@ assign gp_fault = enable && ~(instr_prefix) && consume_count_local == 4'd0 && (
     ( dec_acceptable == 4'd0 )                  // instruction length limit reached
 );
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   gp_fault_last <= 1'b0;
+always @(posedge clk) begin
+    if(rst)   gp_fault_last <= 1'b0;
     else                gp_fault_last <= gp_fault;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   dec_gp_fault <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                   dec_gp_fault <= `FALSE;
     else if(dec_reset)                  dec_gp_fault <= `FALSE;
     else if(gp_fault && gp_fault_last)  dec_gp_fault <= `TRUE;
 end
@@ -315,8 +315,8 @@ end
 //-------------------------- UD
 
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           dec_ud_fault <= `FALSE;
+always @(posedge clk) begin
+    if(rst)           dec_ud_fault <= `FALSE;
     else if(dec_reset)          dec_ud_fault <= `FALSE;
     else if(dec_exception_ud)   dec_ud_fault <= `TRUE;
 end
@@ -327,13 +327,13 @@ assign pf_fault = enable && ~(instr_prefix) && consume_count_local == 4'd0 && (
     ( fetch_valid == 4'd0 && fetch_page_fault )
 );
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   pf_fault_last <= 1'b0;
+always @(posedge clk) begin
+    if(rst)   pf_fault_last <= 1'b0;
     else                pf_fault_last <= pf_fault;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   dec_pf_fault <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                   dec_pf_fault <= `FALSE;
     else if(dec_reset)                  dec_pf_fault <= `FALSE;
     else if(pf_fault && pf_fault_last)  dec_pf_fault <= `TRUE;
 end
@@ -342,8 +342,8 @@ end
 
 assign dec_eip = eip + { 28'd0, dec_consumed };
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           eip <= `STARTUP_EIP;
+always @(posedge clk) begin
+    if(rst)                           eip <= `STARTUP_EIP;
     else if(pr_reset)                           eip <= prefetch_eip;
     else if(dec_ready)                          eip <= dec_eip;
 end
diff --git a/rtl/ao486/pipeline/decode_commands.v b/rtl/ao486/pipeline/decode_commands.v
index a27e877..c1fc220 100644
--- a/rtl/ao486/pipeline/decode_commands.v
+++ b/rtl/ao486/pipeline/decode_commands.v
@@ -26,6 +26,9 @@
 
 //PARSED_COMMENTS: this file contains parsed script comments
 
+`include "defines.v"
+`include "autogen/defines.v"
+
 module decode_commands(
     
     input               protected_mode,
diff --git a/rtl/ao486/pipeline/decode_prefix.v b/rtl/ao486/pipeline/decode_prefix.v
index 8cc6b5d..f0ad401 100644
--- a/rtl/ao486/pipeline/decode_prefix.v
+++ b/rtl/ao486/pipeline/decode_prefix.v
@@ -23,10 +23,12 @@
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
+
+`include "defines.v"
 
 module decode_prefix(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input       [63:0]  cs_cache,
     input               dec_is_modregrm,
@@ -120,22 +122,22 @@ assign is_prefix =
 //------------------------------------------------------------------------------
 
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               dec_prefix_group_1_rep <= 2'd0;
+always @(posedge clk) begin
+    if(rst)                               dec_prefix_group_1_rep <= 2'd0;
     else if(instr_finished)                         dec_prefix_group_1_rep <= 2'd0;
     else if(instr_prefix && decoder[7:0] == 8'hF2)  dec_prefix_group_1_rep <= 2'd1;
     else if(instr_prefix && decoder[7:0] == 8'hF3)  dec_prefix_group_1_rep <= 2'd2;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               prefix_group_1_lock <= 1'd0;
+always @(posedge clk) begin
+    if(rst)                               prefix_group_1_lock <= 1'd0;
     else if(instr_finished)                         prefix_group_1_lock <= 1'd0;
     else if(instr_prefix && decoder[7:0] == 8'hF0)  prefix_group_1_lock <= 1'd1;
 end
 
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               prefix_group_2 <= 3'd7;
+always @(posedge clk) begin
+    if(rst)                               prefix_group_2 <= 3'd7;
     else if(instr_finished)                         prefix_group_2 <= 3'd7;
     else if(instr_prefix && decoder[7:0] == 8'h26)  prefix_group_2 <= 3'd0;
     else if(instr_prefix && decoder[7:0] == 8'h2E)  prefix_group_2 <= 3'd1;
@@ -145,26 +147,26 @@ always @(posedge clk or negedge rst_n) begin
     else if(instr_prefix && decoder[7:0] == 8'h65)  prefix_group_2 <= 3'd5;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               prefix_group_3 <= 1'd0;
+always @(posedge clk) begin
+    if(rst)                               prefix_group_3 <= 1'd0;
     else if(instr_finished)                         prefix_group_3 <= 1'd0;
     else if(instr_prefix && decoder[7:0] == 8'h66)  prefix_group_3 <= 1'd1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               prefix_group_4 <= 1'd0;
+always @(posedge clk) begin
+    if(rst)                               prefix_group_4 <= 1'd0;
     else if(instr_finished)                         prefix_group_4 <= 1'd0;
     else if(instr_prefix && decoder[7:0] == 8'h67)  prefix_group_4 <= 1'd1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               dec_prefix_2byte <= 1'd0;
+always @(posedge clk) begin
+    if(rst)                               dec_prefix_2byte <= 1'd0;
     else if(instr_finished)                         dec_prefix_2byte <= 1'd0;
     else if(instr_prefix && decoder[7:0] == 8'h0F)  dec_prefix_2byte <= 1'd1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       prefix_count <= 4'd0;
+always @(posedge clk) begin
+    if(rst)       prefix_count <= 4'd0;
     else if(instr_finished) prefix_count <= 4'd0;
     else if(instr_prefix)   prefix_count <= prefix_count + 4'd1;
 end
diff --git a/rtl/ao486/pipeline/decode_regs.v b/rtl/ao486/pipeline/decode_regs.v
index 3319ba1..88af27b 100644
--- a/rtl/ao486/pipeline/decode_regs.v
+++ b/rtl/ao486/pipeline/decode_regs.v
@@ -26,7 +26,7 @@
 
 module decode_regs(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               dec_reset,
     
@@ -111,13 +111,13 @@ assign decoder_next =
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   decoder <= 96'd0;
+always @(posedge clk) begin
+    if(rst)   decoder <= 96'd0;
     else                decoder <= decoder_next;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   decoder_count <= 4'd0;
+always @(posedge clk) begin
+    if(rst)   decoder_count <= 4'd0;
     else if(dec_reset)  decoder_count <= 4'd0;
     else                decoder_count <= after_consume_count + accepted;
 end
diff --git a/rtl/ao486/pipeline/execute.v b/rtl/ao486/pipeline/execute.v
index f47a50f..09af125 100644
--- a/rtl/ao486/pipeline/execute.v
+++ b/rtl/ao486/pipeline/execute.v
@@ -28,7 +28,7 @@
 
 module execute(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               exe_reset,
     
@@ -278,11 +278,62 @@ module execute(
 );
 
 //------------------------------------------------------------------------------
-
+reg         exe_is_8bit;
+reg [7:0]   exe_modregrm_imm;
+reg [31:0]  exe_extra;
+reg [31:0]  src;
+reg [31:0]  dst;
+reg [31:0]  exe_address_effective;
+reg         exe_prefix_2byte;
 wire [31:0] tr_base;
 wire [31:0] tr_limit;
-
 wire [31:0] cs_limit;
+wire        e_load;
+wire        exe_operand_16bit;
+wire        exe_address_16bit;
+wire [10:0] exe_mutex_current;
+wire [2:0]  exe_modregrm_reg;
+wire exe_waiting;
+wire exe_is_8bit_clear;
+wire exe_cmpxchg_switch;
+wire exe_task_switch_finished;
+wire exe_eip_from_glob_param_2;
+wire exe_eip_from_glob_param_2_16bit;
+wire        exe_branch;
+wire [31:0] exe_branch_eip;
+wire offset_ret_far_se;
+wire offset_new_stack;
+wire offset_new_stack_minus;
+wire offset_new_stack_continue;
+wire offset_leave;
+wire offset_pop;
+wire offset_enter_last;
+wire offset_ret;
+wire offset_iret_glob_param_4;
+wire offset_iret;
+wire offset_ret_imm;
+wire offset_esp;
+wire offset_call;
+wire offset_call_keep;
+wire offset_call_int_same_first;
+wire offset_call_int_same_next;
+wire offset_int_real;
+wire offset_int_real_next;
+wire offset_task;
+wire [31:0] exe_enter_offset;
+wire e_shift_no_write;
+wire e_shift_oszapc_update;
+wire e_shift_cf_of_update;
+wire e_shift_oflag;
+wire e_shift_cflag;
+wire [31:0] e_shift_result;
+wire [65:0] mult_result;
+wire        mult_busy;    
+wire        div_busy;
+wire [31:0] div_result_quotient;
+wire [31:0] div_result_remainder;
+wire _unused_ok;
+
 
 assign tr_base  = { tr_cache[63:56], tr_cache[39:16] };
 
@@ -291,27 +342,16 @@ assign cs_limit = cs_cache[`DESC_BIT_G]? { cs_cache[51:48], cs_cache[15:0], 12'h
 
 //------------------------------------------------------------------------------
 
-wire        e_load;
 
-wire        exe_operand_16bit;
-wire        exe_address_16bit;
 
-wire [10:0] exe_mutex_current;
 
-wire [2:0]  exe_modregrm_reg;
 
 //------------------------------------------------------------------------------
 
-wire exe_waiting;
     
-wire exe_is_8bit_clear;
 
-wire exe_cmpxchg_switch;
 
-wire exe_task_switch_finished;
     
-wire exe_eip_from_glob_param_2;
-wire exe_eip_from_glob_param_2_16bit;
 
 //------------------------------------------------------------------------------
 
@@ -323,47 +363,40 @@ assign e_load = rd_ready;
 
 //------------------------------------------------------------------------------
 
-reg         exe_is_8bit;
-reg [7:0]   exe_modregrm_imm;
-reg [31:0]  exe_extra;
-reg [31:0]  src;
-reg [31:0]  dst;
-reg [31:0]  exe_address_effective;
-reg         exe_prefix_2byte;
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_decoder              <= 40'd0;     else if(e_load) exe_decoder              <= rd_decoder[39:0];        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_eip                  <= 32'd0;     else if(e_load) exe_eip                  <= rd_eip;                  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_operand_32bit        <= `FALSE;    else if(e_load) exe_operand_32bit        <= rd_operand_32bit;        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_address_32bit        <= `FALSE;    else if(e_load) exe_address_32bit        <= rd_address_32bit;        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_prefix_group_1_rep   <= 2'd0;      else if(e_load) exe_prefix_group_1_rep   <= rd_prefix_group_1_rep;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_prefix_group_1_lock  <= `FALSE;    else if(e_load) exe_prefix_group_1_lock  <= rd_prefix_group_1_lock;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_prefix_2byte         <= `FALSE;    else if(e_load) exe_prefix_2byte         <= rd_prefix_2byte;         end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_consumed             <= 4'd0;      else if(e_load) exe_consumed             <= rd_consumed;             end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_is_8bit              <= `FALSE;    else if(e_load) exe_is_8bit              <= rd_is_8bit;              end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_cmdex                <= 4'd0;      else if(e_load) exe_cmdex                <= rd_cmdex;                end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_modregrm_imm         <= 8'd0;      else if(e_load) exe_modregrm_imm         <= rd_modregrm_imm[7:0];    end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_dst_is_reg           <= `FALSE;    else if(e_load) exe_dst_is_reg           <= rd_dst_is_reg;           end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_dst_is_rm            <= `FALSE;    else if(e_load) exe_dst_is_rm            <= rd_dst_is_rm;            end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_dst_is_memory        <= `FALSE;    else if(e_load) exe_dst_is_memory        <= rd_dst_is_memory;        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_dst_is_eax           <= `FALSE;    else if(e_load) exe_dst_is_eax           <= rd_dst_is_eax;           end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_dst_is_edx_eax       <= `FALSE;    else if(e_load) exe_dst_is_edx_eax       <= rd_dst_is_edx_eax;       end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_dst_is_implicit_reg  <= `FALSE;    else if(e_load) exe_dst_is_implicit_reg  <= rd_dst_is_implicit_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_extra                <= 32'd0;     else if(e_load) exe_extra                <= rd_extra_wire;           end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_linear               <= 32'd0;     else if(e_load) exe_linear               <= rd_linear;               end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_debug_read           <= 4'd0;      else if(e_load) exe_debug_read           <= rd_debug_read;           end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) src                      <= 32'd0;     else if(e_load) src                      <= src_wire;                end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dst                      <= 32'd0;     else if(e_load) dst                      <= dst_wire;                end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) exe_address_effective    <= 32'd0;     else if(e_load) exe_address_effective    <= rd_address_effective;    end
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   exe_mutex <= 11'd0;
+always @(posedge clk) begin if(rst) exe_decoder              <= 40'd0;     else if(e_load) exe_decoder              <= rd_decoder[39:0];        end
+always @(posedge clk) begin if(rst) exe_eip                  <= 32'd0;     else if(e_load) exe_eip                  <= rd_eip;                  end
+always @(posedge clk) begin if(rst) exe_operand_32bit        <= `FALSE;    else if(e_load) exe_operand_32bit        <= rd_operand_32bit;        end
+always @(posedge clk) begin if(rst) exe_address_32bit        <= `FALSE;    else if(e_load) exe_address_32bit        <= rd_address_32bit;        end
+always @(posedge clk) begin if(rst) exe_prefix_group_1_rep   <= 2'd0;      else if(e_load) exe_prefix_group_1_rep   <= rd_prefix_group_1_rep;   end
+always @(posedge clk) begin if(rst) exe_prefix_group_1_lock  <= `FALSE;    else if(e_load) exe_prefix_group_1_lock  <= rd_prefix_group_1_lock;  end
+always @(posedge clk) begin if(rst) exe_prefix_2byte         <= `FALSE;    else if(e_load) exe_prefix_2byte         <= rd_prefix_2byte;         end
+always @(posedge clk) begin if(rst) exe_consumed             <= 4'd0;      else if(e_load) exe_consumed             <= rd_consumed;             end
+always @(posedge clk) begin if(rst) exe_is_8bit              <= `FALSE;    else if(e_load) exe_is_8bit              <= rd_is_8bit;              end
+always @(posedge clk) begin if(rst) exe_cmdex                <= 4'd0;      else if(e_load) exe_cmdex                <= rd_cmdex;                end
+always @(posedge clk) begin if(rst) exe_modregrm_imm         <= 8'd0;      else if(e_load) exe_modregrm_imm         <= rd_modregrm_imm[7:0];    end
+always @(posedge clk) begin if(rst) exe_dst_is_reg           <= `FALSE;    else if(e_load) exe_dst_is_reg           <= rd_dst_is_reg;           end
+always @(posedge clk) begin if(rst) exe_dst_is_rm            <= `FALSE;    else if(e_load) exe_dst_is_rm            <= rd_dst_is_rm;            end
+always @(posedge clk) begin if(rst) exe_dst_is_memory        <= `FALSE;    else if(e_load) exe_dst_is_memory        <= rd_dst_is_memory;        end
+always @(posedge clk) begin if(rst) exe_dst_is_eax           <= `FALSE;    else if(e_load) exe_dst_is_eax           <= rd_dst_is_eax;           end
+always @(posedge clk) begin if(rst) exe_dst_is_edx_eax       <= `FALSE;    else if(e_load) exe_dst_is_edx_eax       <= rd_dst_is_edx_eax;       end
+always @(posedge clk) begin if(rst) exe_dst_is_implicit_reg  <= `FALSE;    else if(e_load) exe_dst_is_implicit_reg  <= rd_dst_is_implicit_reg;  end
+always @(posedge clk) begin if(rst) exe_extra                <= 32'd0;     else if(e_load) exe_extra                <= rd_extra_wire;           end
+always @(posedge clk) begin if(rst) exe_linear               <= 32'd0;     else if(e_load) exe_linear               <= rd_linear;               end
+always @(posedge clk) begin if(rst) exe_debug_read           <= 4'd0;      else if(e_load) exe_debug_read           <= rd_debug_read;           end
+always @(posedge clk) begin if(rst) src                      <= 32'd0;     else if(e_load) src                      <= src_wire;                end
+always @(posedge clk) begin if(rst) dst                      <= 32'd0;     else if(e_load) dst                      <= dst_wire;                end
+always @(posedge clk) begin if(rst) exe_address_effective    <= 32'd0;     else if(e_load) exe_address_effective    <= rd_address_effective;    end
+
+always @(posedge clk) begin
+    if(rst)   exe_mutex <= 11'd0;
     else if(exe_reset)  exe_mutex <= 11'd0;
     else if(e_load)     exe_mutex <= rd_mutex_next;
     else if(exe_ready)  exe_mutex <= 11'd0;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   exe_cmd <= `CMD_NULL;
+always @(posedge clk) begin
+    if(rst)   exe_cmd <= `CMD_NULL;
     else if(exe_reset)  exe_cmd <= `CMD_NULL;
     else if(e_load)     exe_cmd <= rd_cmd;
     else if(exe_ready)  exe_cmd <= `CMD_NULL;
@@ -391,8 +424,6 @@ assign exe_consumed_final = (exe_task_switch_finished)?   glob_param_3[21:18] :
 
 //------------------------------------------------------------------------------ eip
 
-wire        exe_branch;
-wire [31:0] exe_branch_eip;
 
 assign exe_eip_final =
     (exe_eip_from_glob_param_2 && ~(exe_task_switch_finished))? glob_param_2 :
@@ -402,27 +433,7 @@ assign exe_eip_final =
 
 //------------------------------------------------------------------------------
 
-wire offset_ret_far_se;
-wire offset_new_stack;
-wire offset_new_stack_minus;
-wire offset_new_stack_continue;
-wire offset_leave;
-wire offset_pop;
-wire offset_enter_last;
-wire offset_ret;
-wire offset_iret_glob_param_4;
-wire offset_iret;
-wire offset_ret_imm;
-wire offset_esp;
-wire offset_call;
-wire offset_call_keep;
-wire offset_call_int_same_first;
-wire offset_call_int_same_next;
-wire offset_int_real;
-wire offset_int_real_next;
-wire offset_task;
 
-wire [31:0] exe_enter_offset;
 
 execute_offset execute_offset_inst(
     
@@ -472,13 +483,7 @@ execute_offset execute_offset_inst(
 
 //------------------------------------------------------------------------------
 
-wire e_shift_no_write;
-wire e_shift_oszapc_update;
-wire e_shift_cf_of_update;
-wire e_shift_oflag;
-wire e_shift_cflag;
 
-wire [31:0] e_shift_result;
 
 execute_shift execute_shift_inst(
     
@@ -511,12 +516,10 @@ execute_shift execute_shift_inst(
 
 //------------------------------------------------------------------------------
 
-wire [65:0] mult_result;
-wire        mult_busy;    
 
 execute_multiply execute_multiply_inst(
     .clk                    (clk),
-    .rst_n                  (rst_n),
+    .rst                  (rst),
     
     .exe_reset              (exe_reset),
     
@@ -536,14 +539,11 @@ execute_multiply execute_multiply_inst(
 );
 
 //------------------------------------------------------------------------------
-wire        div_busy;
 
-wire [31:0] div_result_quotient;
-wire [31:0] div_result_remainder;
 
 execute_divide execute_divide_inst(
     .clk                    (clk),
-    .rst_n                  (rst_n),
+    .rst                  (rst),
     
     .exe_reset              (exe_reset),
     .exe_ready              (exe_ready),
@@ -571,7 +571,7 @@ execute_divide execute_divide_inst(
 
 execute_commands execute_commands_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     .exe_reset          (exe_reset),
     
@@ -835,7 +835,7 @@ execute_commands execute_commands_inst(
 //------------------------------------------------------------------------------
 
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, cs_cache[63:56], cs_cache[54:52], cs_cache[47:16], rd_decoder[87:24], rd_modregrm_imm[31:8], 1'b0 };
+ assign _unused_ok = &{ 1'b0, cs_cache[63:56], cs_cache[54:52], cs_cache[47:16], rd_decoder[87:24], rd_modregrm_imm[31:8], 1'b0 };
 // synthesis translate_on
 
 //------------------------------------------------------------------------------
diff --git a/rtl/ao486/pipeline/execute_commands.v b/rtl/ao486/pipeline/execute_commands.v
index 428fabc..0d853ed 100644
--- a/rtl/ao486/pipeline/execute_commands.v
+++ b/rtl/ao486/pipeline/execute_commands.v
@@ -30,7 +30,7 @@
 
 module execute_commands(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               exe_reset,
     
@@ -295,22 +295,385 @@ module execute_commands(
 );
 
 //------------------------------------------------------------------------------ 
+reg e_invd_code_done;
+reg e_invd_data_done;
+reg e_wbinvd_code_done;
+reg e_wbinvd_data_done;
+wire [31:0] exe_buffer_to_reg ;
+wire exe_jecxz_condition;
+wire [3:0] e_io_allow_bits;
+wire exe_int_2_int_trap_same_exception;
+wire [7:0] e_aad_result;
+wire [1:0] e_cpl_current;
+wire [4:0]  e_bit_selector;
+wire        e_bit_selected;
+wire        e_bit_value;
+wire [31:0] e_bit_result;
+wire [31:0] e_cr0_reg;
+wire        e_cmpxchg_eq;
+wire [32:0] e_cmpxchg_sub;
+wire [31:0] e_cmpxchg_result;
+wire exe_cmd_loop_ecx;
+wire exe_cmd_loop_condition;
+wire exe_cmd_lar_desc_invalid;
+wire exe_cmd_lsl_desc_invalid;
+wire exe_cmd_verr_desc_invalid;
+wire exe_cmd_verw_desc_invalid;
+wire signed [31:0] e_bound_min;
+wire signed [31:0] e_bound_max;
+wire signed [31:0] e_bound_dst;
+wire [31:0] exe_new_tss_max;
+wire e_bcd_condition_cf;
+wire exe_bcd_condition_af;
+wire exe_bcd_condition_cf;
+wire [15:0] e_aaa_sum_ax;
+wire [15:0] e_aaa_result;
+wire [15:0] e_aas_sub_ax;
+wire [15:0] e_aas_result;
+wire [7:0]  e_daa_sum_low;
+wire [7:0]  e_daa_step1;
+wire [7:0]  e_daa_sum_high;
+wire [7:0]  e_daa_result;
+wire [7:0]  e_das_sub_low;
+wire [7:0]  e_das_step1;
+wire [7:0]  e_das_sub_high;
+wire [7:0]  e_das_result;
+wire [4:0]  e_bit_scan_forward;
+wire        e_bit_scan_zero;
+wire [31:0] e_src_ze;
+wire [4:0]  e_bit_scan_reverse;
+wire cond_0;
+wire cond_1;
+wire cond_2;
+wire cond_3;
+wire cond_4;
+wire cond_5;
+wire cond_6;
+wire cond_7;
+wire cond_8;
+wire cond_9;
+wire cond_10;
+wire cond_11;
+wire cond_12;
+wire cond_13;
+wire cond_14;
+wire cond_15;
+wire cond_16;
+wire cond_17;
+wire cond_18;
+wire cond_19;
+wire cond_20;
+wire cond_21;
+wire cond_22;
+wire cond_23;
+wire cond_24;
+wire cond_25;
+wire cond_26;
+wire cond_27;
+wire cond_28;
+wire cond_29;
+wire cond_30;
+wire cond_31;
+wire cond_32;
+wire cond_33;
+wire cond_34;
+wire cond_35;
+wire cond_36;
+wire cond_37;
+wire cond_38;
+wire cond_39;
+wire cond_40;
+wire cond_41;
+wire cond_42;
+wire cond_43;
+wire cond_44;
+wire cond_45;
+wire cond_46;
+wire cond_47;
+wire cond_48;
+wire cond_49;
+wire cond_50;
+wire cond_51;
+wire cond_52;
+wire cond_53;
+wire cond_54;
+wire cond_55;
+wire cond_56;
+wire cond_57;
+wire cond_58;
+wire cond_59;
+wire cond_60;
+wire cond_61;
+wire cond_62;
+wire cond_63;
+wire cond_64;
+wire cond_65;
+wire cond_66;
+wire cond_67;
+wire cond_68;
+wire cond_69;
+wire cond_70;
+wire cond_71;
+wire cond_72;
+wire cond_73;
+wire cond_74;
+wire cond_75;
+wire cond_76;
+wire cond_77;
+wire cond_78;
+wire cond_79;
+wire cond_80;
+wire cond_81;
+wire cond_82;
+wire cond_83;
+wire cond_84;
+wire cond_85;
+wire cond_86;
+wire cond_87;
+wire cond_88;
+wire cond_89;
+wire cond_90;
+wire cond_91;
+wire cond_92;
+wire cond_93;
+wire cond_94;
+wire cond_95;
+wire cond_96;
+wire cond_97;
+wire cond_98;
+wire cond_99;
+wire cond_100;
+wire cond_101;
+wire cond_102;
+wire cond_103;
+wire cond_104;
+wire cond_105;
+wire cond_106;
+wire cond_107;
+wire cond_108;
+wire cond_109;
+wire cond_110;
+wire cond_111;
+wire cond_112;
+wire cond_113;
+wire cond_114;
+wire cond_115;
+wire cond_116;
+wire cond_117;
+wire cond_118;
+wire cond_119;
+wire cond_120;
+wire cond_121;
+wire cond_122;
+wire cond_123;
+wire cond_124;
+wire cond_125;
+wire cond_126;
+wire cond_127;
+wire cond_128;
+wire cond_129;
+wire cond_130;
+wire cond_131;
+wire cond_132;
+wire cond_133;
+wire cond_134;
+wire cond_135;
+wire cond_136;
+wire cond_137;
+wire cond_138;
+wire cond_139;
+wire cond_140;
+wire cond_141;
+wire cond_142;
+wire cond_143;
+wire cond_144;
+wire cond_145;
+wire cond_146;
+wire cond_147;
+wire cond_148;
+wire cond_149;
+wire cond_150;
+wire cond_151;
+wire cond_152;
+wire cond_153;
+wire cond_154;
+wire cond_155;
+wire cond_156;
+wire cond_157;
+wire cond_158;
+wire cond_159;
+wire cond_160;
+wire cond_161;
+wire cond_162;
+wire cond_163;
+wire cond_164;
+wire cond_165;
+wire cond_166;
+wire cond_167;
+wire cond_168;
+wire cond_169;
+wire cond_170;
+wire cond_171;
+wire cond_172;
+wire cond_173;
+wire cond_174;
+wire cond_175;
+wire cond_176;
+wire cond_177;
+wire cond_178;
+wire cond_179;
+wire cond_180;
+wire cond_181;
+wire cond_182;
+wire cond_183;
+wire cond_184;
+wire cond_185;
+wire cond_186;
+wire cond_187;
+wire cond_188;
+wire cond_189;
+wire cond_190;
+wire cond_191;
+wire cond_192;
+wire cond_193;
+wire cond_194;
+wire cond_195;
+wire cond_196;
+wire cond_197;
+wire cond_198;
+wire cond_199;
+wire cond_200;
+wire cond_201;
+wire cond_202;
+wire cond_203;
+wire cond_204;
+wire cond_205;
+wire cond_206;
+wire cond_207;
+wire cond_208;
+wire cond_209;
+wire cond_210;
+wire cond_211;
+wire cond_212;
+wire cond_213;
+wire cond_214;
+wire cond_215;
+wire cond_216;
+wire cond_217;
+wire cond_218;
+wire cond_219;
+wire cond_220;
+wire cond_221;
+wire cond_222;
+wire cond_223;
+wire cond_224;
+wire cond_225;
+wire cond_226;
+wire cond_227;
+wire cond_228;
+wire cond_229;
+wire cond_230;
+wire cond_231;
+wire cond_232;
+wire cond_233;
+wire cond_234;
+wire cond_235;
+wire cond_236;
+wire cond_237;
+wire cond_238;
+wire cond_239;
+wire cond_240;
+wire cond_241;
+wire cond_242;
+wire cond_243;
+wire cond_244;
+wire cond_245;
+wire cond_246;
+wire cond_247;
+wire cond_248;
+wire cond_249;
+wire cond_250;
+wire cond_251;
+wire cond_252;
+wire cond_253;
+wire cond_254;
+wire cond_255;
+wire cond_256;
+wire cond_257;
+wire cond_258;
+wire cond_259;
+wire cond_260;
+wire cond_261;
+wire cond_262;
+wire cond_263;
+wire cond_264;
+wire cond_265;
+wire cond_266;
+wire cond_267;
+wire cond_268;
+wire cond_269;
+wire cond_270;
+wire cond_271;
+wire cond_272;
+wire cond_273;
+wire cond_274;
+wire cond_275;
+wire cond_276;
+wire cond_277;
+wire cond_278;
+wire cond_279;
+wire cond_280;
+wire cond_281;
+wire cond_282;
+wire cond_283;
+wire cond_284;
+wire cond_285;
+wire cond_286;
+wire cond_287;
+wire cond_288;
+wire cond_289;
+wire cond_290;
+wire cond_291;
+wire cond_292;
+wire cond_293;
+wire cond_294;
+wire cond_295;
+wire cond_296;
+wire cond_297;
+wire cond_298;
+wire cond_299;
 
 //------------------------------------------------------------------------------ eflags
 
 wire [31:0] exe_push_eflags;
 wire [31:0] exe_pushf_eflags;
+wire [2:0]  exe_segment;
+wire [15:0] exe_selector;
+wire [63:0] exe_descriptor;
+
+wire exe_privilege_not_accepted;
+wire        exe_buffer_shift;
+wire        exe_buffer_shift_word;
+wire [32:0] exe_arith_adc;
+wire [32:0] exe_arith_add;
+wire [31:0] exe_arith_and;
+wire [31:0] exe_arith_not;
+wire [31:0] exe_arith_or;
+wire [32:0] exe_arith_sub;
+wire [32:0] exe_arith_sbb;
+wire [31:0] exe_arith_xor;
+
+wire        exe_cmpxchg_switch_carry;
+
+wire [15:0] e_seg_by_cmdex;
+wire [31:0] e_eip_next_sum;
+wire exe_condition;    
 
 assign exe_push_eflags   = { 10'b0,idflag,2'b0,acflag,vmflag,rflag,1'b0,ntflag,iopl,oflag,dflag,iflag,tflag,sflag,zflag,1'b0,aflag,1'b0,pflag,1'b1,cflag };
 assign exe_pushf_eflags  = { 10'b0,idflag,2'b0,acflag,1'b0,  1'b0, 1'b0,ntflag,iopl,oflag,dflag,iflag,tflag,sflag,zflag,1'b0,aflag,1'b0,pflag,1'b1,cflag };
                          
 //------------------------------------------------------------------------------ descriptor load seg
 
-wire [2:0]  exe_segment;
-wire [15:0] exe_selector;
-wire [63:0] exe_descriptor;
-
-wire exe_privilege_not_accepted;
 
 assign exe_segment    = glob_param_1[18:16];
 assign exe_selector   = glob_param_1[15:0];
@@ -322,27 +685,15 @@ assign exe_privilege_not_accepted =
 
 //------------------------------------------------------------------------------ exe_buffer
     
-wire        exe_buffer_shift;
-wire        exe_buffer_shift_word;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               exe_buffer_shifted <= 464'd0;
+always @(posedge clk) begin
+    if(rst)               exe_buffer_shifted <= 464'd0;
     else if(exe_buffer_shift)       exe_buffer_shifted <= { exe_buffer_shifted[431:0], exe_buffer };
     else if(exe_buffer_shift_word)  exe_buffer_shifted <= { exe_buffer_shifted[447:0], exe_buffer[15:0] };
 end
 
 //------------------------------------------------------------------------------ 
 
-wire [32:0] exe_arith_adc;
-wire [32:0] exe_arith_add;
-wire [31:0] exe_arith_and;
-wire [31:0] exe_arith_not;
-wire [31:0] exe_arith_or;
-wire [32:0] exe_arith_sub;
-wire [32:0] exe_arith_sbb;
-wire [31:0] exe_arith_xor;
-
-wire        exe_cmpxchg_switch_carry;
 
 assign exe_arith_adc   = src + dst + { 31'd0, cflag };
 assign exe_arith_add   = src + dst;
@@ -360,7 +711,6 @@ assign exe_arith_sbb_carry = exe_arith_sbb[32];
 
 //------------------------------------------------------------------------------ 
 
-wire [15:0] e_seg_by_cmdex;
 
 assign e_seg_by_cmdex =
     (exe_cmdex[2:0] == 3'd0)?   es :
@@ -379,8 +729,7 @@ assign task_eip   = (glob_descriptor[`DESC_BITS_TYPE] <= 4'd3)? { 16'd0, exe_buf
 
 //------------------------------------------------------------------------------ Jcc, JCXZ, LOOP
 
-wire [31:0] e_eip_next_sum;
-    
+
 assign e_eip_next_sum =
     (exe_is_8bit)?          exe_eip + { {24{exe_decoder[15]}}, exe_decoder[15:8] } :
     (exe_operand_16bit)?    exe_eip + { {16{exe_decoder[23]}}, exe_decoder[23:8] } :
@@ -392,7 +741,7 @@ assign exe_branch_eip =
 
 //------------------------------------------------------------------------------ Jcc, SETcc
 
-wire exe_condition;
+
 
 condition exe_condition_inst(
     .oflag      (oflag), //input
diff --git a/rtl/ao486/pipeline/execute_divide.v b/rtl/ao486/pipeline/execute_divide.v
index 4f48960..d025a0f 100644
--- a/rtl/ao486/pipeline/execute_divide.v
+++ b/rtl/ao486/pipeline/execute_divide.v
@@ -28,7 +28,7 @@
 
 module execute_divide(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               exe_reset,
     input               exe_ready,
@@ -94,8 +94,8 @@ assign div_working= div_counter > 6'd1;
 assign div_busy   = div_counter != 6'd0 || ~(div_one_time);
 //div_end condition: div_counter == 6'd1 && ~(exe_div_exception)
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)            div_one_time <= `FALSE;
+always @(posedge clk) begin
+    if(rst)            div_one_time <= `FALSE;
     else if(exe_reset)           div_one_time <= `FALSE;
     else if(exe_ready)           div_one_time <= `FALSE;
     else if(div_counter > 6'd1)  div_one_time <= `TRUE;
@@ -111,14 +111,14 @@ assign div_exception_zero = div_counter == 6'd0 && (exe_cmd == `CMD_IDIV || exe_
     (exe_operand_16bit  && src[15:0] == 16'd0) ||
     (exe_operand_32bit  && src       == 32'd0) );
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               div_overflow_waiting <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                               div_overflow_waiting <= `FALSE;
     else if(exe_reset)                              div_overflow_waiting <= `FALSE;
     else if(div_counter == 6'd1 && div_overflow)    div_overflow_waiting <= `TRUE;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       div_counter <= 6'd0;
+always @(posedge clk) begin
+    if(rst)                       div_counter <= 6'd0;
     else if(exe_reset)                      div_counter <= 6'd0;
     else if(div_start && exe_is_8bit)       div_counter <= 6'd10;
     else if(div_start && exe_operand_16bit) div_counter <= 6'd18;
@@ -141,15 +141,15 @@ assign div_denom_neg = -div_denom;
                             
 assign div_diff = div_dividend - div_divisor;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               div_dividend <= 64'd0;
+always @(posedge clk) begin
+    if(rst)                               div_dividend <= 64'd0;
     else if(div_start && div_numer[64] == 1'b0)     div_dividend <=  div_numer[63:0];
     else if(div_start && div_numer[64] == 1'b1)     div_dividend <= -div_numer[63:0];
     else if(div_working && div_diff[64] == 1'b0)    div_dividend <= div_diff[63:0];
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   div_divisor <= 64'd0;
+always @(posedge clk) begin
+    if(rst)                                                   div_divisor <= 64'd0;
     else if(div_start && div_denom[32] == 1'b0 && exe_is_8bit)          div_divisor <= { 48'd0, div_denom    [7:0], 8'd0 };
     else if(div_start && div_denom[32] == 1'b1 && exe_is_8bit)          div_divisor <= { 48'd0, div_denom_neg[7:0], 8'd0 };
     else if(div_start && div_denom[32] == 1'b0 && exe_operand_16bit)    div_divisor <= { 32'd0, div_denom    [15:0],16'd0 };
@@ -159,8 +159,8 @@ always @(posedge clk or negedge rst_n) begin
     else if(div_working)                                                div_divisor <= { 1'b0, div_divisor[63:1] };
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               div_quotient <= 33'd0;
+always @(posedge clk) begin
+    if(rst)                               div_quotient <= 33'd0;
     else if(div_start)                              div_quotient <= 33'd0;
     else if(div_working && div_diff[64] == 1'b0)    div_quotient <= { div_quotient[31:0], 1'b1 };
     else if(div_working && div_diff[64] == 1'b1)    div_quotient <= { div_quotient[31:0], 1'b0 };
diff --git a/rtl/ao486/pipeline/execute_multiply.v b/rtl/ao486/pipeline/execute_multiply.v
index a14a796..130c2c8 100644
--- a/rtl/ao486/pipeline/execute_multiply.v
+++ b/rtl/ao486/pipeline/execute_multiply.v
@@ -28,7 +28,7 @@
 
 module execute_multiply(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               exe_reset,
     
@@ -62,8 +62,8 @@ assign mult_start = mult_counter == 2'd0 && (exe_cmd == `CMD_IMUL || exe_cmd ==
 assign mult_busy  = mult_counter != 2'd1;
 //mult_end condition: mult_counter == 2'd1
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               mult_counter <= 2'd0;
+always @(posedge clk) begin
+    if(rst)               mult_counter <= 2'd0;
     else if(exe_reset)              mult_counter <= 2'd0;
     else if(mult_start)             mult_counter <= 2'd2;
     else if(mult_counter != 2'd0)   mult_counter <= mult_counter - 2'd1;
diff --git a/rtl/ao486/pipeline/fetch.v b/rtl/ao486/pipeline/fetch.v
index 45f41da..dc0ce17 100644
--- a/rtl/ao486/pipeline/fetch.v
+++ b/rtl/ao486/pipeline/fetch.v
@@ -28,7 +28,7 @@
 
 module fetch(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               pr_reset,
     
@@ -55,7 +55,8 @@ module fetch(
 //------------------------------------------------------------------------------
 
 wire partial;
-
+reg [3:0] fetch_count;
+   
 //------------------------------------------------------------------------------
 
 assign prefetch_eip = wr_eip;
@@ -86,9 +87,9 @@ assign partial                  = dec_acceptable <  fetch_valid && prefetchfifo_
 
 //------------------------------------------------------------------------------
 
-reg [3:0] fetch_count;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               fetch_count <= 4'd0;
+
+always @(posedge clk) begin
+    if(rst)               fetch_count <= 4'd0;
     else if(pr_reset)               fetch_count <= 4'd0;
     else if(prefetchfifo_accept_do) fetch_count <= 4'd0;
     else if(partial)                fetch_count <= fetch_count + dec_acceptable;
diff --git a/rtl/ao486/pipeline/microcode.v b/rtl/ao486/pipeline/microcode.v
index 0628706..4e09e13 100644
--- a/rtl/ao486/pipeline/microcode.v
+++ b/rtl/ao486/pipeline/microcode.v
@@ -28,7 +28,7 @@
 
 module microcode(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               micro_reset,
     
@@ -119,6 +119,12 @@ reg [31:0]  mc_eip;
 
 reg [5:0]   mc_step;
 reg [3:0]   mc_cmdex_last;
+
+wire [6:0]  mc_cmd_next;
+wire [6:0]  mc_cmd_current;
+
+wire [3:0]  mc_cmdex_current;
+
 //------------------------------------------------------------------------------
 
 assign micro_busy  = rd_busy || m_overlay;
@@ -133,14 +139,10 @@ assign task_start  = micro_cmd == `CMD_task_switch_4 && micro_cmdex == `CMDEX_ta
 
 //------------------------------------------------------------------------------
 
-wire [6:0]  mc_cmd_next;
-wire [6:0]  mc_cmd_current;
-
-wire [3:0]  mc_cmdex_current;
 
 microcode_commands microcode_commands_inst(
     .clk                    (clk),
-    .rst_n                  (rst_n),
+    .rst                  (rst),
     
     .protected_mode         (protected_mode),    //input
     .real_mode              (real_mode),         //input
@@ -174,39 +176,39 @@ microcode_commands microcode_commands_inst(
 
 //------------------------------------------------------------------------------
     
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) mc_operand_32bit       <= `FALSE; else if(m_load) mc_operand_32bit       <= dec_operand_32bit;       else if(exc_init) mc_operand_32bit       <= `FALSE;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) mc_address_32bit       <= `FALSE; else if(m_load) mc_address_32bit       <= dec_address_32bit;       else if(exc_init) mc_address_32bit       <= `FALSE;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) mc_prefix_group_1_rep  <= 2'd0;   else if(m_load) mc_prefix_group_1_rep  <= dec_prefix_group_1_rep;  else if(exc_init) mc_prefix_group_1_rep  <= 2'd0;    end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) mc_prefix_group_1_lock <= `FALSE; else if(m_load) mc_prefix_group_1_lock <= dec_prefix_group_1_lock; else if(exc_init) mc_prefix_group_1_lock <= `FALSE;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) mc_prefix_group_2_seg  <= 3'd3;   else if(m_load) mc_prefix_group_2_seg  <= dec_prefix_group_2_seg;  else if(exc_init) mc_prefix_group_2_seg  <= 3'd3;    end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) mc_prefix_2byte        <= `FALSE; else if(m_load) mc_prefix_2byte        <= dec_prefix_2byte;        else if(exc_init) mc_prefix_2byte        <= `FALSE;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) mc_decoder             <= 88'd0;  else if(m_load) mc_decoder             <= decoder[87:0];           else if(exc_init) mc_decoder             <= 88'd0;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) mc_modregrm_len        <= 3'd0;   else if(m_load) mc_modregrm_len        <= dec_modregrm_len;        else if(exc_init) mc_modregrm_len        <= 3'd0;    end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) mc_is_8bit             <= `FALSE; else if(m_load) mc_is_8bit             <= dec_is_8bit;             else if(exc_init) mc_is_8bit             <= `FALSE;  end
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       mc_cmd <= `CMD_NULL;
+always @(posedge clk) begin if(rst) mc_operand_32bit       <= `FALSE; else if(m_load) mc_operand_32bit       <= dec_operand_32bit;       else if(exc_init) mc_operand_32bit       <= `FALSE;  end
+always @(posedge clk) begin if(rst) mc_address_32bit       <= `FALSE; else if(m_load) mc_address_32bit       <= dec_address_32bit;       else if(exc_init) mc_address_32bit       <= `FALSE;  end
+always @(posedge clk) begin if(rst) mc_prefix_group_1_rep  <= 2'd0;   else if(m_load) mc_prefix_group_1_rep  <= dec_prefix_group_1_rep;  else if(exc_init) mc_prefix_group_1_rep  <= 2'd0;    end
+always @(posedge clk) begin if(rst) mc_prefix_group_1_lock <= `FALSE; else if(m_load) mc_prefix_group_1_lock <= dec_prefix_group_1_lock; else if(exc_init) mc_prefix_group_1_lock <= `FALSE;  end
+always @(posedge clk) begin if(rst) mc_prefix_group_2_seg  <= 3'd3;   else if(m_load) mc_prefix_group_2_seg  <= dec_prefix_group_2_seg;  else if(exc_init) mc_prefix_group_2_seg  <= 3'd3;    end
+always @(posedge clk) begin if(rst) mc_prefix_2byte        <= `FALSE; else if(m_load) mc_prefix_2byte        <= dec_prefix_2byte;        else if(exc_init) mc_prefix_2byte        <= `FALSE;  end
+always @(posedge clk) begin if(rst) mc_decoder             <= 88'd0;  else if(m_load) mc_decoder             <= decoder[87:0];           else if(exc_init) mc_decoder             <= 88'd0;   end
+always @(posedge clk) begin if(rst) mc_modregrm_len        <= 3'd0;   else if(m_load) mc_modregrm_len        <= dec_modregrm_len;        else if(exc_init) mc_modregrm_len        <= 3'd0;    end
+always @(posedge clk) begin if(rst) mc_is_8bit             <= `FALSE; else if(m_load) mc_is_8bit             <= dec_is_8bit;             else if(exc_init) mc_is_8bit             <= `FALSE;  end
+
+always @(posedge clk) begin
+    if(rst)       mc_cmd <= `CMD_NULL;
     else if(exc_init)       mc_cmd <= `CMD_int;
     else if(micro_reset)    mc_cmd <= `CMD_NULL;
     else if(m_load)         mc_cmd <= dec_cmd;
     else if(micro_ready)    mc_cmd <= mc_cmd_next;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   mc_cmdex <= 4'd0;
+always @(posedge clk) begin
+    if(rst)   mc_cmdex <= 4'd0;
     else if(m_load)     mc_cmdex <= dec_cmdex;
     else if(exc_init)   mc_cmdex <= `CMDEX_int_STEP_0;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   mc_consumed <= 4'd0;
+always @(posedge clk) begin
+    if(rst)   mc_consumed <= 4'd0;
     else if(m_load)     mc_consumed <= dec_consumed;
     else if(task_start) mc_consumed <= 4'd0;
     else if(exc_load)   mc_consumed <= 4'd0;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   mc_eip <= 32'd0;
+always @(posedge clk) begin
+    if(rst)   mc_eip <= 32'd0;
     else if(m_load)     mc_eip <= dec_eip;
     else if(task_start) mc_eip <= task_eip;
     else if(exc_load)   mc_eip <= exc_eip;
@@ -248,16 +250,16 @@ assign micro_eip =
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       mc_step <= 6'd0;
+always @(posedge clk) begin
+    if(rst)       mc_step <= 6'd0;
     else if(m_load)         mc_step <= 6'd1;
     else if(micro_ready)    mc_step <= mc_step + 6'd1;
     else if(exc_init)       mc_step <= 6'd1;
 end
 
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       mc_cmdex_last <= 4'd0;
+always @(posedge clk) begin
+    if(rst)       mc_cmdex_last <= 4'd0;
     else if(micro_ready)    mc_cmdex_last <= micro_cmdex;
     else if(exc_init)       mc_cmdex_last <= `CMDEX_int_STEP_0;
 end
diff --git a/rtl/ao486/pipeline/microcode_commands.v b/rtl/ao486/pipeline/microcode_commands.v
index 2a9e44e..5974c21 100644
--- a/rtl/ao486/pipeline/microcode_commands.v
+++ b/rtl/ao486/pipeline/microcode_commands.v
@@ -30,7 +30,7 @@
 
 module microcode_commands(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               protected_mode,
     input               real_mode,
diff --git a/rtl/ao486/pipeline/pipeline.v b/rtl/ao486/pipeline/pipeline.v
index ea23276..5ae3073 100644
--- a/rtl/ao486/pipeline/pipeline.v
+++ b/rtl/ao486/pipeline/pipeline.v
@@ -28,7 +28,7 @@
 
 module pipeline(
     input           clk,
-    input           rst_n,
+    input           rst,
     
     //to memory
     output              pr_reset,
@@ -267,33 +267,9 @@ module pipeline(
 );
 
 //------------------------------------------------------------------------------
-
-// synthesis translate_off
-wire _unused_ok = &{ 1'b0, SW[16:7], 1'b0 };
-// synthesis translate_on
-
-//------------------------------------------------------------------------------
-
-assign prefetch_cpl = cpl;
-
-//------------------------------------------------------------------------------ pipeline state
-
-wire      pipeline_dec_idle;
 reg [1:0] pipeline_dec_idle_counter;
-
-assign pipeline_dec_idle                = rd_dec_is_front && prefetchfifo_accept_empty;
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               pipeline_dec_idle_counter <= 2'd0;
-    else if(pipeline_dec_idle && pipeline_dec_idle_counter < 2'd3)  pipeline_dec_idle_counter <= pipeline_dec_idle_counter + 2'd1;
-    else if(~(pipeline_dec_idle))                                   pipeline_dec_idle_counter <= 2'd0;
-end
-
-assign pipeline_after_read_empty        = rd_is_front;
-assign pipeline_after_prefetch_empty    = pipeline_dec_idle && pipeline_dec_idle_counter == 2'd3;
-
-//------------------------------------------------------------------------------
-
+wire _unused_ok;
+wire      pipeline_dec_idle;
 wire        rd_glob_descriptor_set;
 wire [63:0] rd_glob_descriptor_value;
 wire        rd_glob_descriptor_2_set;
@@ -308,7 +284,6 @@ wire        rd_glob_param_4_set;
 wire [31:0] rd_glob_param_4_value;
 wire        rd_glob_param_5_set;
 wire [31:0] rd_glob_param_5_value;
-
 wire        exe_glob_descriptor_set;
 wire [63:0] exe_glob_descriptor_value;
 wire        exe_glob_descriptor_2_set;
@@ -319,63 +294,24 @@ wire        exe_glob_param_2_set;
 wire [31:0] exe_glob_param_2_value;
 wire        exe_glob_param_3_set;
 wire [31:0] exe_glob_param_3_value;
-
 wire        wr_glob_param_1_set;
 wire [31:0] wr_glob_param_1_value;
 wire        wr_glob_param_3_set;
 wire [31:0] wr_glob_param_3_value;
 wire        wr_glob_param_4_set;
 wire [31:0] wr_glob_param_4_value;
-
-assign glob_descriptor_set      = rd_glob_descriptor_set | exe_glob_descriptor_set;
-assign glob_descriptor_value    = (rd_glob_descriptor_set)? rd_glob_descriptor_value : exe_glob_descriptor_value;
-
-assign glob_descriptor_2_set    = rd_glob_descriptor_2_set | exe_glob_descriptor_2_set;
-assign glob_descriptor_2_value  = (rd_glob_descriptor_2_set)? rd_glob_descriptor_2_value : exe_glob_descriptor_2_value;
-
-assign glob_param_1_set     = rd_glob_param_1_set | exe_glob_param_1_set | wr_glob_param_1_set;
-assign glob_param_1_value   = (rd_glob_param_1_set)? rd_glob_param_1_value : (exe_glob_param_1_set)? exe_glob_param_1_value : wr_glob_param_1_value;
-
-assign glob_param_2_set     = rd_glob_param_2_set | exe_glob_param_2_set;
-assign glob_param_2_value   = (rd_glob_param_2_set)? rd_glob_param_2_value : exe_glob_param_2_value;
-
-assign glob_param_3_set     = rd_glob_param_3_set | exe_glob_param_3_set | wr_glob_param_3_set;
-assign glob_param_3_value   = (rd_glob_param_3_set)? rd_glob_param_3_value : (exe_glob_param_3_set)? exe_glob_param_3_value : wr_glob_param_3_value;
-
-assign glob_param_4_set     = rd_glob_param_4_set | wr_glob_param_4_set;
-assign glob_param_4_value   = (rd_glob_param_4_set)? rd_glob_param_4_value : wr_glob_param_4_value;
-
-assign glob_param_5_set     = rd_glob_param_5_set;
-assign glob_param_5_value   = rd_glob_param_5_value;
-
-//------------------------------------------------------------------------------
-
 wire wr_req_reset_pr;
 wire wr_req_reset_dec;
 wire wr_req_reset_micro;
 wire wr_req_reset_rd;
 wire wr_req_reset_exe;
-
 wire dec_reset;
 wire micro_reset;
-
-assign pr_reset    =                   wr_req_reset_pr;
-assign dec_reset   = exc_dec_reset   | wr_req_reset_dec;
-assign micro_reset = exc_micro_reset | wr_req_reset_micro;
-assign rd_reset    = exc_rd_reset    | wr_req_reset_rd;
-assign exe_reset   = exc_exe_reset   | wr_req_reset_exe;
-assign wr_reset    = exc_wr_reset;
-
-//------------------------------------------------------------------------------
-
 wire [1:0]  cpl;
-
 wire [31:0] gdtr_base;
 wire [15:0] gdtr_limit;
-
 wire [31:0] idtr_base;
 wire [15:0] idtr_limit;
-
 wire        es_cache_valid;
 wire [63:0] es_cache;
 wire        cs_cache_valid;
@@ -391,7 +327,6 @@ wire        tr_cache_valid;
 wire [63:0] tr_cache;
 wire        ldtr_cache_valid;
 wire [63:0] ldtr_cache;
-
 wire        idflag;
 wire        vmflag;
 wire        rflag;
@@ -406,15 +341,12 @@ wire        zflag;
 wire        aflag;
 wire        pflag;
 wire        cflag;
-
 wire        cr0_ne;
 wire        cr0_ts;
 wire        cr0_em;
 wire        cr0_mp;
 wire        cr0_pe;
-
 wire [31:0] cr2;
-
 wire [31:0] eax;
 wire [31:0] ebx;
 wire [31:0] ecx;
@@ -423,7 +355,6 @@ wire [31:0] esp;
 wire [31:0] ebp;
 wire [31:0] esi;
 wire [31:0] edi;
-
 wire [15:0] es;
 wire [15:0] cs;
 wire [15:0] ss;
@@ -432,7 +363,6 @@ wire [15:0] fs;
 wire [15:0] gs;
 wire [15:0] ldtr;
 wire [15:0] tr;
-
 wire [31:0] dr0;
 wire [31:0] dr1;
 wire [31:0] dr2;
@@ -443,21 +373,197 @@ wire        dr6_bd;
 wire        dr6_b12;
 wire [3:0]  dr6_breakpoints;
 wire [31:0] dr7;
+wire [3:0]  fetch_valid;
+wire [63:0] fetch;
+wire        fetch_limit;
+wire        fetch_page_fault;
+wire [3:0]  dec_acceptable;
+wire        v8086_mode;
+wire        protected_mode;
+wire        micro_busy;
+wire        dec_ready;
+wire [95:0] decoder;
+wire        dec_operand_32bit;
+wire        dec_address_32bit;
+wire [1:0]  dec_prefix_group_1_rep;
+wire        dec_prefix_group_1_lock;
+wire [2:0]  dec_prefix_group_2_seg;
+wire        dec_prefix_2byte;
+wire [3:0]  dec_consumed;
+wire [2:0]  dec_modregrm_len;
+wire        dec_is_8bit;
+wire [6:0]  dec_cmd;
+wire [3:0]  dec_cmdex;
+wire        dec_is_complex;
+wire [6:0]  micro_cmd;
+wire [6:0]  rd_cmd;
+wire [31:0] task_eip;
+wire        io_allow_check_needed;
+wire        rd_busy;
+wire        micro_ready;
+wire [87:0] micro_decoder;
+wire [31:0] micro_eip;
+wire        micro_operand_32bit;
+wire        micro_address_32bit;
+wire [1:0]  micro_prefix_group_1_rep;
+wire        micro_prefix_group_1_lock;
+wire [2:0]  micro_prefix_group_2_seg;
+wire        micro_prefix_2byte;
+wire [3:0]  micro_consumed;
+wire [2:0]  micro_modregrm_len;
+wire        micro_is_8bit;
+wire [3:0]  micro_cmdex;
+wire [2:0]  debug_len0;
+wire [2:0]  debug_len1;
+wire [2:0]  debug_len2;
+wire [2:0]  debug_len3;
+wire [10:0] exe_mutex;
+wire [10:0] wr_mutex;
+wire [31:0] wr_esp_prev;
+wire        exe_busy;
+wire        rd_ready;
+wire [87:0] rd_decoder;
+wire        rd_operand_32bit;
+wire        rd_address_32bit;
+wire [1:0]  rd_prefix_group_1_rep;
+wire        rd_prefix_group_1_lock;
+wire        rd_prefix_2byte;
+wire        rd_is_8bit;
+//wire [6:0]  rd_cmd;
+wire [3:0]  rd_cmdex;
+wire [31:0] rd_modregrm_imm;
+wire [10:0] rd_mutex_next;
+wire        rd_dst_is_reg;
+wire        rd_dst_is_rm;
+wire        rd_dst_is_memory;
+wire        rd_dst_is_eax;
+wire        rd_dst_is_edx_eax;
+wire        rd_dst_is_implicit_reg;
+wire [31:0] rd_extra_wire;
+wire [31:0] rd_linear;
+wire [3:0]  rd_debug_read;
+wire [31:0] src_wire;
+wire [31:0] dst_wire;
+wire [31:0] rd_address_effective;
+wire [31:0] wr_stack_offset;
+wire [1:0]  wr_task_rpl;
+wire        dr6_bd_set;
+wire [31:0]  exe_buffer;
+wire [463:0] exe_buffer_shifted;
+wire        wr_busy;
+wire        exe_ready;
+wire [39:0] exe_decoder;
+wire [31:0] exe_eip_final;
+wire        exe_operand_32bit;
+wire        exe_address_32bit;
+wire [1:0]  exe_prefix_group_1_rep;
+wire        exe_prefix_group_1_lock;
+wire [3:0]  exe_consumed_final;
+wire        exe_is_8bit_final;
+wire [6:0]  exe_cmd;
+wire [3:0]  exe_cmdex;
+wire        exe_dst_is_reg;
+wire        exe_dst_is_rm;
+wire        exe_dst_is_memory;
+wire        exe_dst_is_eax;
+wire        exe_dst_is_edx_eax;
+wire        exe_dst_is_implicit_reg;
+wire [31:0] exe_linear;
+wire [3:0]  exe_debug_read;
+wire [31:0] exe_result;
+wire [31:0] exe_result2;
+wire [31:0] exe_result_push;
+wire [4:0]  exe_result_signals;
+wire [3:0]  exe_arith_index;
+wire        exe_arith_sub_carry;
+wire        exe_arith_add_carry;
+wire        exe_arith_adc_carry;
+wire        exe_arith_sbb_carry;
+wire [31:0] src_final;
+wire [31:0] dst_final;
+wire        exe_mult_overflow;
+wire [31:0] exe_stack_offset;
+   
+// synthesis translate_off
+// assign _unused_ok = &{ 1'b0, SW[16:7], 1'b0 };
+// synthesis translate_on
+
+//------------------------------------------------------------------------------
+
+assign prefetch_cpl = cpl;
+
+//------------------------------------------------------------------------------ pipeline state
+
+
+assign pipeline_dec_idle                = rd_dec_is_front && prefetchfifo_accept_empty;
+
+always @(posedge clk) begin
+    if(rst)                                               pipeline_dec_idle_counter <= 2'd0;
+    else if(pipeline_dec_idle && pipeline_dec_idle_counter < 2'd3)  pipeline_dec_idle_counter <= pipeline_dec_idle_counter + 2'd1;
+    else if(~(pipeline_dec_idle))                                   pipeline_dec_idle_counter <= 2'd0;
+end
+
+assign pipeline_after_read_empty        = rd_is_front;
+assign pipeline_after_prefetch_empty    = pipeline_dec_idle && pipeline_dec_idle_counter == 2'd3;
+
+//------------------------------------------------------------------------------
+
+
+
+
+assign glob_descriptor_set      = rd_glob_descriptor_set | exe_glob_descriptor_set;
+assign glob_descriptor_value    = (rd_glob_descriptor_set)? rd_glob_descriptor_value : exe_glob_descriptor_value;
+
+assign glob_descriptor_2_set    = rd_glob_descriptor_2_set | exe_glob_descriptor_2_set;
+assign glob_descriptor_2_value  = (rd_glob_descriptor_2_set)? rd_glob_descriptor_2_value : exe_glob_descriptor_2_value;
+
+assign glob_param_1_set     = rd_glob_param_1_set | exe_glob_param_1_set | wr_glob_param_1_set;
+assign glob_param_1_value   = (rd_glob_param_1_set)? rd_glob_param_1_value : (exe_glob_param_1_set)? exe_glob_param_1_value : wr_glob_param_1_value;
+
+assign glob_param_2_set     = rd_glob_param_2_set | exe_glob_param_2_set;
+assign glob_param_2_value   = (rd_glob_param_2_set)? rd_glob_param_2_value : exe_glob_param_2_value;
+
+assign glob_param_3_set     = rd_glob_param_3_set | exe_glob_param_3_set | wr_glob_param_3_set;
+assign glob_param_3_value   = (rd_glob_param_3_set)? rd_glob_param_3_value : (exe_glob_param_3_set)? exe_glob_param_3_value : wr_glob_param_3_value;
+
+assign glob_param_4_set     = rd_glob_param_4_set | wr_glob_param_4_set;
+assign glob_param_4_value   = (rd_glob_param_4_set)? rd_glob_param_4_value : wr_glob_param_4_value;
+
+assign glob_param_5_set     = rd_glob_param_5_set;
+assign glob_param_5_value   = rd_glob_param_5_value;
+
+//------------------------------------------------------------------------------
+
+
+
+assign pr_reset    =                   wr_req_reset_pr;
+assign dec_reset   = exc_dec_reset   | wr_req_reset_dec;
+assign micro_reset = exc_micro_reset | wr_req_reset_micro;
+assign rd_reset    = exc_rd_reset    | wr_req_reset_rd;
+assign exe_reset   = exc_exe_reset   | wr_req_reset_exe;
+assign wr_reset    = exc_wr_reset;
+
+//------------------------------------------------------------------------------
+
+
+
+
+
+
+
+
+
+
 
 
 
 //------------------------------------------------------------------------------
 
-wire [3:0]  fetch_valid;
-wire [63:0] fetch;
-wire        fetch_limit;
-wire        fetch_page_fault;
 
-wire [3:0]  dec_acceptable;
 
 fetch fetch_inst(
     .clk                        (clk),
-    .rst_n                      (rst_n),
+    .rst                      (rst),
     
     .pr_reset                   (pr_reset),
     
@@ -483,32 +589,13 @@ fetch fetch_inst(
 
 //------------------------------------------------------------------------------
 
-wire        v8086_mode;
-wire        protected_mode;
 
-wire        micro_busy;
-wire        dec_ready;
 
-wire [95:0] decoder;
-wire        dec_operand_32bit;
-wire        dec_address_32bit;
-wire [1:0]  dec_prefix_group_1_rep;
-wire        dec_prefix_group_1_lock;
-wire [2:0]  dec_prefix_group_2_seg;
-wire        dec_prefix_2byte;
-wire [3:0]  dec_consumed;
-wire [2:0]  dec_modregrm_len;
-wire        dec_is_8bit;
-wire [6:0]  dec_cmd;
-wire [3:0]  dec_cmdex;
-wire        dec_is_complex;
 
-wire [6:0]  micro_cmd;
-wire [6:0]  rd_cmd;
 
 decode decode_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     .dec_reset          (dec_reset),            //input
     
@@ -557,28 +644,12 @@ decode decode_inst(
 
 //------------------------------------------------------------------------------
 
-wire [31:0] task_eip;
 
-wire        io_allow_check_needed;
 
-wire        rd_busy;
-wire        micro_ready;
-wire [87:0] micro_decoder;
-wire [31:0] micro_eip;
-wire        micro_operand_32bit;
-wire        micro_address_32bit;
-wire [1:0]  micro_prefix_group_1_rep;
-wire        micro_prefix_group_1_lock;
-wire [2:0]  micro_prefix_group_2_seg;
-wire        micro_prefix_2byte;
-wire [3:0]  micro_consumed;
-wire [2:0]  micro_modregrm_len;
-wire        micro_is_8bit;
-wire [3:0]  micro_cmdex;
 
 microcode microcode_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     .micro_reset        (micro_reset), //input
     
@@ -645,45 +716,13 @@ microcode microcode_inst(
 
 //------------------------------------------------------------------------------
 
-wire [2:0]  debug_len0;
-wire [2:0]  debug_len1;
-wire [2:0]  debug_len2;
-wire [2:0]  debug_len3;
 
-wire [10:0] exe_mutex;
-wire [10:0] wr_mutex;
 
-wire [31:0] wr_esp_prev;
 
-wire        exe_busy;
-wire        rd_ready;
-wire [87:0] rd_decoder;
-wire        rd_operand_32bit;
-wire        rd_address_32bit;
-wire [1:0]  rd_prefix_group_1_rep;
-wire        rd_prefix_group_1_lock;
-wire        rd_prefix_2byte;
-wire        rd_is_8bit;
-//wire [6:0]  rd_cmd;
-wire [3:0]  rd_cmdex;
-wire [31:0] rd_modregrm_imm;
-wire [10:0] rd_mutex_next;
-wire        rd_dst_is_reg;
-wire        rd_dst_is_rm;
-wire        rd_dst_is_memory;
-wire        rd_dst_is_eax;
-wire        rd_dst_is_edx_eax;
-wire        rd_dst_is_implicit_reg;
-wire [31:0] rd_extra_wire;
-wire [31:0] rd_linear;
-wire [3:0]  rd_debug_read;
-wire [31:0] src_wire;
-wire [31:0] dst_wire;
-wire [31:0] rd_address_effective;
 
 read read_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     .rd_reset           (rd_reset), //input
     
@@ -863,51 +902,13 @@ read read_inst(
 
 //------------------------------------------------------------------------------
 
-wire [31:0] wr_stack_offset;
-wire [1:0]  wr_task_rpl;
     
-wire        dr6_bd_set;
 
-wire [31:0]  exe_buffer;
-wire [463:0] exe_buffer_shifted;
 
-wire        wr_busy;
-wire        exe_ready;
-wire [39:0] exe_decoder;
-wire [31:0] exe_eip_final;
-wire        exe_operand_32bit;
-wire        exe_address_32bit;
-wire [1:0]  exe_prefix_group_1_rep;
-wire        exe_prefix_group_1_lock;
-wire [3:0]  exe_consumed_final;
-wire        exe_is_8bit_final;
-wire [6:0]  exe_cmd;
-wire [3:0]  exe_cmdex;
-wire        exe_dst_is_reg;
-wire        exe_dst_is_rm;
-wire        exe_dst_is_memory;
-wire        exe_dst_is_eax;
-wire        exe_dst_is_edx_eax;
-wire        exe_dst_is_implicit_reg;
-wire [31:0] exe_linear;
-wire [3:0]  exe_debug_read;
-wire [31:0] exe_result;
-wire [31:0] exe_result2;
-wire [31:0] exe_result_push;
-wire [4:0]  exe_result_signals;
-wire [3:0]  exe_arith_index;
-wire        exe_arith_sub_carry;
-wire        exe_arith_add_carry;
-wire        exe_arith_adc_carry;
-wire        exe_arith_sbb_carry;
-wire [31:0] src_final;
-wire [31:0] dst_final;
-wire        exe_mult_overflow;
-wire [31:0] exe_stack_offset;
 
 execute execute_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     .exe_reset          (exe_reset),    //input
     
@@ -1150,7 +1151,7 @@ execute execute_inst(
 
 write write_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     .exe_reset          (exe_reset),  //input
     .wr_reset           (wr_reset),   //input
diff --git a/rtl/ao486/pipeline/read.v b/rtl/ao486/pipeline/read.v
index 75d8bad..092e430 100644
--- a/rtl/ao486/pipeline/read.v
+++ b/rtl/ao486/pipeline/read.v
@@ -28,7 +28,7 @@
 
 module read(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               rd_reset,
     
@@ -217,109 +217,36 @@ module read(
 
 //------------------------------------------------------------------------------
 
+reg [2:0]   rd_modregrm_len;
+reg [2:0]   rd_prefix_group_2_seg;
+reg  rd_address_effective_ready_delayed;
+reg  rd_one_mem_read;
+reg  rd_one_io_read;
+reg [31:0]  rd_memory_last;
 wire r_load;
-
 wire [1:0]  rd_modregrm_mod;
 wire [2:0]  rd_modregrm_reg;
 wire [2:0]  rd_modregrm_rm;
 wire [7:0]  rd_sib;
-
 wire        rd_operand_16bit;
 wire        rd_address_16bit;
-
-//------------------------------------------------------------------------------
-
-assign rd_ready = ~(rd_reset) && ~(rd_waiting) && rd_cmd != `CMD_NULL && ~(exe_busy);
-
-assign rd_busy  = rd_waiting || (rd_ready == `FALSE && rd_cmd != `CMD_NULL);
-
-assign r_load = micro_ready;
-
-//------------------------------------------------------------------------------
-
-reg [2:0]   rd_modregrm_len;
-reg [2:0]   rd_prefix_group_2_seg;
-
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_decoder              <= 88'd0;     else if(r_load) rd_decoder              <= micro_decoder;              end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_eip                  <= 32'd0;     else if(r_load) rd_eip                  <= micro_eip;                  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_operand_32bit        <= `FALSE;    else if(r_load) rd_operand_32bit        <= micro_operand_32bit;        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_address_32bit        <= `FALSE;    else if(r_load) rd_address_32bit        <= micro_address_32bit;        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_prefix_group_1_rep   <= 2'd0;      else if(r_load) rd_prefix_group_1_rep   <= micro_prefix_group_1_rep;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_prefix_group_1_lock  <= `FALSE;    else if(r_load) rd_prefix_group_1_lock  <= micro_prefix_group_1_lock;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_prefix_group_2_seg   <= 3'd3;      else if(r_load) rd_prefix_group_2_seg   <= micro_prefix_group_2_seg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_prefix_2byte         <= `FALSE;    else if(r_load) rd_prefix_2byte         <= micro_prefix_2byte;         end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_consumed             <= 4'd0;      else if(r_load) rd_consumed             <= micro_consumed;             end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_modregrm_len         <= 3'd0;      else if(r_load) rd_modregrm_len         <= micro_modregrm_len;         end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_is_8bit              <= `FALSE;    else if(r_load) rd_is_8bit              <= micro_is_8bit;              end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) rd_cmdex                <= 4'd0;      else if(r_load) rd_cmdex                <= micro_cmdex;                end
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   rd_cmd <= `CMD_NULL;
-    else if(rd_reset)   rd_cmd <= `CMD_NULL;
-    else if(r_load)     rd_cmd <= micro_cmd;
-    else if(rd_ready)   rd_cmd <= `CMD_NULL;
-end
-
-//------------------------------------------------------------------------------
-
-assign rd_modregrm_mod = rd_decoder[15:14];
-assign rd_modregrm_reg = rd_decoder[13:11];
-assign rd_modregrm_rm  = rd_decoder[10:8];
-assign rd_sib          = rd_decoder[23:16];
-
-assign rd_operand_16bit = ~(rd_operand_32bit);
-assign rd_address_16bit = ~(rd_address_32bit);
-
-//------------------------------------------------------------------------------
-
 wire        rd_descriptor_not_in_limits;
 wire [31:0] rd_descriptor_offset;
-
-reg  rd_address_effective_ready_delayed;
 wire write_virtual_check_ready;
-
-//------------------------------------------------------------------------------
-
 wire memory_read_system;
-reg  rd_one_mem_read;
 wire read_for_rd_ready;
-
 wire [31:0] read_4;
 wire [63:0] read_8;
-
-//------------------------------------------------------------------------------
-
 wire rd_io_ready;
-reg  rd_one_io_read;
-
-
-//------------------------------------------------------------------------------
-
 wire [2:0]  src_reg_index;
 wire [2:0]  dst_reg_index;
-
-//------------------------------------------------------------------------------
-
-reg [31:0]  rd_memory_last;
-
-//------------------------------------------------------------------------------
-
 wire [31:0] rd_seg_linear;
-
 wire [31:0] tr_base;
 wire [31:0] ldtr_base;
-
 wire [31:0] tr_limit;
 wire [31:0] ldtr_limit;
-
-//------------------------------------------------------------------------------
-
 wire        rd_address_effective_ready;
-
 wire        rd_address_effective_do;
-
-//------------------------------------------------------------------------------
-
 wire rd_mutex_busy_active;
 wire rd_mutex_busy_memory;
 wire rd_mutex_busy_eflags;
@@ -331,14 +258,9 @@ wire rd_mutex_busy_eax;
 wire rd_mutex_busy_modregrm_reg;
 wire rd_mutex_busy_modregrm_rm;
 wire rd_mutex_busy_implicit_reg;
-
 wire rd_address_waiting;
-
-//------------------------------------------------------------------------------
-
 wire [31:0] rd_system_linear;
 wire        rd_waiting;
-
 wire rd_req_memory;
 wire rd_req_eflags;
 wire rd_req_all;
@@ -355,7 +277,6 @@ wire rd_req_edx_eax;
 wire rd_req_edx;
 wire rd_req_ecx;
 wire rd_req_eax;
-
 wire address_enter_init;
 wire address_enter;
 wire address_enter_last;
@@ -382,20 +303,16 @@ wire address_stack_for_call_param_first;
 wire address_ea_buffer;
 wire address_ea_buffer_plus_2;
 wire address_memoffset;
-
 wire read_virtual;
 wire read_rmw_virtual;
 wire write_virtual_check;
-
 wire read_system_descriptor;
 wire read_system_word;
 wire read_system_dword;
 wire read_system_qword;
 wire read_rmw_system_dword;
-
 wire read_length_word;
 wire read_length_dword;
-
 wire rd_src_is_memory;
 wire rd_src_is_io;
 wire rd_src_is_modregrm_imm;
@@ -409,23 +326,109 @@ wire rd_src_is_cmdex;
 wire rd_src_is_implicit_reg;
 wire rd_src_is_rm;
 wire rd_src_is_reg; //not used
-
 wire rd_dst_is_0;
 wire rd_dst_is_modregrm_imm_se;
 wire rd_dst_is_modregrm_imm;
 wire rd_dst_is_memory_last;
 wire rd_dst_is_eip;
+wire _unused_ok;
+wire io_read;
+wire rd_seg_gp_fault_init;
+wire rd_seg_ss_fault_init;
+
+
+//------------------------------------------------------------------------------
+
+assign rd_ready = ~(rd_reset) && ~(rd_waiting) && rd_cmd != `CMD_NULL && ~(exe_busy);
+
+assign rd_busy  = rd_waiting || (rd_ready == `FALSE && rd_cmd != `CMD_NULL);
+
+assign r_load = micro_ready;
+
+//------------------------------------------------------------------------------
+
+
+always @(posedge clk) begin if(rst) rd_decoder              <= 88'd0;     else if(r_load) rd_decoder              <= micro_decoder;              end
+always @(posedge clk) begin if(rst) rd_eip                  <= 32'd0;     else if(r_load) rd_eip                  <= micro_eip;                  end
+always @(posedge clk) begin if(rst) rd_operand_32bit        <= `FALSE;    else if(r_load) rd_operand_32bit        <= micro_operand_32bit;        end
+always @(posedge clk) begin if(rst) rd_address_32bit        <= `FALSE;    else if(r_load) rd_address_32bit        <= micro_address_32bit;        end
+always @(posedge clk) begin if(rst) rd_prefix_group_1_rep   <= 2'd0;      else if(r_load) rd_prefix_group_1_rep   <= micro_prefix_group_1_rep;   end
+always @(posedge clk) begin if(rst) rd_prefix_group_1_lock  <= `FALSE;    else if(r_load) rd_prefix_group_1_lock  <= micro_prefix_group_1_lock;  end
+always @(posedge clk) begin if(rst) rd_prefix_group_2_seg   <= 3'd3;      else if(r_load) rd_prefix_group_2_seg   <= micro_prefix_group_2_seg;   end
+always @(posedge clk) begin if(rst) rd_prefix_2byte         <= `FALSE;    else if(r_load) rd_prefix_2byte         <= micro_prefix_2byte;         end
+always @(posedge clk) begin if(rst) rd_consumed             <= 4'd0;      else if(r_load) rd_consumed             <= micro_consumed;             end
+always @(posedge clk) begin if(rst) rd_modregrm_len         <= 3'd0;      else if(r_load) rd_modregrm_len         <= micro_modregrm_len;         end
+always @(posedge clk) begin if(rst) rd_is_8bit              <= `FALSE;    else if(r_load) rd_is_8bit              <= micro_is_8bit;              end
+always @(posedge clk) begin if(rst) rd_cmdex                <= 4'd0;      else if(r_load) rd_cmdex                <= micro_cmdex;                end
+
+always @(posedge clk) begin
+    if(rst)   rd_cmd <= `CMD_NULL;
+    else if(rd_reset)   rd_cmd <= `CMD_NULL;
+    else if(r_load)     rd_cmd <= micro_cmd;
+    else if(rd_ready)   rd_cmd <= `CMD_NULL;
+end
+
+//------------------------------------------------------------------------------
+
+assign rd_modregrm_mod = rd_decoder[15:14];
+assign rd_modregrm_reg = rd_decoder[13:11];
+assign rd_modregrm_rm  = rd_decoder[10:8];
+assign rd_sib          = rd_decoder[23:16];
+
+assign rd_operand_16bit = ~(rd_operand_32bit);
+assign rd_address_16bit = ~(rd_address_32bit);
+
+//------------------------------------------------------------------------------
+
+
+
+//------------------------------------------------------------------------------
+
+
+
+//------------------------------------------------------------------------------
+
+
+
+//------------------------------------------------------------------------------
+
+
+//------------------------------------------------------------------------------
+
+
+//------------------------------------------------------------------------------
+
+
+
+
+//------------------------------------------------------------------------------
+
+
+
+//------------------------------------------------------------------------------
+
+
+
+//------------------------------------------------------------------------------
+
+
+
+
+
+
+
+
 
 //------------------------------------------------------------------------------
 
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, rd_src_is_reg, 1'b0 };
+ assign _unused_ok = &{ 1'b0, rd_src_is_reg, 1'b0 };
 // synthesis translate_on
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       rd_memory_last <= 32'd0;
+always @(posedge clk) begin
+    if(rst)                       rd_memory_last <= 32'd0;
     else if(read_for_rd_ready && rd_ready)  rd_memory_last <= read_4;
 end
 
@@ -498,8 +501,8 @@ assign dst_wire =
 
 //------------------------------------------------------------------------------ io_read
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               rd_one_io_read <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               rd_one_io_read <= `FALSE;
     else if(rd_ready || rd_reset)   rd_one_io_read <= `FALSE;
     else if(io_read_done)           rd_one_io_read <= `TRUE;
 end
@@ -509,7 +512,6 @@ assign io_read_length =
     (rd_operand_16bit)? 3'd2 :
                         3'd4;
 
-wire io_read;
 
 //NOTE: gp fault from CMDEX_io_allow_2
 assign io_read_do = io_read && ~(io_read_done) && ~(rd_one_io_read) && ~(rd_reset) && ~(exe_trigger_gp_fault);
@@ -518,17 +520,15 @@ assign rd_io_ready = rd_one_io_read || io_read_done;
 
 //------------------------------------------------------------------------------
 
-wire rd_seg_gp_fault_init;
-wire rd_seg_ss_fault_init;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               rd_seg_gp_fault <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               rd_seg_gp_fault <= `FALSE;
     else if(rd_ready || rd_reset)   rd_seg_gp_fault <= `FALSE;
     else                            rd_seg_gp_fault <= rd_seg_gp_fault_init;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               rd_seg_ss_fault <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               rd_seg_ss_fault <= `FALSE;
     else if(rd_ready || rd_reset)   rd_seg_ss_fault <= `FALSE;
     else                            rd_seg_ss_fault <= rd_seg_ss_fault_init;
 end
@@ -560,8 +560,8 @@ assign read_length =
     rd_operand_16bit?           4'd2 :
                                 4'd4;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               rd_one_mem_read <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                                               rd_one_mem_read <= `FALSE;
     else if(rd_ready || rd_reset)                                   rd_one_mem_read <= `FALSE;
     else if(read_done && ~(read_page_fault) && ~(read_ac_fault))    rd_one_mem_read <= `TRUE;
 end
@@ -579,8 +579,8 @@ assign read_8 = read_data;
 
 //------------------------------------------------------------------------------ write check
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       rd_address_effective_ready_delayed <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                                       rd_address_effective_ready_delayed <= `FALSE;
     else if(rd_ready || rd_reset || ~(write_virtual_check)) rd_address_effective_ready_delayed <= `FALSE;
     else                                                    rd_address_effective_ready_delayed <= rd_address_effective_ready;
 end
@@ -672,7 +672,7 @@ read_segment read_segment_inst(
 
 read_effective_address read_effective_address_inst(
     .clk                                (clk),
-    .rst_n                              (rst_n),
+    .rst                              (rst),
     
     .rd_reset                           (rd_reset),                             //input
 
@@ -747,7 +747,7 @@ read_effective_address read_effective_address_inst(
 
 read_debug read_debug_inst(
     .clk            (clk),
-    .rst_n          (rst_n),
+    .rst          (rst),
     
     .dr0            (dr0),          //input [31:0]
     .dr1            (dr1),          //input [31:0]
@@ -773,7 +773,7 @@ read_debug read_debug_inst(
 
 read_commands read_commands_inst(
     .clk                                (clk),
-    .rst_n                              (rst_n),
+    .rst                              (rst),
     
     //general input
     .glob_descriptor                    (glob_descriptor),                      //input [63:0]
diff --git a/rtl/ao486/pipeline/read_commands.v b/rtl/ao486/pipeline/read_commands.v
index ae6c33f..7fec60e 100644
--- a/rtl/ao486/pipeline/read_commands.v
+++ b/rtl/ao486/pipeline/read_commands.v
@@ -30,7 +30,7 @@
 
 module read_commands(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //general input
     input       [63:0]  glob_descriptor,
diff --git a/rtl/ao486/pipeline/read_debug.v b/rtl/ao486/pipeline/read_debug.v
index 3590b24..5098221 100644
--- a/rtl/ao486/pipeline/read_debug.v
+++ b/rtl/ao486/pipeline/read_debug.v
@@ -28,7 +28,7 @@
 
 module read_debug(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input       [31:0]  dr0,
     input       [31:0]  dr1,
@@ -89,8 +89,8 @@ assign rd_debug_b0_trigger =
     ( rd_debug_linear      <= { dr0[31:3], dr0[2:0] | ~(debug_len0)} ) &&
     ( rd_debug_linear_last >= { dr0[31:3], dr0[2:0] &   debug_len0 } );
     
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               rd_debug_b0_reg <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               rd_debug_b0_reg <= `FALSE;
     else if(rd_ready)               rd_debug_b0_reg <= `FALSE;
     else if(rd_debug_b0_trigger)    rd_debug_b0_reg <= `TRUE;
 end
@@ -101,8 +101,8 @@ assign rd_debug_b1_trigger =
     ( rd_debug_linear      <= { dr1[31:3], dr1[2:0] | ~(debug_len1)} ) &&
     ( rd_debug_linear_last >= { dr1[31:3], dr1[2:0] &   debug_len1 } );
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               rd_debug_b1_reg <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               rd_debug_b1_reg <= `FALSE;
     else if(rd_ready)               rd_debug_b1_reg <= `FALSE;
     else if(rd_debug_b1_trigger)    rd_debug_b1_reg <= `TRUE;
 end
@@ -113,8 +113,8 @@ assign rd_debug_b2_trigger =
     ( rd_debug_linear      <= { dr2[31:3], dr2[2:0] | ~(debug_len2)} ) &&
     ( rd_debug_linear_last >= { dr2[31:3], dr2[2:0] &   debug_len2 } );
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               rd_debug_b2_reg <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               rd_debug_b2_reg <= `FALSE;
     else if(rd_ready)               rd_debug_b2_reg <= `FALSE;
     else if(rd_debug_b2_trigger)    rd_debug_b2_reg <= `TRUE;
 end
@@ -125,8 +125,8 @@ assign rd_debug_b3_trigger =
     ( rd_debug_linear      <= { dr3[31:3], dr3[2:0] | ~(debug_len3)} ) &&
     ( rd_debug_linear_last >= { dr3[31:3], dr3[2:0] &   debug_len3 } );
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               rd_debug_b3_reg <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               rd_debug_b3_reg <= `FALSE;
     else if(rd_ready)               rd_debug_b3_reg <= `FALSE;
     else if(rd_debug_b3_trigger)    rd_debug_b3_reg <= `TRUE;
 end
diff --git a/rtl/ao486/pipeline/read_effective_address.v b/rtl/ao486/pipeline/read_effective_address.v
index d77942e..5f773cf 100644
--- a/rtl/ao486/pipeline/read_effective_address.v
+++ b/rtl/ao486/pipeline/read_effective_address.v
@@ -28,7 +28,7 @@
 
 module read_effective_address(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               rd_reset,
     
@@ -100,12 +100,14 @@ module read_effective_address(
 );
 
 //------------------------------------------------------------------------------ modregrm
-
+reg [31:0]  pop_offset_speedup;
+reg  [31:0] stack_saved;
+reg  [31:0] ebp_for_enter;
+reg  [31:0] ea_buffer;
 wire [15:0] address_disp16;
 wire [15:0] base16;
 wire [15:0] disp16;
 wire [15:0] base16_plus_disp16;
-
 wire [31:0] address_disp32_no_sib;
 wire [31:0] address_disp32_sib;
 wire [31:0] address_disp32;
@@ -116,8 +118,39 @@ wire [31:0] sib_base32_plus_index32_scaled;
 wire [31:0] base32;
 wire [31:0] disp32;
 wire [31:0] base32_plus_disp32;
-
 wire [31:0] address_effective_modrm;
+wire [31:0] esi_offset;
+wire [31:0] edi_offset;
+wire [31:0] pop_next;
+wire [31:0] pop_offset_speedup_next;
+wire [31:0] pop_offset;
+wire [31:0] stack_initial;
+wire [31:0] stack;
+wire [31:0] stack_for_ret_first;
+wire [31:0] stack_for_ret_second_imm_offset;
+wire [31:0] stack_for_ret_second;
+wire [31:0] stack_for_iret_first;
+wire [31:0] stack_for_iret_second;
+wire [31:0] stack_for_iret_third;
+wire [31:0] stack_for_iret_to_v86;
+wire [31:0] stack_for_call_param_first;
+wire [31:0] stack_next;
+wire [31:0] stack_offset;
+wire [4:0]  call_gate_param;
+wire [31:0] xlat_offset;
+wire [31:0] ebp_for_leave_offset;
+wire [31:0] address_bits_transform_reg;
+wire [31:0] address_bits_transform_sum;
+wire [31:0] ebp_for_enter_next;
+wire [31:0] ebp_for_enter_offset;
+wire [31:0] esp_for_enter_next;
+wire [31:0] esp_for_enter_offset;
+wire [31:0] ea_buffer_sum;
+wire [31:0] ea_buffer_next;
+wire _unused_ok;
+
+
+
 
 //------------------------------------------------------------------------------ modregrm 16-bit
 
@@ -206,19 +239,13 @@ assign address_effective_modrm =
                                                                                     
 //------------------------------------------------------------------------------ string
 
-wire [31:0] esi_offset;
-wire [31:0] edi_offset;
 
 assign esi_offset = (rd_address_16bit)? { 16'd0, esi[15:0] } : esi;
 assign edi_offset = (rd_address_16bit)? { 16'd0, edi[15:0] } : edi;
 
 //------------------------------------------------------------------------------ stack pop
 
-wire [31:0] pop_next;
-wire [31:0] pop_offset_speedup_next;
-wire [31:0] pop_offset;
 
-reg [31:0]  pop_offset_speedup;
 
 assign pop_next =
     (address_stack_pop_speedup && rd_operand_16bit)?    pop_offset_speedup + 32'd2 :
@@ -228,8 +255,8 @@ assign pop_next =
 
 assign pop_offset_speedup_next = (ss_cache[`DESC_BIT_D_B])? pop_next : { 16'd0, pop_next[15:0] };
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   pop_offset_speedup <= 32'd0;
+always @(posedge clk) begin
+    if(rst)   pop_offset_speedup <= 32'd0;
     else if(rd_ready)   pop_offset_speedup <= pop_offset_speedup_next;
 end
 
@@ -240,25 +267,11 @@ assign pop_offset =
 
 //------------------------------------------------------------------------------ stack pop for ret
 
-wire [31:0] stack_initial;
-wire [31:0] stack;
-wire [31:0] stack_for_ret_first;
-wire [31:0] stack_for_ret_second_imm_offset;
-wire [31:0] stack_for_ret_second;
-wire [31:0] stack_for_iret_first;
-wire [31:0] stack_for_iret_second;
-wire [31:0] stack_for_iret_third;
-wire [31:0] stack_for_iret_to_v86;
 
-wire [31:0] stack_for_call_param_first;
 
-wire [31:0] stack_next;
 
-reg  [31:0] stack_saved;
 
-wire [31:0] stack_offset;
 
-wire [4:0]  call_gate_param;
 
 assign stack_initial =
     (address_stack_pop_esp_prev)?   wr_esp_prev :
@@ -307,8 +320,8 @@ assign stack_next =
     (rd_operand_16bit)?                                     stack_saved - 32'd2 :
                                                             stack_saved - 32'd4;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   stack_saved <= 32'd0;
+always @(posedge clk) begin
+    if(rst)                                   stack_saved <= 32'd0;
     else if(rd_ready && address_stack_add_4_to_saved)   stack_saved <= stack_saved + 32'd4;
     else if(rd_ready)                                   stack_saved <= stack_next;
     else if(address_stack_save)                         stack_saved <= stack_offset;
@@ -327,20 +340,16 @@ assign stack_offset =
                                     
 //------------------------------------------------------------------------------ XLAT
 
-wire [31:0] xlat_offset;
 
 assign xlat_offset = ebx + { 24'b0, eax[7:0] };
 
 //------------------------------------------------------------------------------ LEAVE
 
-wire [31:0] ebp_for_leave_offset;
 
 assign ebp_for_leave_offset = (ss_cache[`DESC_BIT_D_B])? ebp : { 16'd0, ebp[15:0] };
 
 //------------------------------------------------------------------------------ bit operations
 
-wire [31:0] address_bits_transform_reg;
-wire [31:0] address_bits_transform_sum;
 
 assign address_bits_transform_reg =
     (rd_modregrm_reg == 3'b000)?    eax :
@@ -358,20 +367,15 @@ assign address_bits_transform_sum =
 
 //------------------------------------------------------------------------------ ENTER
 
-wire [31:0] ebp_for_enter_next;
-wire [31:0] ebp_for_enter_offset;
 
-reg  [31:0] ebp_for_enter;
 
-wire [31:0] esp_for_enter_next;
-wire [31:0] esp_for_enter_offset;
 
 
 assign ebp_for_enter_next    = (rd_operand_16bit)? ebp_for_enter - 32'd2 : ebp_for_enter - 32'd4;
 assign ebp_for_enter_offset = (ss_cache[`DESC_BIT_D_B])? ebp_for_enter_next : { 16'd0, ebp_for_enter_next[15:0] };
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           ebp_for_enter <= 32'd0;
+always @(posedge clk) begin
+    if(rst)           ebp_for_enter <= 32'd0;
     else if(address_enter_init) ebp_for_enter <= ebp;
     else if(rd_ready)           ebp_for_enter <= ebp_for_enter_offset;
 end
@@ -381,10 +385,7 @@ assign esp_for_enter_offset = (ss_cache[`DESC_BIT_D_B])? esp_for_enter_next : {
                             
 //------------------------------------------------------------------------------ ea buffer
     
-wire [31:0] ea_buffer_sum;
-wire [31:0] ea_buffer_next;
 
-reg  [31:0] ea_buffer;
                                         
 assign ea_buffer_sum  =
     (rd_operand_16bit || address_ea_buffer_plus_2)? rd_address_effective + 32'd2 :
@@ -392,21 +393,21 @@ assign ea_buffer_sum  =
 
 assign ea_buffer_next = (rd_address_16bit)? { 16'd0, ea_buffer_sum[15:0] } : ea_buffer_sum;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               ea_buffer <= 32'd0;
+always @(posedge clk) begin
+    if(rst)                               ea_buffer <= 32'd0;
     else if(rd_ready && rd_address_effective_ready) ea_buffer <= ea_buffer_next;
 end
 
 //------------------------------------------------------------------------------ final effective address
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   rd_address_effective_ready <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                   rd_address_effective_ready <= `FALSE;
     else if(rd_ready || rd_reset)       rd_address_effective_ready <= `FALSE;
     else if(rd_address_effective_do)    rd_address_effective_ready <= `TRUE;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               rd_address_effective <= 32'd0;
+always @(posedge clk) begin
+    if(rst)                               rd_address_effective <= 32'd0;
     else if(address_memoffset && rd_address_16bit)  rd_address_effective <= { 16'd0, rd_decoder[23:8] };
     else if(address_memoffset && rd_address_32bit)  rd_address_effective <= rd_decoder[39:8];
     else if(address_ea_buffer)                      rd_address_effective <= ea_buffer;
@@ -425,7 +426,7 @@ end
 //------------------------------------------------------------------------------
 
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, ss_cache[63:55], ss_cache[53:0], glob_param_3[31:25], glob_param_3[18:0], rd_decoder[87:56], rd_decoder[7:1], address_bits_transform_reg[3:0], 1'b0 };
+ assign _unused_ok = &{ 1'b0, ss_cache[63:55], ss_cache[53:0], glob_param_3[31:25], glob_param_3[18:0], rd_decoder[87:56], rd_decoder[7:1], address_bits_transform_reg[3:0], 1'b0 };
 // synthesis translate_on
 
 //------------------------------------------------------------------------------
diff --git a/rtl/ao486/pipeline/write.v b/rtl/ao486/pipeline/write.v
index 35ad8b6..43af9b3 100644
--- a/rtl/ao486/pipeline/write.v
+++ b/rtl/ao486/pipeline/write.v
@@ -28,7 +28,7 @@
 
 module write(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               exe_reset,
     input               wr_reset,
@@ -295,19 +295,212 @@ module write(
 );
 
 //------------------------------------------------------------------------------
-
+reg  wr_string_in_progress_last;
+reg wr_first_cycle;
+reg [15:0]  wr_decoder;
+reg         wr_operand_32bit;
+reg         wr_address_32bit;
+reg [1:0]   wr_prefix_group_1_rep;
+reg         wr_prefix_group_1_lock;
+reg         wr_is_8bit;
+reg [6:0]   wr_cmd;
+reg [3:0]   wr_cmdex;
+reg         wr_dst_is_reg;
+reg         wr_dst_is_rm;
+reg         wr_dst_is_memory;
+reg         wr_dst_is_eax;
+reg         wr_dst_is_edx_eax;
+reg         wr_dst_is_implicit_reg;
+reg [31:0]  wr_linear;
+reg [31:0]  result;
+reg [31:0]  result2;
+reg [4:0]   result_signals;
+reg [31:0]  result_push;
+reg [3:0]   wr_arith_index;
+reg [31:0]  wr_src;
+reg [31:0]  wr_dst;
+reg         wr_arith_add_carry;
+reg         wr_arith_adc_carry;
+reg         wr_arith_sub_carry;
+reg         wr_arith_sbb_carry;
+reg         wr_mult_overflow;
 wire [31:0] tr_base;
-
 wire [31:0] cs_base;
 wire [31:0] cs_limit;
-
 wire [31:0] es_base;
 wire [31:0] es_limit;
-
 wire [31:0] ss_base;
 wire [31:0] ss_limit;
-
 wire [31:0] ldtr_base;
+wire wr_ready;
+wire w_load;
+wire wr_waiting;
+wire wr_one_cycle_wait;
+wire wr_finished;
+wire wr_not_finished;
+wire wr_hlt_in_progress;
+wire wr_inhibit_interrupts_and_debug;
+wire wr_inhibit_interrupts;
+wire iflag_to_reg;
+wire wr_debug_prepare;
+wire wr_interrupt_possible_prepare;
+wire wr_clear_rflag;
+wire wr_string_in_progress;
+wire wr_operand_16bit;
+wire wr_address_16bit;
+wire [1:0] wr_modregrm_mod;
+wire [2:0] wr_modregrm_reg;
+wire [2:0] wr_modregrm_rm;
+wire [31:0] wr_descriptor_touch_offset;
+wire [31:0] wr_descriptor_busy_tss_offset;
+wire memory_write_system;
+wire        write_for_wr_ready;
+wire [31:0] wr_string_es_linear;
+wire write_io_for_wr_ready;
+wire _unused_ok;
+wire        write_stack_virtual;
+wire        write_new_stack_virtual;
+wire        wr_push_length_word;
+wire        wr_push_length_dword;
+wire        wr_push_ss_fault_check;
+wire        wr_new_push_ss_fault_check;
+wire        wr_make_esp_speculative;
+wire        wr_make_esp_commit;
+wire        wr_validate_seg_regs;
+wire [15:0] wr_seg_sel;
+wire        wr_seg_cache_valid;
+wire [1:0]  wr_seg_rpl;
+wire [63:0] wr_seg_cache_mask;
+wire        write_seg_cache;
+wire        write_seg_sel;
+wire        write_seg_cache_valid;
+wire        write_seg_rpl;
+wire        wr_debug_trap_clear;
+wire        wr_debug_task_trigger;
+wire        write_rmw_virtual;
+wire        write_virtual;
+wire        write_rmw_system_dword;
+wire        write_system_word;
+wire        write_system_dword;
+wire        write_system_busy_tss;
+wire        write_system_touch;
+wire        write_length_word;
+wire        write_length_dword;
+wire [31:0] wr_system_dword;
+wire [31:0] wr_system_linear;
+wire        write_regrm;
+wire        write_eax;
+wire        wr_regrm_word;
+wire        wr_regrm_dword;
+wire        wr_string_gp_fault_check;
+wire        write_string_es_virtual;
+wire        write_io;
+wire [1:0]  es_rpl;
+wire [1:0]  ds_rpl;
+wire [1:0]  ss_rpl;
+wire [1:0]  fs_rpl;
+wire [1:0]  gs_rpl;
+wire [1:0]  cs_rpl;
+wire [1:0]  ldtr_rpl;
+wire [1:0]  tr_rpl;
+wire [31:0] eax_to_reg;
+wire [31:0] ebx_to_reg;
+wire [31:0] ecx_to_reg;
+wire [31:0] edx_to_reg;
+wire [31:0] esi_to_reg;
+wire [31:0] edi_to_reg;
+wire [31:0] ebp_to_reg;
+wire [31:0] esp_to_reg;
+wire        cr0_pe_to_reg;
+wire        cr0_mp_to_reg;
+wire        cr0_em_to_reg;
+wire        cr0_ts_to_reg;
+wire        cr0_ne_to_reg;
+wire        cr0_wp_to_reg;
+wire        cr0_am_to_reg;
+wire        cr0_nw_to_reg;
+wire        cr0_cd_to_reg;
+wire        cr0_pg_to_reg;
+wire [31:0] cr2_to_reg;
+wire [31:0] cr3_to_reg;
+wire        cflag_to_reg;
+wire        pflag_to_reg;
+wire        aflag_to_reg;
+wire        zflag_to_reg;
+wire        sflag_to_reg;
+wire        oflag_to_reg;
+wire        tflag_to_reg;
+//wire        iflag_to_reg; --declared above
+wire        dflag_to_reg;
+wire [1:0]  iopl_to_reg;
+wire        ntflag_to_reg;
+wire        rflag_to_reg;
+wire        vmflag_to_reg;
+wire        acflag_to_reg;
+wire        idflag_to_reg;
+wire [31:0] gdtr_base_to_reg;
+wire [15:0] gdtr_limit_to_reg;
+wire [31:0] idtr_base_to_reg;
+wire [15:0] idtr_limit_to_reg;
+wire [31:0] dr0_to_reg;
+wire [31:0] dr1_to_reg;
+wire [31:0] dr2_to_reg;
+wire [31:0] dr3_to_reg;
+wire [3:0]  dr6_breakpoints_to_reg;
+wire        dr6_b12_to_reg;
+wire        dr6_bd_to_reg;
+wire        dr6_bs_to_reg;
+wire        dr6_bt_to_reg;
+wire [31:0] dr7_to_reg;
+wire [15:0] es_to_reg;
+wire [15:0] ds_to_reg;
+wire [15:0] ss_to_reg;
+wire [15:0] fs_to_reg;
+wire [15:0] gs_to_reg;
+wire [15:0] cs_to_reg;
+wire [15:0] ldtr_to_reg;
+wire [15:0] tr_to_reg;
+wire [63:0] es_cache_to_reg;
+wire [63:0] ds_cache_to_reg;
+wire [63:0] ss_cache_to_reg;
+wire [63:0] fs_cache_to_reg;
+wire [63:0] gs_cache_to_reg;
+wire [63:0] cs_cache_to_reg;
+wire [63:0] ldtr_cache_to_reg;
+wire [63:0] tr_cache_to_reg;
+wire        es_cache_valid_to_reg;
+wire        ds_cache_valid_to_reg;
+wire        ss_cache_valid_to_reg;
+wire        fs_cache_valid_to_reg;
+wire        gs_cache_valid_to_reg;
+wire        cs_cache_valid_to_reg;
+wire        ldtr_cache_valid_to_reg;
+wire [1:0]  es_rpl_to_reg;
+wire [1:0]  ds_rpl_to_reg;
+wire [1:0]  ss_rpl_to_reg;
+wire [1:0]  fs_rpl_to_reg;
+wire [1:0]  gs_rpl_to_reg;
+wire [1:0]  cs_rpl_to_reg;
+wire [1:0]  ldtr_rpl_to_reg;
+wire [1:0]  tr_rpl_to_reg;
+wire [31:0] wr_stack_esp;
+wire [31:0] wr_push_linear;
+wire [31:0] wr_new_stack_esp;
+wire [31:0] wr_new_push_linear;
+wire [2:0]  wr_push_length;
+wire [31:0] wr_esi_final;
+wire [31:0] wr_edi_final;
+wire [31:0] wr_ecx_final;
+wire        wr_string_ignore;
+wire        wr_zflag_result;
+wire        wr_string_zf_finish;
+wire        wr_string_finish;
+wire [3:0]  wr_debug_code_reg;
+wire [3:0]  wr_debug_write_reg;
+wire [3:0]  wr_debug_read_reg;
+wire        wr_debug_step_reg;
+wire        wr_debug_task_reg;
+
 
 assign tr_base     = {   tr_cache[63:56],   tr_cache[39:16] };
 
@@ -332,12 +525,8 @@ assign ldtr_base   = { ldtr_cache[63:56], ldtr_cache[39:16] };
 
 //------------------------------------------------------------------------------
 
-wire wr_ready;
-wire w_load;
 
-wire wr_waiting;
 
-wire wr_one_cycle_wait;
 
 //------------------------------------------------------------------------------
 
@@ -351,21 +540,10 @@ assign wr_is_front = wr_cmd != `CMD_NULL;
 
 //------------------------------------------------------------------------------
 
-wire wr_finished;
 
-wire wr_not_finished;
-wire wr_hlt_in_progress;
-wire wr_inhibit_interrupts_and_debug;
-wire wr_inhibit_interrupts;
-wire iflag_to_reg;
 
-wire wr_debug_prepare;
-wire wr_interrupt_possible_prepare;
 
-wire wr_clear_rflag;
 
-wire wr_string_in_progress;
-reg  wr_string_in_progress_last;
 
 assign wr_finished =
     wr_ready && (~(wr_not_finished) || (wr_hlt_in_progress && iflag_to_reg && interrupt_do) || wr_string_in_progress);
@@ -378,19 +556,19 @@ assign wr_interrupt_possible_prepare =
 
 assign wr_clear_rflag = wr_finished && wr_eip <= cs_limit && ~(exc_init) && ~(wr_debug_prepare) && ~(wr_interrupt_possible_prepare);
     
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_interrupt_possible <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   wr_interrupt_possible <= `FALSE;
     else if(wr_reset)   wr_interrupt_possible <= `FALSE;
     else                wr_interrupt_possible <= wr_interrupt_possible_prepare;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_debug_init <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   wr_debug_init <= `FALSE;
     else                wr_debug_init <= wr_debug_prepare;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_string_in_progress_last <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   wr_string_in_progress_last <= `FALSE;
     else                wr_string_in_progress_last <= wr_string_in_progress;
 end
 
@@ -398,10 +576,9 @@ assign wr_string_in_progress_final = wr_string_in_progress || ((wr_debug_init ||
 
 //------------------------------------------------------------------------------
 
-reg wr_first_cycle;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_first_cycle <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   wr_first_cycle <= `FALSE;
     else if(wr_reset)   wr_first_cycle <= `FALSE;
     else if(w_load)     wr_first_cycle <= `TRUE;
     else                wr_first_cycle <= `FALSE;
@@ -409,80 +586,53 @@ end
 
 //------------------------------------------------------------------------------
 
-reg [15:0]  wr_decoder;
-reg         wr_operand_32bit;
-reg         wr_address_32bit;
-reg [1:0]   wr_prefix_group_1_rep;
-reg         wr_prefix_group_1_lock;
-reg         wr_is_8bit;
-reg [6:0]   wr_cmd;
-reg [3:0]   wr_cmdex;
-reg         wr_dst_is_reg;
-reg         wr_dst_is_rm;
-reg         wr_dst_is_memory;
-reg         wr_dst_is_eax;
-reg         wr_dst_is_edx_eax;
-reg         wr_dst_is_implicit_reg;
-reg [31:0]  wr_linear;
 
-reg [31:0]  result;
-reg [31:0]  result2;
-reg [4:0]   result_signals;
-reg [31:0]  result_push;
 
-reg [3:0]   wr_arith_index;
-reg [31:0]  wr_src;
-reg [31:0]  wr_dst;
 
-reg         wr_arith_add_carry;
-reg         wr_arith_adc_carry;
-reg         wr_arith_sub_carry;
-reg         wr_arith_sbb_carry;
-reg         wr_mult_overflow;
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_decoder              <= 16'd0;     else if(w_load) wr_decoder              <= exe_decoder[15:0];        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_eip                  <= 32'd0;     else if(w_load) wr_eip                  <= exe_eip_final;            end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_operand_32bit        <= `FALSE;    else if(w_load) wr_operand_32bit        <= exe_operand_32bit;        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_address_32bit        <= `FALSE;    else if(w_load) wr_address_32bit        <= exe_address_32bit;        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_prefix_group_1_rep   <= 2'd0;      else if(w_load) wr_prefix_group_1_rep   <= exe_prefix_group_1_rep;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_prefix_group_1_lock  <= `FALSE;    else if(w_load) wr_prefix_group_1_lock  <= exe_prefix_group_1_lock;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_consumed             <= 4'd0;      else if(w_load) wr_consumed             <= exe_consumed_final;       end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_is_8bit              <= `FALSE;    else if(w_load) wr_is_8bit              <= exe_is_8bit_final;        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_cmdex                <= 4'd0;      else if(w_load) wr_cmdex                <= exe_cmdex;                end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_dst_is_reg           <= `FALSE;    else if(w_load) wr_dst_is_reg           <= exe_dst_is_reg;           end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_dst_is_rm            <= `FALSE;    else if(w_load) wr_dst_is_rm            <= exe_dst_is_rm;            end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_dst_is_memory        <= `FALSE;    else if(w_load) wr_dst_is_memory        <= exe_dst_is_memory;        end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_dst_is_eax           <= `FALSE;    else if(w_load) wr_dst_is_eax           <= exe_dst_is_eax;           end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_dst_is_edx_eax       <= `FALSE;    else if(w_load) wr_dst_is_edx_eax       <= exe_dst_is_edx_eax;       end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_dst_is_implicit_reg  <= `FALSE;    else if(w_load) wr_dst_is_implicit_reg  <= exe_dst_is_implicit_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_linear               <= 32'd0;     else if(w_load) wr_linear               <= exe_linear;               end
-
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) result                  <= 32'd0;     else if(w_load) result                  <= exe_result;               end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) result2                 <= 32'd0;     else if(w_load) result2                 <= exe_result2;              end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) result_push             <= 32'd0;     else if(w_load) result_push             <= exe_result_push;          end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) result_signals          <= 5'd0;      else if(w_load) result_signals          <= exe_result_signals;       end
-
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_arith_index          <= 4'd0;      else if(w_load) wr_arith_index          <= exe_arith_index;          end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_src                  <= 32'd0;     else if(w_load) wr_src                  <= src_final;                end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_dst                  <= 32'd0;     else if(w_load) wr_dst                  <= dst_final;                end
-
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_arith_sub_carry      <= 1'd0;      else if(w_load) wr_arith_sub_carry      <= exe_arith_sub_carry;      end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_arith_add_carry      <= 1'd0;      else if(w_load) wr_arith_add_carry      <= exe_arith_add_carry;      end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_arith_adc_carry      <= 1'd0;      else if(w_load) wr_arith_adc_carry      <= exe_arith_adc_carry;      end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_arith_sbb_carry      <= 1'd0;      else if(w_load) wr_arith_sbb_carry      <= exe_arith_sbb_carry;      end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_mult_overflow        <= 1'd0;      else if(w_load) wr_mult_overflow        <= exe_mult_overflow;        end
-
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) wr_stack_offset         <= 32'd0;     else if(w_load) wr_stack_offset         <= exe_stack_offset;         end
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_cmd <= `CMD_NULL;
+always @(posedge clk) begin if(rst) wr_decoder              <= 16'd0;     else if(w_load) wr_decoder              <= exe_decoder[15:0];        end
+always @(posedge clk) begin if(rst) wr_eip                  <= 32'd0;     else if(w_load) wr_eip                  <= exe_eip_final;            end
+always @(posedge clk) begin if(rst) wr_operand_32bit        <= `FALSE;    else if(w_load) wr_operand_32bit        <= exe_operand_32bit;        end
+always @(posedge clk) begin if(rst) wr_address_32bit        <= `FALSE;    else if(w_load) wr_address_32bit        <= exe_address_32bit;        end
+always @(posedge clk) begin if(rst) wr_prefix_group_1_rep   <= 2'd0;      else if(w_load) wr_prefix_group_1_rep   <= exe_prefix_group_1_rep;   end
+always @(posedge clk) begin if(rst) wr_prefix_group_1_lock  <= `FALSE;    else if(w_load) wr_prefix_group_1_lock  <= exe_prefix_group_1_lock;  end
+always @(posedge clk) begin if(rst) wr_consumed             <= 4'd0;      else if(w_load) wr_consumed             <= exe_consumed_final;       end
+always @(posedge clk) begin if(rst) wr_is_8bit              <= `FALSE;    else if(w_load) wr_is_8bit              <= exe_is_8bit_final;        end
+always @(posedge clk) begin if(rst) wr_cmdex                <= 4'd0;      else if(w_load) wr_cmdex                <= exe_cmdex;                end
+always @(posedge clk) begin if(rst) wr_dst_is_reg           <= `FALSE;    else if(w_load) wr_dst_is_reg           <= exe_dst_is_reg;           end
+always @(posedge clk) begin if(rst) wr_dst_is_rm            <= `FALSE;    else if(w_load) wr_dst_is_rm            <= exe_dst_is_rm;            end
+always @(posedge clk) begin if(rst) wr_dst_is_memory        <= `FALSE;    else if(w_load) wr_dst_is_memory        <= exe_dst_is_memory;        end
+always @(posedge clk) begin if(rst) wr_dst_is_eax           <= `FALSE;    else if(w_load) wr_dst_is_eax           <= exe_dst_is_eax;           end
+always @(posedge clk) begin if(rst) wr_dst_is_edx_eax       <= `FALSE;    else if(w_load) wr_dst_is_edx_eax       <= exe_dst_is_edx_eax;       end
+always @(posedge clk) begin if(rst) wr_dst_is_implicit_reg  <= `FALSE;    else if(w_load) wr_dst_is_implicit_reg  <= exe_dst_is_implicit_reg;  end
+always @(posedge clk) begin if(rst) wr_linear               <= 32'd0;     else if(w_load) wr_linear               <= exe_linear;               end
+
+always @(posedge clk) begin if(rst) result                  <= 32'd0;     else if(w_load) result                  <= exe_result;               end
+always @(posedge clk) begin if(rst) result2                 <= 32'd0;     else if(w_load) result2                 <= exe_result2;              end
+always @(posedge clk) begin if(rst) result_push             <= 32'd0;     else if(w_load) result_push             <= exe_result_push;          end
+always @(posedge clk) begin if(rst) result_signals          <= 5'd0;      else if(w_load) result_signals          <= exe_result_signals;       end
+
+always @(posedge clk) begin if(rst) wr_arith_index          <= 4'd0;      else if(w_load) wr_arith_index          <= exe_arith_index;          end
+always @(posedge clk) begin if(rst) wr_src                  <= 32'd0;     else if(w_load) wr_src                  <= src_final;                end
+always @(posedge clk) begin if(rst) wr_dst                  <= 32'd0;     else if(w_load) wr_dst                  <= dst_final;                end
+
+always @(posedge clk) begin if(rst) wr_arith_sub_carry      <= 1'd0;      else if(w_load) wr_arith_sub_carry      <= exe_arith_sub_carry;      end
+always @(posedge clk) begin if(rst) wr_arith_add_carry      <= 1'd0;      else if(w_load) wr_arith_add_carry      <= exe_arith_add_carry;      end
+always @(posedge clk) begin if(rst) wr_arith_adc_carry      <= 1'd0;      else if(w_load) wr_arith_adc_carry      <= exe_arith_adc_carry;      end
+always @(posedge clk) begin if(rst) wr_arith_sbb_carry      <= 1'd0;      else if(w_load) wr_arith_sbb_carry      <= exe_arith_sbb_carry;      end
+always @(posedge clk) begin if(rst) wr_mult_overflow        <= 1'd0;      else if(w_load) wr_mult_overflow        <= exe_mult_overflow;        end
+
+always @(posedge clk) begin if(rst) wr_stack_offset         <= 32'd0;     else if(w_load) wr_stack_offset         <= exe_stack_offset;         end
+
+always @(posedge clk) begin
+    if(rst)   wr_cmd <= `CMD_NULL;
     else if(wr_reset)   wr_cmd <= `CMD_NULL;
     else if(w_load)     wr_cmd <= exe_cmd;
     else if(wr_ready)   wr_cmd <= `CMD_NULL;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       wr_mutex <= 11'd0;
+always @(posedge clk) begin
+    if(rst)                                       wr_mutex <= 11'd0;
     else if(wr_reset)                                       wr_mutex <= 11'd0;
     else if(w_load)                                         wr_mutex <= exe_mutex;
     else if(wr_ready && ~(wr_interrupt_possible_prepare))   wr_mutex <= 11'd0;
@@ -490,12 +640,7 @@ end
 
 //------------------------------------------------------------------------------
 
-wire wr_operand_16bit;
-wire wr_address_16bit;
 
-wire [1:0] wr_modregrm_mod;
-wire [2:0] wr_modregrm_reg;
-wire [2:0] wr_modregrm_rm;
 
 assign wr_operand_16bit = ~(wr_operand_32bit);
 assign wr_address_16bit = ~(wr_address_32bit);
@@ -506,8 +651,6 @@ assign wr_modregrm_rm  = wr_decoder[10:8];
 
 //------------------------------------------------------------------------------
 
-wire [31:0] wr_descriptor_touch_offset;
-wire [31:0] wr_descriptor_busy_tss_offset;
 
 assign wr_descriptor_touch_offset =
     (glob_param_1[2] == 1'b0)?   gdtr_base + { 16'd0, glob_param_1[15:3], 3'd0 } + 32'd5 :
@@ -518,10 +661,7 @@ assign wr_descriptor_busy_tss_offset =
 
 //------------------------------------------------------------------------------ write memory
 
-wire memory_write_system;
 
-wire        write_for_wr_ready;
-wire [31:0] wr_string_es_linear;
 
 assign memory_write_system =
     write_system_touch || write_system_busy_tss || write_system_dword || write_system_word || write_rmw_system_dword;
@@ -573,7 +713,6 @@ assign write_for_wr_ready = write_done && ~(write_page_fault) && ~(write_ac_faul
 
 //------------------------------------------------------------------------------ write io
 
-wire write_io_for_wr_ready;
 
 assign io_write_do      = write_io;
 assign io_write_address = glob_param_1[15:0];
@@ -584,13 +723,13 @@ assign write_io_for_wr_ready = io_write_done;
 
 //------------------------------------------------------------------------------ esp speculative
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               wr_esp_prev <= 32'd0;
+always @(posedge clk) begin
+    if(rst)                                               wr_esp_prev <= 32'd0;
     else if(wr_make_esp_speculative && ~(wr_is_esp_speculative))    wr_esp_prev <= esp;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   wr_is_esp_speculative <= `FALSE;
+always @(posedge clk) begin
+    if(rst)                   wr_is_esp_speculative <= `FALSE;
     else if(wr_reset || exe_reset)      wr_is_esp_speculative <= `FALSE;
     else if(wr_make_esp_commit)         wr_is_esp_speculative <= `FALSE;
     else if(wr_make_esp_speculative)    wr_is_esp_speculative <= `TRUE;
@@ -601,171 +740,34 @@ end
 //------------------------------------------------------------------------------
 
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, glob_descriptor_2[63:47], glob_descriptor_2[44:0], exe_decoder[39:16], 1'b0 };
+ assign _unused_ok = &{ 1'b0, glob_descriptor_2[63:47], glob_descriptor_2[44:0], exe_decoder[39:16], 1'b0 };
 // synthesis translate_on
 
 //------------------------------------------------------------------------------
 
-wire        write_stack_virtual;
-wire        write_new_stack_virtual;
-wire        wr_push_length_word;
-wire        wr_push_length_dword;
-wire        wr_push_ss_fault_check;
-wire        wr_new_push_ss_fault_check;
-wire        wr_make_esp_speculative;
-wire        wr_make_esp_commit;
 
-wire        wr_validate_seg_regs;
 
-wire [15:0] wr_seg_sel;
-wire        wr_seg_cache_valid;
-wire [1:0]  wr_seg_rpl;
-wire [63:0] wr_seg_cache_mask;
 
-wire        write_seg_cache;
-wire        write_seg_sel;
-wire        write_seg_cache_valid;
-wire        write_seg_rpl;
 
-wire        wr_debug_trap_clear;
-wire        wr_debug_task_trigger;
 
-wire        write_rmw_virtual;
-wire        write_virtual;
-wire        write_rmw_system_dword;
-wire        write_system_word;
-wire        write_system_dword;
-wire        write_system_busy_tss;
-wire        write_system_touch;
 
-wire        write_length_word;
-wire        write_length_dword;
 
-wire [31:0] wr_system_dword;
-wire [31:0] wr_system_linear;
 
-wire        write_regrm;
-wire        write_eax;
-wire        wr_regrm_word;
-wire        wr_regrm_dword;
 
-wire        wr_string_gp_fault_check;
-wire        write_string_es_virtual;
 
-wire        write_io;
 
 //registers
-wire [1:0]  es_rpl;
-wire [1:0]  ds_rpl;
-wire [1:0]  ss_rpl;
-wire [1:0]  fs_rpl;
-wire [1:0]  gs_rpl;
-wire [1:0]  cs_rpl;
-wire [1:0]  ldtr_rpl;
-wire [1:0]  tr_rpl;
 
-wire [31:0] eax_to_reg;
-wire [31:0] ebx_to_reg;
-wire [31:0] ecx_to_reg;
-wire [31:0] edx_to_reg;
-wire [31:0] esi_to_reg;
-wire [31:0] edi_to_reg;
-wire [31:0] ebp_to_reg;
-wire [31:0] esp_to_reg;
-wire        cr0_pe_to_reg;
-wire        cr0_mp_to_reg;
-wire        cr0_em_to_reg;
-wire        cr0_ts_to_reg;
-wire        cr0_ne_to_reg;
-wire        cr0_wp_to_reg;
-wire        cr0_am_to_reg;
-wire        cr0_nw_to_reg;
-wire        cr0_cd_to_reg;
-wire        cr0_pg_to_reg;
-wire [31:0] cr2_to_reg;
-wire [31:0] cr3_to_reg;
-wire        cflag_to_reg;
-wire        pflag_to_reg;
-wire        aflag_to_reg;
-wire        zflag_to_reg;
-wire        sflag_to_reg;
-wire        oflag_to_reg;
-wire        tflag_to_reg;
-//wire        iflag_to_reg; --declared above
-wire        dflag_to_reg;
-wire [1:0]  iopl_to_reg;
-wire        ntflag_to_reg;
-wire        rflag_to_reg;
-wire        vmflag_to_reg;
-wire        acflag_to_reg;
-wire        idflag_to_reg;
-wire [31:0] gdtr_base_to_reg;
-wire [15:0] gdtr_limit_to_reg;
-wire [31:0] idtr_base_to_reg;
-wire [15:0] idtr_limit_to_reg;
-wire [31:0] dr0_to_reg;
-wire [31:0] dr1_to_reg;
-wire [31:0] dr2_to_reg;
-wire [31:0] dr3_to_reg;
-wire [3:0]  dr6_breakpoints_to_reg;
-wire        dr6_b12_to_reg;
-wire        dr6_bd_to_reg;
-wire        dr6_bs_to_reg;
-wire        dr6_bt_to_reg;
-wire [31:0] dr7_to_reg;
-wire [15:0] es_to_reg;
-wire [15:0] ds_to_reg;
-wire [15:0] ss_to_reg;
-wire [15:0] fs_to_reg;
-wire [15:0] gs_to_reg;
-wire [15:0] cs_to_reg;
-wire [15:0] ldtr_to_reg;
-wire [15:0] tr_to_reg;
-wire [63:0] es_cache_to_reg;
-wire [63:0] ds_cache_to_reg;
-wire [63:0] ss_cache_to_reg;
-wire [63:0] fs_cache_to_reg;
-wire [63:0] gs_cache_to_reg;
-wire [63:0] cs_cache_to_reg;
-wire [63:0] ldtr_cache_to_reg;
-wire [63:0] tr_cache_to_reg;
-wire        es_cache_valid_to_reg;
-wire        ds_cache_valid_to_reg;
-wire        ss_cache_valid_to_reg;
-wire        fs_cache_valid_to_reg;
-wire        gs_cache_valid_to_reg;
-wire        cs_cache_valid_to_reg;
-wire        ldtr_cache_valid_to_reg;
-wire [1:0]  es_rpl_to_reg;
-wire [1:0]  ds_rpl_to_reg;
-wire [1:0]  ss_rpl_to_reg;
-wire [1:0]  fs_rpl_to_reg;
-wire [1:0]  gs_rpl_to_reg;
-wire [1:0]  cs_rpl_to_reg;
-wire [1:0]  ldtr_rpl_to_reg;
-wire [1:0]  tr_rpl_to_reg;
 
 //stack
-wire [31:0] wr_stack_esp;
-wire [31:0] wr_push_linear;
-wire [31:0] wr_new_stack_esp;
-wire [31:0] wr_new_push_linear;
-wire [2:0]  wr_push_length;
 
 //string
-wire [31:0] wr_esi_final;
-wire [31:0] wr_edi_final;
-wire [31:0] wr_ecx_final;
 
-wire        wr_string_ignore;
 
-wire        wr_zflag_result;
-wire        wr_string_zf_finish;
-wire        wr_string_finish;
 
 write_commands write_commands_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     //general input
     .real_mode              (real_mode),                //input
@@ -1123,15 +1125,10 @@ write_commands write_commands_inst(
     
 //------------------------------------------------------------------------------
 
-wire [3:0]  wr_debug_code_reg;
-wire [3:0]  wr_debug_write_reg;
-wire [3:0]  wr_debug_read_reg;
-wire        wr_debug_step_reg;
-wire        wr_debug_task_reg;
 
 write_debug write_debug_inst(
     .clk            (clk),
-    .rst_n          (rst_n),
+    .rst          (rst),
     
     //general input
     .dr0                                (dr0),              //input [31:0]
@@ -1184,7 +1181,7 @@ write_debug write_debug_inst(
 
 write_register write_register_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     //general input
     .glob_descriptor               (glob_descriptor),               //input [63:0]
@@ -1246,14 +1243,12 @@ write_register write_register_inst(
     .write_eax                     (write_eax),                     //input
     .write_regrm                   (write_regrm),                   //input
                                    
-    //write reg options
     .wr_dst_is_rm                  (wr_dst_is_rm),                  //input
     .wr_dst_is_reg                 (wr_dst_is_reg),                 //input
     .wr_dst_is_implicit_reg        (wr_dst_is_implicit_reg),        //input
     .wr_regrm_word                 (wr_regrm_word),                 //input
     .wr_regrm_dword                (wr_regrm_dword),                //input
     
-    //write reg data
     .result                        (result),                        //input [31:0]
     
     //output
diff --git a/rtl/ao486/pipeline/write_commands.v b/rtl/ao486/pipeline/write_commands.v
index 75f764c..5ee619b 100644
--- a/rtl/ao486/pipeline/write_commands.v
+++ b/rtl/ao486/pipeline/write_commands.v
@@ -30,7 +30,7 @@
 
 module write_commands(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //general input
     input               real_mode,
diff --git a/rtl/ao486/pipeline/write_debug.v b/rtl/ao486/pipeline/write_debug.v
index 4563ccc..38ad080 100644
--- a/rtl/ao486/pipeline/write_debug.v
+++ b/rtl/ao486/pipeline/write_debug.v
@@ -28,7 +28,7 @@
 
 module write_debug(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //general input
     input       [31:0]  dr0,
@@ -80,20 +80,40 @@ module write_debug(
 //------------------------------------------------------------------------------
 
 wire wr_debug_breakpoints_disabled;
+wire        wr_debug_read_active;
+wire [3:0]  wr_debug_read_current;
+wire [31:0] wr_debug_linear_last;    
+reg         wr_debug_b0_write_trigger;
+reg         wr_debug_b1_write_trigger;
+reg         wr_debug_b2_write_trigger;
+reg         wr_debug_b3_write_trigger;
+
+reg  [31:0] wr_debug_linear_last_reg;
+reg  [31:0] write_address_last;
+wire [3:0]  wr_debug_write;
+wire        wr_debug_write_active;
+wire [3:0]  wr_debug_write_current;
+wire        wr_debug_code_trigger;
+wire        wr_debug_b0_code_trigger;
+wire        wr_debug_b1_code_trigger;
+wire        wr_debug_b2_code_trigger;
+wire        wr_debug_b3_code_trigger;
+wire        wr_debug_code_active;
+wire [3:0]  wr_debug_code;
 
+wire [31:0] wr_code_linear;
+reg wr_debug_step;
+   
 assign wr_debug_breakpoints_disabled = dr7[7:0] == 8'h00;
     
 //NOTE: GD exception -- has to have: (single_step / breakpoint data) saved
 
 //------------------------------------------------------------------------------ debug read
 
-wire        wr_debug_read_active;
-wire [3:0]  wr_debug_read_current;
-
 assign wr_debug_read_current = (wr_debug_breakpoints_disabled)? 4'd0 : exe_debug_read;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               wr_debug_read_reg <= 4'd0;
+always @(posedge clk) begin
+    if(rst)                                               wr_debug_read_reg <= 4'd0;
     
     else if(wr_inhibit_interrupts_and_debug || wr_debug_prepare)    wr_debug_read_reg <= wr_debug_read_reg; // no change
     else if(wr_debug_trap_clear)                                    wr_debug_read_reg <= 4'd0;
@@ -110,52 +130,43 @@ assign wr_debug_read_active =
 
 //------------------------------------------------------------------------------ write breakpoints
 
-wire [31:0] wr_debug_linear_last;    
-reg         wr_debug_b0_write_trigger;
-reg         wr_debug_b1_write_trigger;
-reg         wr_debug_b2_write_trigger;
-reg         wr_debug_b3_write_trigger;
-
-reg  [31:0] wr_debug_linear_last_reg;
-reg  [31:0] write_address_last;
-
 assign wr_debug_linear_last = write_address + { 29'd0, write_length } - 32'd1;
 
 
 //NOTE: write_for_wr_ready at least two cycles after valid write_address
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_debug_linear_last_reg <= 32'd0;
+always @(posedge clk) begin
+    if(rst)   wr_debug_linear_last_reg <= 32'd0;
     else                wr_debug_linear_last_reg <= wr_debug_linear_last;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   write_address_last <= 32'd0;
+always @(posedge clk) begin
+    if(rst)   write_address_last <= 32'd0;
     else                write_address_last <= write_address;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_debug_b0_write_trigger <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   wr_debug_b0_write_trigger <= `FALSE;
     else                wr_debug_b0_write_trigger <= dr7[16] == 1'b1 && // RW bits = (read or write) or write only
                                                      ( write_address_last        <= { dr0[31:3], dr0[2:0] | ~(debug_len0)} ) &&
                                                      ( wr_debug_linear_last_reg  >= { dr0[31:3], dr0[2:0] &   debug_len0 } );
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_debug_b1_write_trigger <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   wr_debug_b1_write_trigger <= `FALSE;
     else                wr_debug_b1_write_trigger <= dr7[20] == 1'b1 && // RW bits = (read or write) or write only
                                                      ( write_address_last        <= { dr1[31:3], dr1[2:0] | ~(debug_len1)} ) &&
                                                      ( wr_debug_linear_last_reg  >= { dr1[31:3], dr1[2:0] &   debug_len1 } );
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_debug_b2_write_trigger <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   wr_debug_b2_write_trigger <= `FALSE;
     else                wr_debug_b2_write_trigger <= dr7[24] == 1'b1 && // RW bits = (read or write) or write only
                                                      ( write_address_last        <= { dr2[31:3], dr2[2:0] | ~(debug_len2)} ) &&
                                                      ( wr_debug_linear_last_reg  >= { dr2[31:3], dr2[2:0] &   debug_len2 } );
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_debug_b3_write_trigger <= `FALSE;
+always @(posedge clk) begin
+    if(rst)   wr_debug_b3_write_trigger <= `FALSE;
     else                wr_debug_b3_write_trigger <= dr7[28] == 1'b1 && // RW bits = (read or write) or write only
                                                      ( write_address_last        <= { dr3[31:3], dr3[2:0] | ~(debug_len3)} ) &&
                                                      ( wr_debug_linear_last_reg  >= { dr3[31:3], dr3[2:0] &   debug_len3 } );
@@ -163,16 +174,13 @@ end
 
 //------------------------------------------------------------------------------ debug write
 
-wire [3:0]  wr_debug_write;
-wire        wr_debug_write_active;
-wire [3:0]  wr_debug_write_current;
 
 assign wr_debug_write_current = (wr_debug_breakpoints_disabled)? 4'd0 :
     { wr_debug_b3_write_trigger, wr_debug_b2_write_trigger, wr_debug_b1_write_trigger, wr_debug_b0_write_trigger };
     
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               wr_debug_write_reg <= 4'd0;
+always @(posedge clk) begin
+    if(rst)                               wr_debug_write_reg <= 4'd0;
     
     else if(wr_inhibit_interrupts_and_debug)        wr_debug_write_reg <= wr_debug_write_reg; // no change
     else if(wr_debug_trap_clear)                    wr_debug_write_reg <= 4'd0;
@@ -190,16 +198,7 @@ assign wr_debug_write_active =
 
 //------------------------------------------------------------------------------ debug code
 
-wire        wr_debug_code_trigger;
-wire        wr_debug_b0_code_trigger;
-wire        wr_debug_b1_code_trigger;
-wire        wr_debug_b2_code_trigger;
-wire        wr_debug_b3_code_trigger;
-wire        wr_debug_code_active;
-wire [3:0]  wr_debug_code;
-
-wire [31:0] wr_code_linear;
-
+   
 assign wr_code_linear = cs_base + wr_eip;
 
 assign wr_debug_code_trigger =
@@ -224,30 +223,29 @@ assign wr_debug_code_active =
 assign wr_debug_code = (wr_debug_code_active)? 
     { wr_debug_b3_code_trigger, wr_debug_b2_code_trigger, wr_debug_b1_code_trigger, wr_debug_b0_code_trigger } : 4'd0;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           wr_debug_code_reg <= 4'd0;
+always @(posedge clk) begin
+    if(rst)           wr_debug_code_reg <= 4'd0;
     else if(wr_debug_prepare)   wr_debug_code_reg <= wr_debug_code;
 end
 
 //------------------------------------------------------------------------------ debug single step
 
-reg wr_debug_step;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           wr_debug_step_reg <= `FALSE;
+always @(posedge clk) begin
+    if(rst)           wr_debug_step_reg <= `FALSE;
     else if(wr_debug_prepare)   wr_debug_step_reg <= wr_debug_step;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               wr_debug_step <= `FALSE;
+always @(posedge clk) begin
+    if(rst)               wr_debug_step <= `FALSE;
     else if(wr_debug_trap_clear)    wr_debug_step <= `FALSE;
     else if(wr_finished)            wr_debug_step <= tflag_to_reg;
 end
 
 //------------------------------------------------------------------------------ debug task switch
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           wr_debug_task_reg <= `FALSE;
+always @(posedge clk) begin
+    if(rst)           wr_debug_task_reg <= `FALSE;
     else if(wr_debug_prepare)   wr_debug_task_reg <= wr_debug_task_trigger;
 end
 
diff --git a/rtl/ao486/pipeline/write_register.v b/rtl/ao486/pipeline/write_register.v
index f3a8c33..733ec5d 100644
--- a/rtl/ao486/pipeline/write_register.v
+++ b/rtl/ao486/pipeline/write_register.v
@@ -28,7 +28,7 @@
 
 module write_register(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     
     
@@ -409,32 +409,32 @@ assign esp_value =
 //------------------------------------------------------------------------------ general registers
 
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) eax <= `STARTUP_EAX; else if(w_write_regrm) eax <= eax_value;                                              else eax <= eax_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) ebx <= `STARTUP_EBX; else if(w_write_regrm) ebx <= ebx_value;                                              else ebx <= ebx_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) ecx <= `STARTUP_ECX; else if(w_write_regrm) ecx <= ecx_value;                                              else ecx <= ecx_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) edx <= `STARTUP_EDX; else if(w_write_regrm) edx <= edx_value;                                              else edx <= edx_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) esi <= `STARTUP_ESI; else if(w_write_regrm) esi <= esi_value;                                              else esi <= esi_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) edi <= `STARTUP_EDI; else if(w_write_regrm) edi <= edi_value;                                              else edi <= edi_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) ebp <= `STARTUP_EBP; else if(w_write_regrm) ebp <= ebp_value;                                              else ebp <= ebp_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) esp <= `STARTUP_ESP; else if(w_write_regrm) esp <= esp_value; else if(exc_restore_esp) esp <= wr_esp_prev; else esp <= esp_to_reg; end
+always @(posedge clk) begin if(rst) eax <= `STARTUP_EAX; else if(w_write_regrm) eax <= eax_value;                                              else eax <= eax_to_reg; end
+always @(posedge clk) begin if(rst) ebx <= `STARTUP_EBX; else if(w_write_regrm) ebx <= ebx_value;                                              else ebx <= ebx_to_reg; end
+always @(posedge clk) begin if(rst) ecx <= `STARTUP_ECX; else if(w_write_regrm) ecx <= ecx_value;                                              else ecx <= ecx_to_reg; end
+always @(posedge clk) begin if(rst) edx <= `STARTUP_EDX; else if(w_write_regrm) edx <= edx_value;                                              else edx <= edx_to_reg; end
+always @(posedge clk) begin if(rst) esi <= `STARTUP_ESI; else if(w_write_regrm) esi <= esi_value;                                              else esi <= esi_to_reg; end
+always @(posedge clk) begin if(rst) edi <= `STARTUP_EDI; else if(w_write_regrm) edi <= edi_value;                                              else edi <= edi_to_reg; end
+always @(posedge clk) begin if(rst) ebp <= `STARTUP_EBP; else if(w_write_regrm) ebp <= ebp_value;                                              else ebp <= ebp_to_reg; end
+always @(posedge clk) begin if(rst) esp <= `STARTUP_ESP; else if(w_write_regrm) esp <= esp_value; else if(exc_restore_esp) esp <= wr_esp_prev; else esp <= esp_to_reg; end
 
 //------------------------------------------------------------------------------ control registers
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cr0_pe <= `STARTUP_CR0_PE; else cr0_pe <= cr0_pe_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cr0_mp <= `STARTUP_CR0_MP; else cr0_mp <= cr0_mp_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cr0_em <= `STARTUP_CR0_EM; else cr0_em <= cr0_em_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cr0_ts <= `STARTUP_CR0_TS; else cr0_ts <= cr0_ts_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cr0_ne <= `STARTUP_CR0_NE; else cr0_ne <= cr0_ne_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cr0_wp <= `STARTUP_CR0_WP; else cr0_wp <= cr0_wp_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cr0_am <= `STARTUP_CR0_AM; else cr0_am <= cr0_am_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cr0_nw <= `STARTUP_CR0_NW; else cr0_nw <= cr0_nw_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cr0_cd <= `STARTUP_CR0_CD; else cr0_cd <= cr0_cd_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cr0_pg <= `STARTUP_CR0_PG; else cr0_pg <= cr0_pg_to_reg; end
-
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cr3    <= `STARTUP_CR3;  else cr3    <= cr3_to_reg;    end
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       cr2 <= `STARTUP_CR2;
+always @(posedge clk) begin if(rst) cr0_pe <= `STARTUP_CR0_PE; else cr0_pe <= cr0_pe_to_reg; end
+always @(posedge clk) begin if(rst) cr0_mp <= `STARTUP_CR0_MP; else cr0_mp <= cr0_mp_to_reg; end
+always @(posedge clk) begin if(rst) cr0_em <= `STARTUP_CR0_EM; else cr0_em <= cr0_em_to_reg; end
+always @(posedge clk) begin if(rst) cr0_ts <= `STARTUP_CR0_TS; else cr0_ts <= cr0_ts_to_reg; end
+always @(posedge clk) begin if(rst) cr0_ne <= `STARTUP_CR0_NE; else cr0_ne <= cr0_ne_to_reg; end
+always @(posedge clk) begin if(rst) cr0_wp <= `STARTUP_CR0_WP; else cr0_wp <= cr0_wp_to_reg; end
+always @(posedge clk) begin if(rst) cr0_am <= `STARTUP_CR0_AM; else cr0_am <= cr0_am_to_reg; end
+always @(posedge clk) begin if(rst) cr0_nw <= `STARTUP_CR0_NW; else cr0_nw <= cr0_nw_to_reg; end
+always @(posedge clk) begin if(rst) cr0_cd <= `STARTUP_CR0_CD; else cr0_cd <= cr0_cd_to_reg; end
+always @(posedge clk) begin if(rst) cr0_pg <= `STARTUP_CR0_PG; else cr0_pg <= cr0_pg_to_reg; end
+
+always @(posedge clk) begin if(rst) cr3    <= `STARTUP_CR3;  else cr3    <= cr3_to_reg;    end
+
+always @(posedge clk) begin
+    if(rst)       cr2 <= `STARTUP_CR2;
     else if(exc_pf_write)   cr2 <= tlb_write_pf_cr2;
     else if(exc_pf_check)   cr2 <= tlb_check_pf_cr2;
     else if(exc_pf_read)    cr2 <= tlb_read_pf_cr2;
@@ -444,23 +444,23 @@ end
 
 //------------------------------------------------------------------------------ eflags
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cflag  <= `STARTUP_CFLAG;  else cflag  <= cflag_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) pflag  <= `STARTUP_PFLAG;  else pflag  <= pflag_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) aflag  <= `STARTUP_AFLAG;  else aflag  <= aflag_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) zflag  <= `STARTUP_ZFLAG;  else zflag  <= zflag_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) sflag  <= `STARTUP_SFLAG;  else sflag  <= sflag_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) oflag  <= `STARTUP_OFLAG;  else oflag  <= oflag_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tflag  <= `STARTUP_TFLAG;  else tflag  <= tflag_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) iflag  <= `STARTUP_IFLAG;  else iflag  <= iflag_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dflag  <= `STARTUP_DFLAG;  else dflag  <= dflag_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) iopl   <= `STARTUP_IOPL;   else iopl   <= iopl_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) ntflag <= `STARTUP_NTFLAG; else ntflag <= ntflag_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) vmflag <= `STARTUP_VMFLAG; else vmflag <= vmflag_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) acflag <= `STARTUP_ACFLAG; else acflag <= acflag_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) idflag <= `STARTUP_IDFLAG; else idflag <= idflag_to_reg; end
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       rflag <= `STARTUP_RFLAG;
+always @(posedge clk) begin if(rst) cflag  <= `STARTUP_CFLAG;  else cflag  <= cflag_to_reg;  end
+always @(posedge clk) begin if(rst) pflag  <= `STARTUP_PFLAG;  else pflag  <= pflag_to_reg;  end
+always @(posedge clk) begin if(rst) aflag  <= `STARTUP_AFLAG;  else aflag  <= aflag_to_reg;  end
+always @(posedge clk) begin if(rst) zflag  <= `STARTUP_ZFLAG;  else zflag  <= zflag_to_reg;  end
+always @(posedge clk) begin if(rst) sflag  <= `STARTUP_SFLAG;  else sflag  <= sflag_to_reg;  end
+always @(posedge clk) begin if(rst) oflag  <= `STARTUP_OFLAG;  else oflag  <= oflag_to_reg;  end
+always @(posedge clk) begin if(rst) tflag  <= `STARTUP_TFLAG;  else tflag  <= tflag_to_reg;  end
+always @(posedge clk) begin if(rst) iflag  <= `STARTUP_IFLAG;  else iflag  <= iflag_to_reg;  end
+always @(posedge clk) begin if(rst) dflag  <= `STARTUP_DFLAG;  else dflag  <= dflag_to_reg;  end
+always @(posedge clk) begin if(rst) iopl   <= `STARTUP_IOPL;   else iopl   <= iopl_to_reg;   end
+always @(posedge clk) begin if(rst) ntflag <= `STARTUP_NTFLAG; else ntflag <= ntflag_to_reg; end
+always @(posedge clk) begin if(rst) vmflag <= `STARTUP_VMFLAG; else vmflag <= vmflag_to_reg; end
+always @(posedge clk) begin if(rst) acflag <= `STARTUP_ACFLAG; else acflag <= acflag_to_reg; end
+always @(posedge clk) begin if(rst) idflag <= `STARTUP_IDFLAG; else idflag <= idflag_to_reg; end
+
+always @(posedge clk) begin
+    if(rst)       rflag <= `STARTUP_RFLAG;
     else if(wr_clear_rflag) rflag <= `FALSE;
     else if(exc_set_rflag)  rflag <= `TRUE;
     else                    rflag <= rflag_to_reg;
@@ -468,33 +468,33 @@ end
 
 //------------------------------------------------------------------------------ gdtr, idtr
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) gdtr_base  <= `STARTUP_GDTR_BASE;  else gdtr_base  <= gdtr_base_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) gdtr_limit <= `STARTUP_GDTR_LIMIT; else gdtr_limit <= gdtr_limit_to_reg; end
+always @(posedge clk) begin if(rst) gdtr_base  <= `STARTUP_GDTR_BASE;  else gdtr_base  <= gdtr_base_to_reg;  end
+always @(posedge clk) begin if(rst) gdtr_limit <= `STARTUP_GDTR_LIMIT; else gdtr_limit <= gdtr_limit_to_reg; end
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) idtr_base  <= `STARTUP_IDTR_BASE;  else idtr_base  <= idtr_base_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) idtr_limit <= `STARTUP_IDTR_LIMIT; else idtr_limit <= idtr_limit_to_reg; end
+always @(posedge clk) begin if(rst) idtr_base  <= `STARTUP_IDTR_BASE;  else idtr_base  <= idtr_base_to_reg;  end
+always @(posedge clk) begin if(rst) idtr_limit <= `STARTUP_IDTR_LIMIT; else idtr_limit <= idtr_limit_to_reg; end
 
 
 //------------------------------------------------------------------------------ debug registers
 
 
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dr0 <= `STARTUP_DR0; else dr0 <= dr0_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dr1 <= `STARTUP_DR1; else dr1 <= dr1_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dr2 <= `STARTUP_DR2; else dr2 <= dr2_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dr3 <= `STARTUP_DR3; else dr3 <= dr3_to_reg; end
+always @(posedge clk) begin if(rst) dr0 <= `STARTUP_DR0; else dr0 <= dr0_to_reg; end
+always @(posedge clk) begin if(rst) dr1 <= `STARTUP_DR1; else dr1 <= dr1_to_reg; end
+always @(posedge clk) begin if(rst) dr2 <= `STARTUP_DR2; else dr2 <= dr2_to_reg; end
+always @(posedge clk) begin if(rst) dr3 <= `STARTUP_DR3; else dr3 <= dr3_to_reg; end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           dr6_breakpoints <= `STARTUP_DR6_BREAKPOINTS;
+always @(posedge clk) begin
+    if(rst)           dr6_breakpoints <= `STARTUP_DR6_BREAKPOINTS;
     else if(exc_debug_start)    dr6_breakpoints <= wr_debug_read_reg | wr_debug_write_reg | wr_debug_code_reg;
     else                        dr6_breakpoints <= dr6_breakpoints_to_reg;
 end
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dr6_b12 <= `STARTUP_DR6_B12; else if(exc_debug_start) dr6_b12 <= `FALSE;                         else dr6_b12 <= dr6_b12_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dr6_bd  <= `STARTUP_DR6_BD;  else if(dr6_bd_set)      dr6_bd  <= `TRUE;                          else dr6_bd  <= dr6_bd_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dr6_bs  <= `STARTUP_DR6_BS;  else if(exc_debug_start) dr6_bs <= wr_debug_step_reg;               else dr6_bs  <= dr6_bs_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dr6_bt  <= `STARTUP_DR6_BT;  else if(exc_debug_start) dr6_bt <= wr_debug_task_reg;               else dr6_bt  <= dr6_bt_to_reg;  end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) dr7     <= `STARTUP_DR7;     else if(exc_debug_start) dr7    <= { dr7[31:14], 1'b0, dr7[12:0] }; else dr7     <= dr7_to_reg;     end
+always @(posedge clk) begin if(rst) dr6_b12 <= `STARTUP_DR6_B12; else if(exc_debug_start) dr6_b12 <= `FALSE;                         else dr6_b12 <= dr6_b12_to_reg; end
+always @(posedge clk) begin if(rst) dr6_bd  <= `STARTUP_DR6_BD;  else if(dr6_bd_set)      dr6_bd  <= `TRUE;                          else dr6_bd  <= dr6_bd_to_reg;  end
+always @(posedge clk) begin if(rst) dr6_bs  <= `STARTUP_DR6_BS;  else if(exc_debug_start) dr6_bs <= wr_debug_step_reg;               else dr6_bs  <= dr6_bs_to_reg;  end
+always @(posedge clk) begin if(rst) dr6_bt  <= `STARTUP_DR6_BT;  else if(exc_debug_start) dr6_bt <= wr_debug_task_reg;               else dr6_bt  <= dr6_bt_to_reg;  end
+always @(posedge clk) begin if(rst) dr7     <= `STARTUP_DR7;     else if(exc_debug_start) dr7    <= { dr7[31:14], 1'b0, dr7[12:0] }; else dr7     <= dr7_to_reg;     end
 
 
 //------------------------------------------------------------------------------ segment registers
@@ -518,25 +518,25 @@ assign es_invalidate = wr_validate_seg_regs && es_cache[`DESC_BITS_DPL] < cpl &&
 assign fs_invalidate = wr_validate_seg_regs && fs_cache[`DESC_BITS_DPL] < cpl && (fs_cache_valid == `FALSE || fs_cache[`DESC_BIT_SEG] == `FALSE || `DESC_IS_DATA(fs_cache) || `DESC_IS_CODE_NON_CONFORMING(fs_cache));
 assign gs_invalidate = wr_validate_seg_regs && gs_cache[`DESC_BITS_DPL] < cpl && (gs_cache_valid == `FALSE || gs_cache[`DESC_BIT_SEG] == `FALSE || `DESC_IS_DATA(gs_cache) || `DESC_IS_CODE_NON_CONFORMING(gs_cache));
 
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) es   <= `STARTUP_ES;   else if(es_invalidate) es <= 16'd0; else if(write_seg_sel && wr_seg_index == 3'd0) es   <= wr_seg_sel; else es   <= es_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) ds   <= `STARTUP_DS;   else if(ds_invalidate) ds <= 16'd0; else if(write_seg_sel && wr_seg_index == 3'd3) ds   <= wr_seg_sel; else ds   <= ds_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) ss   <= `STARTUP_SS;                                       else if(write_seg_sel && wr_seg_index == 3'd2) ss   <= wr_seg_sel; else ss   <= ss_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) fs   <= `STARTUP_FS;   else if(fs_invalidate) fs <= 16'd0; else if(write_seg_sel && wr_seg_index == 3'd4) fs   <= wr_seg_sel; else fs   <= fs_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) gs   <= `STARTUP_GS;   else if(gs_invalidate) gs <= 16'd0; else if(write_seg_sel && wr_seg_index == 3'd5) gs   <= wr_seg_sel; else gs   <= gs_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cs   <= `STARTUP_CS;                                       else if(write_seg_sel && wr_seg_index == 3'd1) cs   <= wr_seg_sel; else cs   <= cs_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) ldtr <= `STARTUP_LDTR;                                     else if(write_seg_sel && wr_seg_index == 3'd6) ldtr <= wr_seg_sel; else ldtr <= ldtr_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tr   <= `STARTUP_TR;                                       else if(write_seg_sel && wr_seg_index == 3'd7) tr   <= wr_seg_sel; else tr   <= tr_to_reg;   end
-
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) es_rpl   <= `STARTUP_ES_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd0)                             es_rpl   <= wr_seg_rpl; else es_rpl   <= es_rpl_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) ds_rpl   <= `STARTUP_DS_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd3)                             ds_rpl   <= wr_seg_rpl; else ds_rpl   <= ds_rpl_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) ss_rpl   <= `STARTUP_SS_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd2)                             ss_rpl   <= wr_seg_rpl; else ss_rpl   <= ss_rpl_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) fs_rpl   <= `STARTUP_FS_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd4)                             fs_rpl   <= wr_seg_rpl; else fs_rpl   <= fs_rpl_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) gs_rpl   <= `STARTUP_GS_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd5)                             gs_rpl   <= wr_seg_rpl; else gs_rpl   <= gs_rpl_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) cs_rpl   <= `STARTUP_CS_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd1)                             cs_rpl   <= wr_seg_rpl; else cs_rpl   <= cs_rpl_to_reg;   end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) ldtr_rpl <= `STARTUP_LDTR_RPL; else if(write_seg_rpl && wr_seg_index == 3'd6 && w_seg_cache[`DESC_BIT_P]) ldtr_rpl <= wr_seg_rpl; else ldtr_rpl <= ldtr_rpl_to_reg; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) tr_rpl   <= `STARTUP_TR_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd7)                             tr_rpl   <= wr_seg_rpl; else tr_rpl   <= tr_rpl_to_reg;   end
-
-`define ALWAYS   always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0)
+always @(posedge clk) begin if(rst) es   <= `STARTUP_ES;   else if(es_invalidate) es <= 16'd0; else if(write_seg_sel && wr_seg_index == 3'd0) es   <= wr_seg_sel; else es   <= es_to_reg;   end
+always @(posedge clk) begin if(rst) ds   <= `STARTUP_DS;   else if(ds_invalidate) ds <= 16'd0; else if(write_seg_sel && wr_seg_index == 3'd3) ds   <= wr_seg_sel; else ds   <= ds_to_reg;   end
+always @(posedge clk) begin if(rst) ss   <= `STARTUP_SS;                                       else if(write_seg_sel && wr_seg_index == 3'd2) ss   <= wr_seg_sel; else ss   <= ss_to_reg;   end
+always @(posedge clk) begin if(rst) fs   <= `STARTUP_FS;   else if(fs_invalidate) fs <= 16'd0; else if(write_seg_sel && wr_seg_index == 3'd4) fs   <= wr_seg_sel; else fs   <= fs_to_reg;   end
+always @(posedge clk) begin if(rst) gs   <= `STARTUP_GS;   else if(gs_invalidate) gs <= 16'd0; else if(write_seg_sel && wr_seg_index == 3'd5) gs   <= wr_seg_sel; else gs   <= gs_to_reg;   end
+always @(posedge clk) begin if(rst) cs   <= `STARTUP_CS;                                       else if(write_seg_sel && wr_seg_index == 3'd1) cs   <= wr_seg_sel; else cs   <= cs_to_reg;   end
+always @(posedge clk) begin if(rst) ldtr <= `STARTUP_LDTR;                                     else if(write_seg_sel && wr_seg_index == 3'd6) ldtr <= wr_seg_sel; else ldtr <= ldtr_to_reg; end
+always @(posedge clk) begin if(rst) tr   <= `STARTUP_TR;                                       else if(write_seg_sel && wr_seg_index == 3'd7) tr   <= wr_seg_sel; else tr   <= tr_to_reg;   end
+
+always @(posedge clk) begin if(rst) es_rpl   <= `STARTUP_ES_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd0)                             es_rpl   <= wr_seg_rpl; else es_rpl   <= es_rpl_to_reg;   end
+always @(posedge clk) begin if(rst) ds_rpl   <= `STARTUP_DS_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd3)                             ds_rpl   <= wr_seg_rpl; else ds_rpl   <= ds_rpl_to_reg;   end
+always @(posedge clk) begin if(rst) ss_rpl   <= `STARTUP_SS_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd2)                             ss_rpl   <= wr_seg_rpl; else ss_rpl   <= ss_rpl_to_reg;   end
+always @(posedge clk) begin if(rst) fs_rpl   <= `STARTUP_FS_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd4)                             fs_rpl   <= wr_seg_rpl; else fs_rpl   <= fs_rpl_to_reg;   end
+always @(posedge clk) begin if(rst) gs_rpl   <= `STARTUP_GS_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd5)                             gs_rpl   <= wr_seg_rpl; else gs_rpl   <= gs_rpl_to_reg;   end
+always @(posedge clk) begin if(rst) cs_rpl   <= `STARTUP_CS_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd1)                             cs_rpl   <= wr_seg_rpl; else cs_rpl   <= cs_rpl_to_reg;   end
+always @(posedge clk) begin if(rst) ldtr_rpl <= `STARTUP_LDTR_RPL; else if(write_seg_rpl && wr_seg_index == 3'd6 && w_seg_cache[`DESC_BIT_P]) ldtr_rpl <= wr_seg_rpl; else ldtr_rpl <= ldtr_rpl_to_reg; end
+always @(posedge clk) begin if(rst) tr_rpl   <= `STARTUP_TR_RPL;   else if(write_seg_rpl && wr_seg_index == 3'd7)                             tr_rpl   <= wr_seg_rpl; else tr_rpl   <= tr_rpl_to_reg;   end
+
+`define ALWAYS   always @(posedge clk) begin if(rst)
 
 // G=0, D/B=0, P=1, Data, Accessed, R/W
 `define DEFAULT_SEG_CACHE       { 8'd0,  8'd0, 1'b1, 2'b0, 1'b1, 1'b0, 1'b0, 2'b11, 8'd0,  16'd0, 16'hFFFF }
diff --git a/rtl/ao486/pipeline/write_stack.v b/rtl/ao486/pipeline/write_stack.v
index 8a01788..91bfde7 100644
--- a/rtl/ao486/pipeline/write_stack.v
+++ b/rtl/ao486/pipeline/write_stack.v
@@ -66,7 +66,13 @@ module write_stack(
 //------------------------------------------------------------------------------ stack
 
 wire [2:0]  wr_push_length_minus_1;
-
+wire [31:0] w_new_upper_limit;
+wire        w_new_push_not_fit;
+wire        w_new_push_limit_overflow;
+wire [31:0] w_upper_limit;
+wire        w_push_not_fit;
+wire        w_push_limit_overflow;
+   
 assign wr_stack_esp = (ss_cache[`DESC_BIT_D_B])? wr_stack_offset : { esp[31:16], wr_stack_offset[15:0] };
 
 assign wr_push_linear = ss_base + wr_stack_offset;
@@ -77,10 +83,6 @@ assign wr_push_length_minus_1 =  wr_push_length - 3'd1;
 
 //------------------------------------------------------------------------------ write_new_stack_virtual
 
-wire [31:0] w_new_upper_limit;
-wire        w_new_push_not_fit;
-wire        w_new_push_limit_overflow;
-
 assign wr_new_stack_esp = (glob_descriptor[`DESC_BIT_D_B])? wr_stack_offset : { esp[31:16], wr_stack_offset[15:0] };
 
 assign wr_new_push_linear = glob_desc_base + wr_stack_offset;
@@ -103,10 +105,6 @@ assign wr_new_push_ss_fault = wr_new_push_ss_fault_check &&
 
 //------------------------------------------------------------------------------
 
-wire [31:0] w_upper_limit;
-wire        w_push_not_fit;
-wire        w_push_limit_overflow;
-
 assign w_upper_limit = (ss_cache[`DESC_BIT_D_B])? 32'hFFFFFFFF : 32'h0000FFFF;
 
 // (CODE or not EXPAND-DOWN)
diff --git a/rtl/common/simple_bidir_ram.v b/rtl/common/simple_bidir_ram.v
index 10c9d7a..febb625 100644
--- a/rtl/common/simple_bidir_ram.v
+++ b/rtl/common/simple_bidir_ram.v
@@ -24,19 +24,21 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-module simple_bidir_ram(
-    input                       clk,
+module simple_bidir_ram
+  #(parameter width = 1,
+    parameter widthad = 1)
+   
+   (
+    input 		   clk,
     
-    input       [widthad-1:0]   address_a,
-    input                       wren_a,
-    input       [width-1:0]     data_a,
-    output reg  [width-1:0]     q_a,
+    input [widthad-1:0]    address_a,
+    input 		   wren_a,
+    input [width-1:0] 	   data_a,
+    output reg [width-1:0] q_a,
     
-    input       [widthad-1:0]   address_b,
-    output reg  [width-1:0]     q_b
-);
-parameter width     = 1;
-parameter widthad   = 1;
+    input [widthad-1:0]    address_b,
+    output reg [width-1:0] q_b
+    );
 
 reg [width-1:0] mem [(2**widthad)-1:0];
 
diff --git a/rtl/common/simple_fifo.v b/rtl/common/simple_fifo.v
index 03a451c..39530ac 100644
--- a/rtl/common/simple_fifo.v
+++ b/rtl/common/simple_fifo.v
@@ -24,23 +24,24 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-module simple_fifo(
-    input                       clk,
-    input                       rst_n,
-    input                       sclr,
+module simple_fifo
+  #(parameter width     = 1,
+    parameter widthu    = 1
+    )
+   (
+    input 		    clk,
+    input 		    rst,
+    input 		    sclr,
     
-    input                       rdreq,
-    input                       wrreq,
-    input       [width-1:0]     data,
+    input 		    rdreq,
+    input 		    wrreq,
+    input [width-1:0] 	    data,
     
-    output                      empty,
-    output reg                  full,
-    output      [width-1:0]     q,
-    output reg  [widthu-1:0]    usedw
-);
-
-parameter width     = 1;
-parameter widthu    = 1;
+    output 		    empty,
+    output reg 		    full,
+    output [width-1:0] 	    q,
+    output reg [widthu-1:0] usedw
+    );
 
 reg [width-1:0] mem [(2**widthu)-1:0];
 
@@ -50,14 +51,14 @@ reg [widthu-1:0] wr_index = 0;
 assign q    = mem[rd_index];
 assign empty= usedw == 0 && ~(full);
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           rd_index <= 0;
+always @(posedge clk) begin
+    if(rst)           rd_index <= 0;
     else if(sclr)               rd_index <= 0;
     else if(rdreq && ~(empty))  rd_index <= rd_index + { {widthu-1{1'b0}}, 1'b1 };
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       wr_index <= 0;
+always @(posedge clk) begin
+    if(rst)                       wr_index <= 0;
     else if(sclr)                           wr_index <= 0;
     else if(wrreq && (~(full) || rdreq))    wr_index <= wr_index + { {widthu-1{1'b0}}, 1'b1 };
 end
@@ -66,15 +67,15 @@ always @(posedge clk) begin
     if(wrreq && (~(full) || rdreq)) mem[wr_index] <= data;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               full <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                               full <= 1'b0;
     else if(sclr)                                                   full <= 1'b0;
     else if(rdreq && ~(wrreq) && full)                              full <= 1'b0;
     else if(~(rdreq) && wrreq && ~(full) && usedw == (2**widthu)-1) full <= 1'b1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       usedw <= 0;
+always @(posedge clk) begin
+    if(rst)                       usedw <= 0;
     else if(sclr)                           usedw <= 0;
     else if(rdreq && ~(wrreq) && ~(empty))  usedw <= usedw - { {widthu-1{1'b0}}, 1'b1 };
     else if(~(rdreq) && wrreq && ~(full))   usedw <= usedw + { {widthu-1{1'b0}}, 1'b1 };
diff --git a/rtl/common/simple_mult.v b/rtl/common/simple_mult.v
index 8590507..dd173dd 100644
--- a/rtl/common/simple_mult.v
+++ b/rtl/common/simple_mult.v
@@ -24,19 +24,20 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-module simple_mult(
-    input                           clk,
-    input signed    [widtha-1:0]    a,
-    input signed    [widthb-1:0]    b,
-    output          [widthp-1:0]    out
-);
+module simple_mult
+  #(parameter widtha = 1,
+    parameter widthb = 1,
+    parameter widthp = 2
+    )
+   (
+    input 		      clk,
+    input signed [widtha-1:0] a,
+    input signed [widthb-1:0] b,
+    output [widthp-1:0]       out
+    );
 
 //------------------------------------------------------------------------------
 
-parameter widtha = 1;
-parameter widthb = 1;
-parameter widthp = 2;
-
 //------------------------------------------------------------------------------
 
 reg signed [widtha-1:0] a_reg;
diff --git a/rtl/common/simple_ram.v b/rtl/common/simple_ram.v
index 04ffb2e..230ea83 100644
--- a/rtl/common/simple_ram.v
+++ b/rtl/common/simple_ram.v
@@ -24,18 +24,20 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-module simple_ram(
-    input                       clk,
+module simple_ram
+  #(parameter width     = 1,
+    parameter widthad   = 1
+    )
+   (
+    input 		   clk,
     
-    input       [widthad-1:0]   wraddress,
-    input                       wren,
-    input       [width-1:0]     data,
+    input [widthad-1:0]    wraddress,
+    input 		   wren,
+    input [width-1:0] 	   data,
     
-    input       [widthad-1:0]   rdaddress,
-    output reg  [width-1:0]     q
-);
-parameter width     = 1;
-parameter widthad   = 1;
+    input [widthad-1:0]    rdaddress,
+    output reg [width-1:0] q
+    );
 
 reg [width-1:0] mem [(2**widthad)-1:0];
 
diff --git a/rtl/common/simple_rom.v b/rtl/common/simple_rom.v
index 214001a..b8cb6e8 100644
--- a/rtl/common/simple_rom.v
+++ b/rtl/common/simple_rom.v
@@ -24,18 +24,20 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-module simple_rom(
-    input                       clk,
+module simple_rom
+  #(parameter width     = 1,
+    parameter widthad   = 1)
+   (
+    input 		   clk,
     
-    input       [widthad-1:0]   addr_a,
-    output reg  [width-1:0]     q_a,
+    input [widthad-1:0]    addr_a,
+    output reg [width-1:0] q_a,
     
-    input       [widthad-1:0]   addr_b,
-    output reg  [width-1:0]     q_b
-);
+    input [widthad-1:0]    addr_b,
+    output reg [width-1:0] q_b
+    );
+   
 
-parameter width     = 1;
-parameter widthad   = 1;
 parameter datafile  = "none";
 
 reg [width-1:0] mem [(2**widthad)-1:0];
diff --git a/rtl/common/simple_single_rom.v b/rtl/common/simple_single_rom.v
index ed2a5f0..ed64e6f 100644
--- a/rtl/common/simple_single_rom.v
+++ b/rtl/common/simple_single_rom.v
@@ -24,23 +24,21 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-module simple_single_rom(
+module simple_single_rom
+#(parameter width     = 1,
+parameter widthad   = 1,
+parameter datafile  = "none"
+)
+(
     input                       clk,
     
     input       [widthad-1:0]   addr,
     output reg  [width-1:0]     q
 );
 
-parameter width     = 1;
-parameter widthad   = 1;
-parameter datafile  = "none";
 
-reg [width-1:0] mem [(2**widthad)-1:0];
 
-initial
-begin
-$readmemb(datafile, mem);
-end
+reg [width-1:0] mem [(2**widthad)-1:0];
 
 always @(posedge clk) begin
     q <= mem[addr];
diff --git a/rtl/soc/driver_sd/avalon_master.v b/rtl/soc/driver_sd/avalon_master.v
index 38c9de0..82d40ae 100644
--- a/rtl/soc/driver_sd/avalon_master.v
+++ b/rtl/soc/driver_sd/avalon_master.v
@@ -7,7 +7,7 @@
 
 module avalon_master(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //
     output reg  [31:0]  avm_address,
@@ -36,46 +36,46 @@ module avalon_master(
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   avm_address <= 32'd0;
+always @(posedge clk) begin
+    if(rst)                   avm_address <= 32'd0;
     else if(read_start || write_start)  avm_address <= avalon_address_base;
     else if(read_next || write_next)    avm_address <= avm_address + 32'd4;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   avm_read <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   avm_read <= 1'b0;
     else if(read_start || read_next)    avm_read <= 1'b1;
     else if(~(avm_waitrequest))         avm_read <= 1'b0;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   avm_write <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   avm_write <= 1'b0;
     else if(write_start || write_next)  avm_write <= 1'b1;
     else if(~(avm_waitrequest))         avm_write <= 1'b0;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   avm_writedata <= 32'd0;
+always @(posedge clk) begin
+    if(rst)                   avm_writedata <= 32'd0;
     else if(write_start || write_next)  avm_writedata <= write_data;
 end
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   read_data <= 32'd0;
+always @(posedge clk) begin
+    if(rst)                   read_data <= 32'd0;
     else if(avm_readdatavalid)          read_data <= avm_readdata;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   read_done <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   read_done <= 1'b0;
     else if(read_start || read_next)    read_done <= 1'b0;
     else                                read_done <= avm_readdatavalid;
 end
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   write_done <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   write_done <= 1'b0;
     else if(write_start || write_next)  write_done <= 1'b0;
     else                                write_done <= ~(avm_waitrequest) && avm_write;
 end
diff --git a/rtl/soc/driver_sd/avalon_slave.v b/rtl/soc/driver_sd/avalon_slave.v
index 975dd93..8154f5d 100644
--- a/rtl/soc/driver_sd/avalon_slave.v
+++ b/rtl/soc/driver_sd/avalon_slave.v
@@ -6,39 +6,43 @@
  */
 
 module avalon_slave(
-    input               clk,
-    input               rst_n,
+    input 	      clk,
+    input 	      rst,
     
     //
-    input       [1:0]   avs_address,
-    input               avs_read,
-    output      [31:0]  avs_readdata,
-    input               avs_write,
-    input       [31:0]  avs_writedata,
+    input [1:0]       avs_address,
+    input 	      avs_read,
+    output [31:0]     avs_readdata,
+    input 	      avs_write,
+    input [31:0]      avs_writedata,
     
     //
-    output reg          operation_init,
-    output reg          operation_read,
-    output reg          operation_write,
+    output reg 	      operation_init,
+    output reg 	      operation_read,
+    output reg 	      operation_write,
     
-    input               operation_sector_update,
-    output              operation_sector_last,
+    input 	      operation_sector_update,
+    output 	      operation_sector_last,
     
-    input               operation_finished_ok,
-    input               operation_finished_with_error,
+    input 	      operation_finished_ok,
+    input 	      operation_finished_with_error,
     
     //
-    output reg  [31:0]  sd_address,
-    output reg  [31:0]  avalon_address_base  
+    output reg [31:0] sd_address,
+    output reg [31:0] avalon_address_base, 
+    output [2:0]      sd_status,
+    output [17:0]     ledr_out
 );
 
 //------------------------------------------------------------------------------
 
+assign sd_status = status;
+
 assign avs_readdata = (avs_address == 2'd0)? {29'd0, status[2:0]} : { 29'd0, mutex };
 
 reg [2:0] mutex;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                               mutex <= 3'd0;
+always @(posedge clk) begin
+    if(rst)                                                               mutex <= 3'd0;
     else if(mutex == 3'd0 && avs_address == 2'd1 && avs_read)                       mutex <= 3'd1;
     else if(mutex == 3'd0 && avs_address == 2'd2 && avs_read)                       mutex <= 3'd2;
     else if(mutex == 3'd0 && avs_address == 2'd3 && avs_read)                       mutex <= 3'd3;
@@ -55,20 +59,20 @@ localparam [1:0] CONTROL_INIT   = 2'd1;
 localparam [1:0] CONTROL_READ   = 2'd2;
 localparam [1:0] CONTROL_WRITE  = 2'd3;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                   operation_init <= 1'b1;
+always @(posedge clk) begin
+    if(rst)                                                                                   operation_init <= 1'b1;
     else if(operation_finished_ok || operation_finished_with_error)                                     operation_init <= 1'b0;
     else if(operation_idle && avs_write && avs_address == 2'd3 && avs_writedata[1:0] == CONTROL_INIT)   operation_init <= 1'b1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                   operation_read <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                                                   operation_read <= 1'b0;
     else if(operation_finished_ok || operation_finished_with_error)                                     operation_read <= 1'b0;
     else if(operation_idle && avs_write && avs_address == 2'd3 && avs_writedata[1:0] == CONTROL_READ)   operation_read <= 1'b1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                   operation_write <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                                                   operation_write <= 1'b0;
     else if(operation_finished_ok || operation_finished_with_error)                                     operation_write <= 1'b0;
     else if(operation_idle && avs_write && avs_address == 2'd3 && avs_writedata[1:0] == CONTROL_WRITE)  operation_write <= 1'b1;
 end
@@ -83,8 +87,8 @@ localparam [2:0] STATUS_WRITE       = 3'd4;
 localparam [2:0] STATUS_ERROR       = 3'd5;
 
 reg [2:0] status;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                   status <= STATUS_INIT;
+always @(posedge clk) begin
+    if(rst)                                                                                   status <= STATUS_INIT;
     else if(operation_idle && avs_write && avs_address == 2'd3 && avs_writedata[1:0] == CONTROL_INIT)   status <= STATUS_INIT;
     else if(operation_idle && avs_write && avs_address == 2'd3 && avs_writedata[1:0] == CONTROL_READ)   status <= STATUS_READ;
     else if(operation_idle && avs_write && avs_address == 2'd3 && avs_writedata[1:0] == CONTROL_WRITE)  status <= STATUS_WRITE;
@@ -95,19 +99,22 @@ end
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                           avalon_address_base <= 32'd0;
+   //assign ledr_out = {avalon_address_base[19:16], sd_address[5:0], sd_block_count[7:0]};
+   assign ledr_out = avalon_address_base[31:14];
+	
+always @(posedge clk) begin
+    if(rst)                                           avalon_address_base <= 32'd0;
     else if(operation_idle && avs_write && avs_address == 2'd0) avalon_address_base <= avs_writedata;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                           sd_address <= 32'd0;
+always @(posedge clk) begin
+    if(rst)                                           sd_address <= 32'd0;
     else if(operation_idle && avs_write && avs_address == 2'd1) sd_address <= avs_writedata;
 end
 
 reg [31:0] sd_block_count;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                           sd_block_count <= 32'd0;
+always @(posedge clk) begin
+    if(rst)                                           sd_block_count <= 32'd0;
     else if(operation_sector_update)                            sd_block_count <= sd_block_count - 32'd1;
     else if(operation_idle && avs_write && avs_address == 2'd2) sd_block_count <= avs_writedata;
 end
diff --git a/rtl/soc/driver_sd/card_init.v b/rtl/soc/driver_sd/card_init.v
index 3b1f9dd..04cf8c3 100644
--- a/rtl/soc/driver_sd/card_init.v
+++ b/rtl/soc/driver_sd/card_init.v
@@ -7,7 +7,7 @@
 
 module card_init(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //
     input               operation_init,
@@ -30,10 +30,48 @@ module card_init(
 );
 
 //------------------------------------------------------------------------------
-
+localparam [3:0] S_IDLE         = 4'd0;
+localparam [3:0] S_CMD0         = 4'd1;
+localparam [3:0] S_CMD8         = 4'd2;
+localparam [3:0] S_CMD55_FOR_41 = 4'd3;
+localparam [3:0] S_ACMD41       = 4'd4;
+localparam [3:0] S_CMD2         = 4'd5;
+localparam [3:0] S_CMD3         = 4'd6;
+localparam [3:0] S_CMD7         = 4'd7;
+localparam [3:0] S_WAIT_DAT0    = 4'd8;
+localparam [3:0] S_CMD55_FOR_6  = 4'd9;
+localparam [3:0] S_ACMD6        = 4'd10;
 reg [23:0] initial_delay;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   initial_delay <= 24'd0;
+reg [19:0] acmd41_busy_cnt;
+reg [15:0] rca;
+reg [3:0] state;
+wire prepare_cmd0;
+wire valid_cmd0;
+wire prepare_cmd8;
+wire valid_cmd8;
+wire prepare_cmd55_for_41;
+wire valid_cmd55;
+wire prepare_acmd41;
+wire valid_acmd41;
+wire valid_acmd41_but_busy;
+wire repeat_acmd41;
+wire prepare_cmd2;
+wire valid_cmd2;
+wire prepare_cmd3;
+wire valid_cmd3;
+wire [15:0] cmd3_new_rca ;
+wire prepare_cmd7;
+wire valid_cmd7_common;
+wire valid_cmd7;
+wire valid_cmd7_but_busy;
+wire prepare_cmd55_for_6;
+wire prepare_acmd6;
+wire valid_acmd6;
+wire _unused_ok;
+
+   
+always @(posedge clk) begin
+    if(rst)                   initial_delay <= 24'd0;
     else if(initial_delay[23] == 1'b0)  initial_delay <= initial_delay + 24'd1;
 end
 
@@ -53,69 +91,55 @@ assign operation_finished_ok = state == S_ACMD6 && reply_ready && valid_acmd6;
 
 //------------------------------------------------------------------------------
 
-wire prepare_cmd0           = state == S_IDLE && initial_delay[23] && operation_init;
-wire valid_cmd0             = 1'b1; //always valid
+ assign prepare_cmd0 = state == S_IDLE && initial_delay[23] && operation_init;
+ assign valid_cmd0 = 1'b1; //always valid
 
-wire prepare_cmd8           = state == S_CMD0 && reply_ready && valid_cmd0;
-wire valid_cmd8             = reply_contents[45:40] == 6'd8 && reply_contents[19:16] == 4'b0001 && reply_contents[15:8] == 8'b11010010; //command index; accepted volage 2.7-3.6 V; check pattern echo
+ assign prepare_cmd8 = state == S_CMD0 && reply_ready && valid_cmd0;
+ assign valid_cmd8 = reply_contents[45:40] == 6'd8 && reply_contents[19:16] == 4'b0001 && reply_contents[15:8] == 8'b11010010; //command index; accepted volage 2.7-3.6 V; check pattern echo
 
-wire prepare_cmd55_for_41   = (state == S_CMD8 && reply_ready && valid_cmd8) || repeat_acmd41;
-wire valid_cmd55            = reply_contents[45:40] == 6'd55 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
+ assign prepare_cmd55_for_41 = (state == S_CMD8 && reply_ready && valid_cmd8) || repeat_acmd41;
+ assign valid_cmd55 = reply_contents[45:40] == 6'd55 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
 
-wire prepare_acmd41         = state == S_CMD55_FOR_41 && reply_ready && valid_cmd55;
-wire valid_acmd41           = reply_contents[39:38] == 2'b11;                            //initialization complete and SDHC or SDXC;
-wire valid_acmd41_but_busy  = reply_contents[39] == 1'b0 && acmd41_busy_cnt < 20'hFFFFF; //initialization not complete
-wire repeat_acmd41          = state == S_ACMD41 && reply_ready && valid_acmd41_but_busy;
+ assign prepare_acmd41 = state == S_CMD55_FOR_41 && reply_ready && valid_cmd55;
+ assign valid_acmd41 = reply_contents[39:38] == 2'b11;                            //initialization complete and SDHC or SDXC;
+ assign valid_acmd41_but_busy = reply_contents[39] == 1'b0 && acmd41_busy_cnt < 20'hFFFFF; //initialization not complete
+ assign repeat_acmd41 = state == S_ACMD41 && reply_ready && valid_acmd41_but_busy;
 
-wire prepare_cmd2           = state == S_ACMD41 && reply_ready && valid_acmd41;
-wire valid_cmd2             = 1'b1; //always valid
+ assign prepare_cmd2 = state == S_ACMD41 && reply_ready && valid_acmd41;
+ assign valid_cmd2 = 1'b1; //always valid
 
-wire prepare_cmd3           = state == S_CMD2 && reply_ready && valid_cmd2;
-wire valid_cmd3             = reply_contents[45:40] == 6'd3 && reply_contents[23:21] == 3'b0; //command index; R1[23,22,19] no errors
-wire [15:0] cmd3_new_rca    = reply_contents[39:24];
+ assign prepare_cmd3 = state == S_CMD2 && reply_ready && valid_cmd2;
+ assign valid_cmd3 = reply_contents[45:40] == 6'd3 && reply_contents[23:21] == 3'b0; //command index; R1[23,22,19] no errors
+ assign cmd3_new_rca = reply_contents[39:24];
 
-wire prepare_cmd7           = state == S_CMD3 && reply_ready && valid_cmd3;
-wire valid_cmd7_common      = reply_contents[45:40] == 6'd7 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
-wire valid_cmd7             = valid_cmd7_common && current_dat0; 
-wire valid_cmd7_but_busy    = valid_cmd7_common && ~(current_dat0);
+ assign prepare_cmd7 = state == S_CMD3 && reply_ready && valid_cmd3;
+ assign valid_cmd7_common = reply_contents[45:40] == 6'd7 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
+ assign valid_cmd7 = valid_cmd7_common && current_dat0; 
+ assign valid_cmd7_but_busy = valid_cmd7_common && ~(current_dat0);
 
-wire prepare_cmd55_for_6    = (state == S_CMD7 && reply_ready && valid_cmd7) || (state == S_WAIT_DAT0 && current_dat0);
+ assign prepare_cmd55_for_6 = (state == S_CMD7 && reply_ready && valid_cmd7) || (state == S_WAIT_DAT0 && current_dat0);
 
-wire prepare_acmd6          = state == S_CMD55_FOR_6 && reply_ready && valid_cmd55;
-wire valid_acmd6            = reply_contents[45:40] == 6'd6 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
+ assign prepare_acmd6 = state == S_CMD55_FOR_6 && reply_ready && valid_cmd55;
+ assign valid_acmd6 = reply_contents[45:40] == 6'd6 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
 
 //------------------------------------------------------------------------------
 
-reg [19:0] acmd41_busy_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       acmd41_busy_cnt <= 20'd0;
+always @(posedge clk) begin
+    if(rst)       acmd41_busy_cnt <= 20'd0;
     else if(prepare_cmd0)   acmd41_busy_cnt <= 20'd0;
     else if(repeat_acmd41)  acmd41_busy_cnt <= acmd41_busy_cnt + 20'd1;
 end
 
-reg [15:0] rca;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       rca <= 16'd0;
+always @(posedge clk) begin
+    if(rst)       rca <= 16'd0;
     else if(prepare_cmd7)   rca <= cmd3_new_rca;
 end
 
 //------------------------------------------------------------------------------
 
-localparam [3:0] S_IDLE         = 4'd0;
-localparam [3:0] S_CMD0         = 4'd1;
-localparam [3:0] S_CMD8         = 4'd2;
-localparam [3:0] S_CMD55_FOR_41 = 4'd3;
-localparam [3:0] S_ACMD41       = 4'd4;
-localparam [3:0] S_CMD2         = 4'd5;
-localparam [3:0] S_CMD3         = 4'd6;
-localparam [3:0] S_CMD7         = 4'd7;
-localparam [3:0] S_WAIT_DAT0    = 4'd8;
-localparam [3:0] S_CMD55_FOR_6  = 4'd9;
-localparam [3:0] S_ACMD6        = 4'd10;
 
-reg [3:0] state;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               state <= S_IDLE;
+always @(posedge clk) begin
+    if(rst)                                               state <= S_IDLE;
     
     else if(operation_finished_with_error)                          state <= S_IDLE;
     
@@ -210,7 +234,7 @@ assign cmd_resp_has_crc7 =
 
 //------------------------------------------------------------------------------
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, reply_contents[135:46], reply_contents[20], reply_contents[7:0], 1'b0 };
+ assign _unused_ok = &{ 1'b0, reply_contents[135:46], reply_contents[20], reply_contents[7:0], 1'b0 };
 // synthesis translate_on
 //------------------------------------------------------------------------------
 
diff --git a/rtl/soc/driver_sd/card_read.v b/rtl/soc/driver_sd/card_read.v
index f2e9a1b..4e11330 100644
--- a/rtl/soc/driver_sd/card_read.v
+++ b/rtl/soc/driver_sd/card_read.v
@@ -7,7 +7,7 @@
 
 module card_read(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //
     input               operation_read,
@@ -61,21 +61,35 @@ localparam [2:0] S_WAIT_FOR_DATA    = 3'd2;
 localparam [2:0] S_CMD12            = 3'd3;
 localparam [2:0] S_WAIT_FOR_DAT0    = 3'd4;
 localparam [2:0] S_FAILED_CMD12     = 3'd5;
-
-wire prepare_cmd18 = state == S_IDLE && operation_read;
-wire valid_cmd18   = reply_contents[45:40] == 6'd18 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
-
-wire stop_because_of_error = (state == S_CMD18 && (reply_error || (reply_ready && ~(valid_cmd18)))) || ((state == S_CMD18 || state == S_WAIT_FOR_DATA) && rd_error);
-wire prepare_cmd12         = stop_because_of_error || (operation_sector_update && operation_sector_last);
-wire valid_cmd12_common    = reply_contents[45:40] == 6'd12 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
-wire valid_cmd12           = valid_cmd12_common && current_dat0; 
-wire valid_cmd12_but_busy  = valid_cmd12_common && ~(current_dat0);
-
-wire prepare_failed_cmd12  = state == S_CMD12 && (reply_error || (reply_ready && ~(valid_cmd12_common))); 
-
 reg [2:0] state;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   state <= S_IDLE;
+reg was_error;
+reg first_write;
+reg [3:0] write_cnt;
+wire prepare_cmd18;
+wire valid_cmd18;
+wire stop_because_of_error;
+wire prepare_cmd12;
+wire valid_cmd12_common;
+wire valid_cmd12;
+wire valid_cmd12_but_busy;
+wire prepare_failed_cmd12;
+wire finishing;
+wire _unused_ok;
+   
+
+ assign prepare_cmd18 = state == S_IDLE && operation_read;
+ assign valid_cmd18 = reply_contents[45:40] == 6'd18 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
+
+ assign stop_because_of_error = (state == S_CMD18 && (reply_error || (reply_ready && ~(valid_cmd18)))) || ((state == S_CMD18 || state == S_WAIT_FOR_DATA) && rd_error);
+ assign prepare_cmd12 = stop_because_of_error || (operation_sector_update && operation_sector_last);
+ assign valid_cmd12_common = reply_contents[45:40] == 6'd12 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
+ assign valid_cmd12 = valid_cmd12_common && current_dat0; 
+ assign valid_cmd12_but_busy = valid_cmd12_common && ~(current_dat0);
+
+ assign prepare_failed_cmd12 = state == S_CMD12 && (reply_error || (reply_ready && ~(valid_cmd12_common))); 
+
+always @(posedge clk) begin
+    if(rst)                                                   state <= S_IDLE;
     
     else if(operation_finished_with_error)                              state <= S_IDLE;
     
@@ -89,30 +103,27 @@ always @(posedge clk or negedge rst_n) begin
     else if(operation_finished_ok)                                      state <= S_IDLE;
 end
 
-reg was_error;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   was_error <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                   was_error <= 1'b0;
     else if(prepare_cmd18)                                              was_error <= 1'b0;
     else if(stop_because_of_error || rd_error || prepare_failed_cmd12)  was_error <= 1'b1;
 end
 
-wire finishing = (state == S_CMD12 && reply_ready && valid_cmd12) || (state == S_WAIT_FOR_DAT0 && current_dat0) || state == S_FAILED_CMD12;
+ assign finishing = (state == S_CMD12 && reply_ready && valid_cmd12) || (state == S_WAIT_FOR_DAT0 && current_dat0) || state == S_FAILED_CMD12;
 
 assign operation_finished_ok         = finishing && ~(was_error);
 assign operation_finished_with_error = finishing && was_error;
 
 //------------------------------------------------------------------------------
 
-reg first_write;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       first_write <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       first_write <= 1'b0;
     else if(prepare_cmd18)  first_write <= 1'b1;
     else if(write_start)    first_write <= 1'b0;
 end
 
-reg [3:0] write_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               write_cnt <= 4'd0;
+always @(posedge clk) begin
+    if(rst)                               write_cnt <= 4'd0;
     else if(write_start || write_next)              write_cnt <= 4'd1;
     else if(write_done)                             write_cnt <= 4'd0;
     else if(write_cnt > 4'd0 && write_cnt < 4'd14)  write_cnt <= write_cnt + 4'd1;
@@ -140,7 +151,7 @@ assign cmd_resp_has_crc7 = 1'b1;
 
 //------------------------------------------------------------------------------
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, reply_contents[135:46], reply_contents[26:25], reply_contents[20:0], 1'b0 };
+ assign _unused_ok = &{ 1'b0, reply_contents[135:46], reply_contents[26:25], reply_contents[20:0], 1'b0 };
 // synthesis translate_on
 //------------------------------------------------------------------------------
 
diff --git a/rtl/soc/driver_sd/card_write.v b/rtl/soc/driver_sd/card_write.v
index 227926a..a5377e9 100644
--- a/rtl/soc/driver_sd/card_write.v
+++ b/rtl/soc/driver_sd/card_write.v
@@ -7,7 +7,7 @@
 
 module card_write(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //
     input               operation_write,
@@ -61,21 +61,36 @@ localparam [2:0] S_WAIT_FOR_DATA    = 3'd2;
 localparam [2:0] S_WAIT_FOR_DAT0    = 3'd3;
 localparam [2:0] S_CMD12            = 3'd4;
 localparam [2:0] S_FAILED_CMD12     = 3'd5;
-
-wire prepare_cmd25 = state == S_IDLE && operation_write;
-wire valid_cmd25   = reply_contents[45:40] == 6'd25 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
-
-wire stop_because_of_error = (state == S_CMD25 && (reply_error || (reply_ready && ~(valid_cmd25)))) || (state == S_WAIT_FOR_DATA && operation_sector_update && wr_error);
-wire prepare_cmd12         = stop_because_of_error || (operation_sector_update && operation_sector_last);
-wire valid_cmd12_common    = reply_contents[45:40] == 6'd12 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
-wire valid_cmd12           = valid_cmd12_common && current_dat0; 
-wire valid_cmd12_but_busy  = valid_cmd12_common && ~(current_dat0);
-
-wire prepare_failed_cmd12  = state == S_CMD12 && (reply_error || (reply_ready && ~(valid_cmd12_common))); 
-
 reg [2:0] state;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   state <= S_IDLE;
+reg was_error;
+reg first_read;
+reg [3:0] read_cnt;
+reg read_finished;
+wire prepare_cmd25;
+wire valid_cmd25;
+wire stop_because_of_error;
+wire prepare_cmd12;
+wire valid_cmd12_common;
+wire valid_cmd12;
+wire valid_cmd12_but_busy;
+wire prepare_failed_cmd12;
+wire finishing;
+wire read_condition;
+wire _unused_ok;
+   
+ assign prepare_cmd25 = state == S_IDLE && operation_write;
+ assign valid_cmd25 = reply_contents[45:40] == 6'd25 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
+
+ assign stop_because_of_error = (state == S_CMD25 && (reply_error || (reply_ready && ~(valid_cmd25)))) || (state == S_WAIT_FOR_DATA && operation_sector_update && wr_error);
+ assign prepare_cmd12 = stop_because_of_error || (operation_sector_update && operation_sector_last);
+ assign valid_cmd12_common = reply_contents[45:40] == 6'd12 && reply_contents[39:27] == 13'd0 && reply_contents[24:21] == 4'b0; //command index; R1[31:19] no errors; R1[16:13] no errors
+ assign valid_cmd12 = valid_cmd12_common && current_dat0; 
+ assign valid_cmd12_but_busy = valid_cmd12_common && ~(current_dat0);
+
+ assign prepare_failed_cmd12 = state == S_CMD12 && (reply_error || (reply_ready && ~(valid_cmd12_common))); 
+
+always @(posedge clk) begin
+    if(rst)                                                   state <= S_IDLE;
     
     else if(operation_finished_with_error)                              state <= S_IDLE;
     
@@ -89,30 +104,27 @@ always @(posedge clk or negedge rst_n) begin
     else if(operation_finished_ok)                                      state <= S_IDLE;
 end
 
-reg was_error;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       was_error <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                       was_error <= 1'b0;
     else if(prepare_cmd25)                                  was_error <= 1'b0;
     else if(stop_because_of_error || prepare_failed_cmd12)  was_error <= 1'b1;
 end
 
-wire finishing = (state == S_CMD12 && reply_ready && valid_cmd12) || (state == S_WAIT_FOR_DAT0 && current_dat0) || state == S_FAILED_CMD12;
+ assign finishing = (state == S_CMD12 && reply_ready && valid_cmd12) || (state == S_WAIT_FOR_DAT0 && current_dat0) || state == S_FAILED_CMD12;
 
 assign operation_finished_ok         = finishing && ~(was_error);
 assign operation_finished_with_error = finishing && was_error;
 
 //------------------------------------------------------------------------------
 
-reg first_read;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       first_read <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       first_read <= 1'b0;
     else if(prepare_cmd25)  first_read <= 1'b1;
     else if(read_start)     first_read <= 1'b0;
 end
 
-reg [3:0] read_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               read_cnt <= 4'd0;
+always @(posedge clk) begin
+    if(rst)                               read_cnt <= 4'd0;
     else if(read_start || read_next)                read_cnt <= 4'd1;
     else if(read_done)                              read_cnt <= 4'd0;
     else if(read_cnt > 4'd0 && read_cnt < 4'd14)    read_cnt <= read_cnt + 4'd1;
@@ -122,25 +134,24 @@ assign stop_sd_clk = read_cnt == 4'd14;
 
 assign operation_sector_update = wr_finished_sector;
 
-wire read_condition = state == S_WAIT_FOR_DATA && ~(wr_async_data_ready) && read_cnt == 4'd0 && ~(read_finished);
+ assign read_condition = state == S_WAIT_FOR_DATA && ~(wr_async_data_ready) && read_cnt == 4'd0 && ~(read_finished);
 assign read_start   = read_condition && first_read;
 assign read_next    = read_condition && ~(first_read);
 
-reg read_finished;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               read_finished <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                               read_finished <= 1'b0;
     else if(wr_data_done && wr_data_last_in_sector) read_finished <= 1'b1;
     else if(operation_sector_update)                read_finished <= 1'b0;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       wr_async_data_ready <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       wr_async_data_ready <= 1'b0;
     else if(wr_data_done)   wr_async_data_ready <= 1'b0;
     else if(read_done)      wr_async_data_ready <= 1'b1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       wr_async_data <= 32'b0;
+always @(posedge clk) begin
+    if(rst)       wr_async_data <= 32'b0;
     else if(read_done)      wr_async_data <= read_data;
 end
 
@@ -157,7 +168,7 @@ assign cmd_resp_has_crc7 = 1'b1;
 
 //------------------------------------------------------------------------------
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, reply_contents[135:46], reply_contents[26:25], reply_contents[20:0], 1'b0 };
+ assign _unused_ok = &{ 1'b0, reply_contents[135:46], reply_contents[26:25], reply_contents[20:0], 1'b0 };
 // synthesis translate_on
 //------------------------------------------------------------------------------
 
diff --git a/rtl/soc/driver_sd/cmd.v b/rtl/soc/driver_sd/cmd.v
index adb326d..9b38425 100644
--- a/rtl/soc/driver_sd/cmd.v
+++ b/rtl/soc/driver_sd/cmd.v
@@ -7,7 +7,7 @@
 
 module cmd(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //
     input               sd_clk_is_one,
@@ -28,139 +28,144 @@ module cmd(
     inout               sd_cmd
 );
 
+reg sd_cmd_enable;
+reg sd_cmd_output;
+reg sd_cmd_input;
+reg [3:0] cmd_start_delay_cnt;
+reg cmd_start_waiting;
+reg [5:0] cmd_cnt;
+reg [38:0] cmd_value;
+reg [6:0] cmd_crc7;
+reg [7:0] resp_cnt;
+reg resp_has_crc7;
+reg resp_awaiting;
+reg [6:0] resp_crc7;
+reg resp_next_is_trans_bit;
+reg resp_had_error;
+reg [6:0] error_delay_cnt;
+wire cmd_start;
+wire resp_active;
+wire resp_now_in_error;
+wire error_start;
+   
 //------------------------------------------------------------------------------
 
-reg sd_cmd_enable;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       sd_cmd_enable <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       sd_cmd_enable <= 1'b0;
     else if(sd_clk_is_one)  sd_cmd_enable <= cmd_start || cmd_cnt > 6'd0;
 end
 
-reg sd_cmd_output;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       sd_cmd_output <= 1'b1;
+always @(posedge clk) begin
+    if(rst)       sd_cmd_output <= 1'b1;
     else if(sd_clk_is_one)  sd_cmd_output <= (cmd_start)? 1'b0 : (cmd_cnt <= 6'd8 && cmd_cnt >= 6'd2)? cmd_crc7[0] : cmd_value[38];
 end
 
 assign sd_cmd = (sd_cmd_enable)? sd_cmd_output : 1'bZ;
 
-reg sd_cmd_input;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           sd_cmd_input <= 1'b1;
+always @(posedge clk) begin
+    if(rst)           sd_cmd_input <= 1'b1;
     else if(~(sd_clk_is_one))   sd_cmd_input <= sd_cmd;
 end
 
 //------------------------------------------------------------------------------
 
-reg [3:0] cmd_start_delay_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                     cmd_start_delay_cnt <= 4'd0;
+always @(posedge clk) begin
+    if(rst)                                     cmd_start_delay_cnt <= 4'd0;
     else if(reply_ready || reply_error)                   cmd_start_delay_cnt <= 4'd8;
     else if(sd_clk_is_one && cmd_start_delay_cnt > 4'd0)  cmd_start_delay_cnt <= cmd_start_delay_cnt - 4'd1;
 end
 
-reg cmd_start_waiting;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       cmd_start_waiting <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                       cmd_start_waiting <= 1'b0;
     else if(cmd_start)                                                      cmd_start_waiting <= 1'b0;
     else if(cmd_ready && (cmd_start_delay_cnt > 4'd0 || ~(sd_clk_is_one)))  cmd_start_waiting <= 1'b1;
 end
 
-wire cmd_start = sd_clk_is_one && (cmd_ready || cmd_start_waiting) && cmd_start_delay_cnt == 4'd0;
+ assign cmd_start = sd_clk_is_one && (cmd_ready || cmd_start_waiting) && cmd_start_delay_cnt == 4'd0;
 
-reg [5:0] cmd_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           cmd_cnt <= 6'd0;
+always @(posedge clk) begin
+    if(rst)                           cmd_cnt <= 6'd0;
     else if(cmd_start)                          cmd_cnt <= 6'd47;
     else if(sd_clk_is_one && cmd_cnt > 6'd0)    cmd_cnt <= cmd_cnt - 6'd1;
 end
 
-reg [38:0] cmd_value;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           cmd_value <= 39'h7FFFFFFFFF;
+always @(posedge clk) begin
+    if(rst)                           cmd_value <= 39'h7FFFFFFFFF;
     else if(cmd_ready)                          cmd_value <= { 1'b1, cmd_index, cmd_arg };
     else if(sd_clk_is_one && cmd_cnt > 6'd0)    cmd_value <= { cmd_value[37:0], 1'b1 }; //fill with 1 important
 end
 
-reg [6:0] cmd_crc7;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           cmd_crc7 <= 7'd0;
+always @(posedge clk) begin
+    if(rst)                           cmd_crc7 <= 7'd0;
     else if(sd_clk_is_one && cmd_cnt >= 6'd9)   cmd_crc7 <= { cmd_value[38] ^ cmd_crc7[0], cmd_crc7[6:5], cmd_crc7[4] ^ cmd_value[38] ^ cmd_crc7[0], cmd_crc7[3:1] };
     else if(sd_clk_is_one)                      cmd_crc7 <= { 1'b0, cmd_crc7[6:1] };
 end
 
 //------------------------------------------------------------------------------
 
-wire resp_active = sd_clk_is_one && resp_cnt > 8'd0 && cmd_cnt == 6'd0 && ~(cmd_start_waiting) && ((resp_awaiting && sd_cmd_input == 1'b0) || ~(resp_awaiting));
+ assign resp_active = sd_clk_is_one && resp_cnt > 8'd0 && cmd_cnt == 6'd0 && ~(cmd_start_waiting) && ((resp_awaiting && sd_cmd_input == 1'b0) || ~(resp_awaiting));
 
-reg [7:0] resp_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       resp_cnt <= 8'd0;
+always @(posedge clk) begin
+    if(rst)       resp_cnt <= 8'd0;
     else if(reply_error)    resp_cnt <= 8'd0;
     else if(cmd_ready)      resp_cnt <= cmd_resp_length;
     else if(resp_active)    resp_cnt <= resp_cnt - 8'd1;
 end
 
-reg resp_has_crc7;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   resp_has_crc7 <= 1'b0;
+always @(posedge clk) begin
+    if(rst)   resp_has_crc7 <= 1'b0;
     else if(cmd_ready)  resp_has_crc7 <= cmd_resp_has_crc7;
 end
 
-reg resp_awaiting;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               resp_awaiting <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                               resp_awaiting <= 1'b0;
     else if(reply_error)                                            resp_awaiting <= 1'b0;
     else if(sd_clk_is_one && cmd_cnt == 6'd1 && resp_cnt > 8'd0)    resp_awaiting <= 1'b1;
     else if(sd_clk_is_one && resp_awaiting && sd_cmd_input == 1'b0) resp_awaiting <= 1'b0;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       reply_contents <= 136'd0;
+always @(posedge clk) begin
+    if(rst)       reply_contents <= 136'd0;
     else if(resp_active)    reply_contents <= { reply_contents[134:0], sd_cmd_input };
 end
 
-reg [6:0] resp_crc7;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               resp_crc7 <= 7'd0;
+always @(posedge clk) begin
+    if(rst)                                               resp_crc7 <= 7'd0;
     else if(resp_active && resp_cnt >= 8'd9 && resp_cnt <= 8'd128)  resp_crc7 <= { sd_cmd_input ^ resp_crc7[0], resp_crc7[6:5], resp_crc7[4] ^ sd_cmd_input ^ resp_crc7[0], resp_crc7[3:1] };
     else if(resp_active)                                            resp_crc7 <= { 1'b0, resp_crc7[6:1] };
 end
 
 //------------------------------------------------------------------------------
 
-reg resp_next_is_trans_bit;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       resp_next_is_trans_bit <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                       resp_next_is_trans_bit <= 1'b0;
     else if(resp_active && resp_awaiting)   resp_next_is_trans_bit <= 1'b1;
     else if(resp_active)                    resp_next_is_trans_bit <= 1'b0;
 end
 
-wire resp_now_in_error = resp_active && (
+ assign resp_now_in_error = resp_active && (
     (resp_next_is_trans_bit && sd_cmd_input == 1'b1) ||                                     //transmission bit is '1'
     (resp_cnt == 8'd1 && sd_cmd_input == 1'b0) ||                                           //end bit is '0'
     (resp_cnt <= 8'd8 && resp_cnt >= 8'd2 && resp_has_crc7 && sd_cmd_input != resp_crc7[0]) //crc7 invalid
 );
 
-reg resp_had_error;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           resp_had_error <= 1'b0;
+always @(posedge clk) begin
+    if(rst)           resp_had_error <= 1'b0;
     else if(reply_error)        resp_had_error <= 1'b0;
     else if(resp_now_in_error)  resp_had_error <= 1'b1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   reply_ready <= 1'b0;
+always @(posedge clk) begin
+    if(rst)   reply_ready <= 1'b0;
     else                reply_ready <= (sd_clk_is_one && cmd_cnt == 6'd1 && resp_cnt == 8'd0) || (resp_active && resp_cnt == 8'd1 && ~(resp_now_in_error || resp_had_error));
 end
 
 //------------------------------------------------------------------------------
 
-wire error_start = (sd_clk_is_one && cmd_cnt == 6'd1 && resp_cnt > 8'd0) || (resp_active && resp_cnt == 8'd1 && (resp_now_in_error || resp_had_error));
+ assign error_start = (sd_clk_is_one && cmd_cnt == 6'd1 && resp_cnt > 8'd0) || (resp_active && resp_cnt == 8'd1 && (resp_now_in_error || resp_had_error));
 
-reg [6:0] error_delay_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               error_delay_cnt <= 7'd0;
+always @(posedge clk) begin
+    if(rst)                                               error_delay_cnt <= 7'd0;
     else if(sd_clk_is_one && resp_awaiting && sd_cmd_input == 1'b0) error_delay_cnt <= 7'd0;
     else if(error_start)                                            error_delay_cnt <= 7'd1;
     else if(sd_clk_is_one && error_delay_cnt > 7'd0)                error_delay_cnt <= error_delay_cnt + 7'd1;
diff --git a/rtl/soc/driver_sd/dat.v b/rtl/soc/driver_sd/dat.v
index 9d79929..6b321e1 100644
--- a/rtl/soc/driver_sd/dat.v
+++ b/rtl/soc/driver_sd/dat.v
@@ -7,7 +7,7 @@
 
 module dat(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //
     input               sd_clk_is_one,
@@ -36,26 +36,60 @@ module dat(
 );
 
 //------------------------------------------------------------------------------
+reg sd_dat_enable;
+reg [3:0] sd_dat_output;
+reg [3:0] sd_dat_input;
+reg [1:0] wr_start_delay_cnt;
+reg wr_missed;
+reg [10:0] wr_cnt;
+reg wr_resp_awaiting;
+reg [2:0] wr_resp_cnt;
+reg wr_in_progress;
+reg [26:0] wr_error_cnt;
+reg [7:0] wr_val_0;
+reg [7:0] wr_val_1;
+reg [7:0] wr_val_2;
+reg [7:0] wr_val_3;
+reg [15:0] wr_crc_0;
+reg [15:0] wr_crc_1;
+reg [15:0] wr_crc_2;
+reg [15:0] wr_crc_3;
+reg rd_async_in_progress;
+reg rd_awaiting;
+reg [10:0] rd_cnt;
+reg [26:0] rd_error_cnt;
+reg [27:0] rd_val;
+reg [15:0] rd_0;
+reg [15:0] rd_1;
+reg [15:0] rd_2;
+reg [15:0] rd_3;
+wire wr_start;
+wire wr_load;
+wire wr_resp_start;
+wire wr_in_progress_end;
+wire wr_resp_now_in_error;
+wire rd_start;
+wire rd_start_block;
+wire rd_active;
+wire rd_load;
+wire rd_now_in_error;
 //------------------------------------------------------------------------------
 //------------------------------------------------------------------------------
 
-reg sd_dat_enable;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       sd_dat_enable <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       sd_dat_enable <= 1'b0;
     else if(sd_clk_is_one)  sd_dat_enable <= wr_start || wr_cnt > 11'd0;
 end
 
-reg [3:0] sd_dat_output;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       sd_dat_output <= 4'hF;
+always @(posedge clk) begin
+    if(rst)       sd_dat_output <= 4'hF;
     else if(sd_clk_is_one)  sd_dat_output <= (wr_start)? 4'h0 : (wr_cnt <= 11'd17 && wr_cnt >= 11'd2)? { wr_crc_3[0], wr_crc_2[0], wr_crc_1[0], wr_crc_0[0] } : { wr_val_3[7], wr_val_2[7], wr_val_1[7], wr_val_0[7] };
 end
 
 assign sd_dat = (sd_dat_enable)? sd_dat_output : 4'bZ;
 
-reg [3:0] sd_dat_input;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           sd_dat_input <= 4'b1111;
+always @(posedge clk) begin
+    if(rst)           sd_dat_input <= 4'b1111;
     else if(~(sd_clk_is_one))   sd_dat_input <= sd_dat;
 end
 
@@ -73,89 +107,82 @@ output reg          wr_error,
 output reg          wr_finished,
 */
 
-reg [1:0] wr_start_delay_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                                   wr_start_delay_cnt <= 2'd2;
+always @(posedge clk) begin
+    if(rst)                                                                                                   wr_start_delay_cnt <= 2'd2;
     else if(sd_clk_is_one && wr_async_data_ready && wr_cnt == 11'd0 && ~(wr_in_progress) && wr_start_delay_cnt > 2'd0)  wr_start_delay_cnt <= wr_start_delay_cnt - 2'd1;
     else if(wr_cnt > 11'd0)                                                                                             wr_start_delay_cnt <= 2'd2;
 end
 
-wire wr_start = sd_clk_is_one && wr_async_data_ready && wr_cnt == 11'd0 && ~(wr_in_progress) && wr_start_delay_cnt == 2'd0;
-wire wr_load  = wr_start || (sd_clk_is_one && wr_async_data_ready && wr_cnt >= 11'd26 && wr_cnt[2:0] == 3'b010) || (wr_missed && wr_async_data_ready);
+ assign wr_start = sd_clk_is_one && wr_async_data_ready && wr_cnt == 11'd0 && ~(wr_in_progress) && wr_start_delay_cnt == 2'd0;
+ assign wr_load = wr_start || (sd_clk_is_one && wr_async_data_ready && wr_cnt >= 11'd26 && wr_cnt[2:0] == 3'b010) || (wr_missed && wr_async_data_ready);
 
-reg wr_missed;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                               wr_missed <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                                               wr_missed <= 1'b0;
     else if(sd_clk_is_one && ~(wr_async_data_ready) && wr_cnt >= 11'd26 && wr_cnt[2:0] == 3'b010)   wr_missed <= 1'b1;
     else if(wr_async_data_ready)                                                                    wr_missed <= 1'b0;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_data_done <= 1'b0;
+always @(posedge clk) begin
+    if(rst)   wr_data_done <= 1'b0;
     else                wr_data_done <= wr_load;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_data_last_in_sector <= 1'b0;
+always @(posedge clk) begin
+    if(rst)   wr_data_last_in_sector <= 1'b0;
     else                wr_data_last_in_sector <= wr_load && (wr_cnt == 11'd26 || wr_cnt == 11'd25);
 end
 
-reg [10:0] wr_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           wr_cnt <= 11'd0;
+always @(posedge clk) begin
+    if(rst)                           wr_cnt <= 11'd0;
     else if(wr_start)                           wr_cnt <= 11'd1041;
     else if(sd_clk_is_one && wr_cnt > 11'd0)    wr_cnt <= wr_cnt - 11'd1;
 end
 
-wire wr_resp_start = sd_clk_is_one && wr_cnt == 11'd1;
+ assign wr_resp_start = sd_clk_is_one && wr_cnt == 11'd1;
 
-reg wr_resp_awaiting;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       wr_resp_awaiting <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                       wr_resp_awaiting <= 1'b0;
     else if(wr_resp_start)                                                  wr_resp_awaiting <= 1'b1;
     else if(sd_clk_is_one && wr_resp_awaiting && sd_dat_input[0] == 1'b0)   wr_resp_awaiting <= 1'b0;
 end
 
-reg [2:0] wr_resp_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       wr_resp_cnt <= 3'd0;
+always @(posedge clk) begin
+    if(rst)                                                       wr_resp_cnt <= 3'd0;
     else if(sd_clk_is_one && wr_resp_awaiting && sd_dat_input[0] == 1'b0)   wr_resp_cnt <= 3'd4;
     else if(sd_clk_is_one && wr_resp_cnt > 3'd0)                            wr_resp_cnt <= wr_resp_cnt - 3'd1;
 end
 
-wire wr_in_progress_end = wr_in_progress && ((sd_clk_is_one && wr_error_cnt == 27'h7FFFFFF) || (sd_clk_is_one && wr_cnt == 11'd0 && ~(wr_resp_awaiting) && wr_resp_cnt == 3'd0 && sd_dat_input[0] == 1'b1));
+ assign wr_in_progress_end = wr_in_progress && ((sd_clk_is_one && wr_error_cnt == 27'h7FFFFFF) || (sd_clk_is_one && wr_cnt == 11'd0 && ~(wr_resp_awaiting) && wr_resp_cnt == 3'd0 && sd_dat_input[0] == 1'b1));
 
-reg wr_in_progress;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               wr_in_progress <= 1'b0;
+always @(posedge clk) begin
+    if(rst)               wr_in_progress <= 1'b0;
     else if(wr_start)               wr_in_progress <= 1'b1;
     else if(wr_in_progress_end)     wr_in_progress <= 1'b0;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   wr_finished_sector <= 1'b0;
+always @(posedge clk) begin
+    if(rst)   wr_finished_sector <= 1'b0;
     else                wr_finished_sector <= wr_in_progress_end;
 end
 
 //------------------------------------------------------------------------------
 
-wire wr_resp_now_in_error = sd_clk_is_one && (
+ assign wr_resp_now_in_error = sd_clk_is_one && (
     (wr_resp_cnt == 3'd4 && sd_dat_input[0] == 1'b1) || //crc status invalid
     (wr_resp_cnt == 3'd3 && sd_dat_input[0] == 1'b0) || //crc status invalid
     (wr_resp_cnt == 3'd2 && sd_dat_input[0] == 1'b1) || //crc status invalid
     (wr_resp_cnt == 3'd1 && sd_dat_input[0] == 1'b0)    //end bit is '0'
 );
 
-reg [26:0] wr_error_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               wr_error_cnt <= 27'd0;
+always @(posedge clk) begin
+    if(rst)                               wr_error_cnt <= 27'd0;
     else if(~(wr_in_progress))                      wr_error_cnt <= 27'd0;
     else if(wr_resp_start)                          wr_error_cnt <= 27'd1;
     else if(sd_clk_is_one && wr_error_cnt > 27'd0)  wr_error_cnt <= wr_error_cnt + 27'd1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       wr_error <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                       wr_error <= 1'b0;
     else if(wr_start)                                       wr_error <= 1'b0;
     else if(wr_resp_now_in_error)                           wr_error <= 1'b1;
     else if(sd_clk_is_one && wr_error_cnt == 27'h7FFFFFF)   wr_error <= 1'b1;
@@ -163,58 +190,50 @@ end
 
 //------------------------------------------------------------------------------
 
-reg [7:0] wr_val_0;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       wr_val_0 <= 8'd0;
+always @(posedge clk) begin
+    if(rst)       wr_val_0 <= 8'd0;
     else if(wr_load)        wr_val_0 <= { wr_async_data[4], wr_async_data[0], wr_async_data[12], wr_async_data[8], wr_async_data[20], wr_async_data[16], wr_async_data[28], wr_async_data[24] };
     else if(sd_clk_is_one)  wr_val_0 <= { wr_val_0[6:0], 1'b1 }; //fill with 1 important
 end
 
-reg [7:0] wr_val_1;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       wr_val_1 <= 8'd0;
+always @(posedge clk) begin
+    if(rst)       wr_val_1 <= 8'd0;
     else if(wr_load)        wr_val_1 <= { wr_async_data[5], wr_async_data[1], wr_async_data[13], wr_async_data[9], wr_async_data[21], wr_async_data[17], wr_async_data[29], wr_async_data[25] };
     else if(sd_clk_is_one)  wr_val_1 <= { wr_val_1[6:0], 1'b1 }; //fill with 1 important
 end
 
-reg [7:0] wr_val_2;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       wr_val_2 <= 8'd0;
+always @(posedge clk) begin
+    if(rst)       wr_val_2 <= 8'd0;
     else if(wr_load)        wr_val_2 <= { wr_async_data[6], wr_async_data[2], wr_async_data[14], wr_async_data[10], wr_async_data[22], wr_async_data[18], wr_async_data[30], wr_async_data[26] };
     else if(sd_clk_is_one)  wr_val_2 <= { wr_val_2[6:0], 1'b1 }; //fill with 1 important
 end
 
-reg [7:0] wr_val_3;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       wr_val_3 <= 8'd0;
+always @(posedge clk) begin
+    if(rst)       wr_val_3 <= 8'd0;
     else if(wr_load)        wr_val_3 <= { wr_async_data[7], wr_async_data[3], wr_async_data[15], wr_async_data[11], wr_async_data[23], wr_async_data[19], wr_async_data[31], wr_async_data[27] };
     else if(sd_clk_is_one)  wr_val_3 <= { wr_val_3[6:0], 1'b1 }; //fill with 1 important
 end
 
-reg [15:0] wr_crc_0;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           wr_crc_0 <= 16'd0;
+always @(posedge clk) begin
+    if(rst)                           wr_crc_0 <= 16'd0;
     else if(sd_clk_is_one && wr_cnt >= 11'd18)  wr_crc_0 <= { wr_val_0[7] ^ wr_crc_0[0], wr_crc_0[15:12], wr_crc_0[11] ^ wr_val_0[7] ^ wr_crc_0[0], wr_crc_0[10:5], wr_crc_0[4] ^ wr_val_0[7] ^ wr_crc_0[0], wr_crc_0[3:1] };
     else if(sd_clk_is_one)                      wr_crc_0 <= { 1'b0, wr_crc_0[15:1] }; //fill with 0 important
 end
 
-reg [15:0] wr_crc_1;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           wr_crc_1 <= 16'd0;
+always @(posedge clk) begin
+    if(rst)                           wr_crc_1 <= 16'd0;
     else if(sd_clk_is_one && wr_cnt >= 11'd18)  wr_crc_1 <= { wr_val_1[7] ^ wr_crc_1[0], wr_crc_1[15:12], wr_crc_1[11] ^ wr_val_1[7] ^ wr_crc_1[0], wr_crc_1[10:5], wr_crc_1[4] ^ wr_val_1[7] ^ wr_crc_1[0], wr_crc_1[3:1] };
     else if(sd_clk_is_one)                      wr_crc_1 <= { 1'b0, wr_crc_1[15:1] }; //fill with 0 important
 end
 
-reg [15:0] wr_crc_2;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           wr_crc_2 <= 16'd0;
+always @(posedge clk) begin
+    if(rst)                           wr_crc_2 <= 16'd0;
     else if(sd_clk_is_one && wr_cnt >= 11'd18)  wr_crc_2 <= { wr_val_2[7] ^ wr_crc_2[0], wr_crc_2[15:12], wr_crc_2[11] ^ wr_val_2[7] ^ wr_crc_2[0], wr_crc_2[10:5], wr_crc_2[4] ^ wr_val_2[7] ^ wr_crc_2[0], wr_crc_2[3:1] };
     else if(sd_clk_is_one)                      wr_crc_2 <= { 1'b0, wr_crc_2[15:1] }; //fill with 0 important
 end
 
-reg [15:0] wr_crc_3;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           wr_crc_3 <= 16'd0;
+always @(posedge clk) begin
+    if(rst)                           wr_crc_3 <= 16'd0;
     else if(sd_clk_is_one && wr_cnt >= 11'd18)  wr_crc_3 <= { wr_val_3[7] ^ wr_crc_3[0], wr_crc_3[15:12], wr_crc_3[11] ^ wr_val_3[7] ^ wr_crc_3[0], wr_crc_3[10:5], wr_crc_3[4] ^ wr_val_3[7] ^ wr_crc_3[0], wr_crc_3[3:1] };
     else if(sd_clk_is_one)                      wr_crc_3 <= { 1'b0, wr_crc_3[15:1] }; //fill with 0 important
 end
@@ -232,67 +251,63 @@ output reg  [31:0]  rd_data,
 output reg          rd_error,
 */
 
-wire rd_start       = sd_clk_is_one && rd_async_in_progress && ~(rd_now_in_error) && ~(rd_error) && ~(rd_awaiting) && rd_cnt <= 11'd1;
-wire rd_start_block = sd_clk_is_one && rd_awaiting && sd_dat_input == 4'h0;
-wire rd_active      = sd_clk_is_one && rd_cnt > 11'd0;
-wire rd_load        = sd_clk_is_one && rd_cnt >= 11'd18 && rd_cnt[2:0] == 3'b010 && ~(rd_async_abort);
+ assign rd_start = sd_clk_is_one && rd_async_in_progress && ~(rd_now_in_error) && ~(rd_error) && ~(rd_awaiting) && rd_cnt <= 11'd1;
+ assign rd_start_block = sd_clk_is_one && rd_awaiting && sd_dat_input == 4'h0;
+ assign rd_active = sd_clk_is_one && rd_cnt > 11'd0;
+ assign rd_load = sd_clk_is_one && rd_cnt >= 11'd18 && rd_cnt[2:0] == 3'b010 && ~(rd_async_abort);
 
-reg rd_async_in_progress;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       rd_async_in_progress <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       rd_async_in_progress <= 1'b0;
     else if(rd_async_abort) rd_async_in_progress <= 1'b0;
     else if(rd_async_start) rd_async_in_progress <= 1'b1;
 end
 
-reg rd_awaiting;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       rd_awaiting <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       rd_awaiting <= 1'b0;
     else if(rd_async_abort) rd_awaiting <= 1'b0;
     else if(rd_start)       rd_awaiting <= 1'b1;
     else if(rd_start_block) rd_awaiting <= 1'b0;
 end
 
-reg [10:0] rd_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       rd_cnt <= 11'd0;
+always @(posedge clk) begin
+    if(rst)       rd_cnt <= 11'd0;
     else if(rd_async_abort) rd_cnt <= 11'd0;
     else if(rd_start_block) rd_cnt <= 11'd1041;
     else if(rd_active)      rd_cnt <= rd_cnt - 11'd1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       rd_data_done <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       rd_data_done <= 1'b0;
     else                    rd_data_done <= rd_load;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       rd_data_last_in_sector <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       rd_data_last_in_sector <= 1'b0;
     else                    rd_data_last_in_sector <= rd_load && rd_cnt == 11'd18;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       rd_data <= 32'b0;
+always @(posedge clk) begin
+    if(rst)       rd_data <= 32'b0;
     else if(rd_load)        rd_data <= { rd_val[3:0], sd_dat_input, rd_val[11:4], rd_val[19:12], rd_val[27:20] };
 end
 
 //------------------------------------------------------------------------------
 
-reg [26:0] rd_error_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               rd_error_cnt <= 27'd0;
+always @(posedge clk) begin
+    if(rst)                               rd_error_cnt <= 27'd0;
     else if(rd_async_abort)                         rd_error_cnt <= 27'd0;
     else if(rd_start_block)                         rd_error_cnt <= 27'd0;
     else if(rd_start)                               rd_error_cnt <= 27'd1;
     else if(sd_clk_is_one && rd_error_cnt > 27'd0)  rd_error_cnt <= rd_error_cnt + 27'd1;
 end
 
-wire rd_now_in_error = rd_active && (
+ assign rd_now_in_error = rd_active && (
     (rd_cnt == 11'd1 && sd_dat_input != 4'hF) ||                                                    //end bit is '0'
     (rd_cnt <= 11'd17 && rd_cnt >= 11'd2 && sd_dat_input != { rd_3[0], rd_2[0], rd_1[0], rd_0[0] }) //crc16 invalid
 );
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       rd_error <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                       rd_error <= 1'b0;
     else if(rd_async_abort)                                 rd_error <= 1'b0;
     else if(rd_now_in_error)                                rd_error <= 1'b1;
     else if(sd_clk_is_one && rd_error_cnt == 27'h7FFFFFF)   rd_error <= 1'b1;
@@ -300,36 +315,31 @@ end
 
 //------------------------------------------------------------------------------
 
-reg [27:0] rd_val;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   rd_val <= 28'd0;
+always @(posedge clk) begin
+    if(rst)   rd_val <= 28'd0;
     else if(rd_active)  rd_val <= { rd_val[23:0], sd_dat_input };
 end
 
-reg [15:0] rd_0;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           rd_0 <= 16'd0;
+always @(posedge clk) begin
+    if(rst)                           rd_0 <= 16'd0;
     else if(sd_clk_is_one && rd_cnt >= 11'd18)  rd_0 <= { sd_dat_input[0] ^ rd_0[0], rd_0[15:12], rd_0[11] ^ sd_dat_input[0] ^ rd_0[0], rd_0[10:5], rd_0[4] ^ sd_dat_input[0] ^ rd_0[0], rd_0[3:1] };
     else if(sd_clk_is_one)                      rd_0 <= { 1'b0, rd_0[15:1] }; //fill with 0 important
 end
 
-reg [15:0] rd_1;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           rd_1 <= 16'd0;
+always @(posedge clk) begin
+    if(rst)                           rd_1 <= 16'd0;
     else if(sd_clk_is_one && rd_cnt >= 11'd18)  rd_1 <= { sd_dat_input[1] ^ rd_1[0], rd_1[15:12], rd_1[11] ^ sd_dat_input[1] ^ rd_1[0], rd_1[10:5], rd_1[4] ^ sd_dat_input[1] ^ rd_1[0], rd_1[3:1] };
     else if(sd_clk_is_one)                      rd_1 <= { 1'b0, rd_1[15:1] }; //fill with 0 important
 end
 
-reg [15:0] rd_2;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           rd_2 <= 16'd0;
+always @(posedge clk) begin
+    if(rst)                           rd_2 <= 16'd0;
     else if(sd_clk_is_one && rd_cnt >= 11'd18)  rd_2 <= { sd_dat_input[2] ^ rd_2[0], rd_2[15:12], rd_2[11] ^ sd_dat_input[2] ^ rd_2[0], rd_2[10:5], rd_2[4] ^ sd_dat_input[2] ^ rd_2[0], rd_2[3:1] };
     else if(sd_clk_is_one)                      rd_2 <= { 1'b0, rd_2[15:1] }; //fill with 0 important
 end
 
-reg [15:0] rd_3;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           rd_3 <= 16'd0;
+always @(posedge clk) begin
+    if(rst)                           rd_3 <= 16'd0;
     else if(sd_clk_is_one && rd_cnt >= 11'd18)  rd_3 <= { sd_dat_input[3] ^ rd_3[0], rd_3[15:12], rd_3[11] ^ sd_dat_input[3] ^ rd_3[0], rd_3[10:5], rd_3[4] ^ sd_dat_input[3] ^ rd_3[0], rd_3[3:1] };
     else if(sd_clk_is_one)                      rd_3 <= { 1'b0, rd_3[15:1] }; //fill with 0 important
 end
diff --git a/rtl/soc/driver_sd/driver_sd.v b/rtl/soc/driver_sd/driver_sd.v
index b6712c0..4f3d931 100644
--- a/rtl/soc/driver_sd/driver_sd.v
+++ b/rtl/soc/driver_sd/driver_sd.v
@@ -7,7 +7,7 @@
 
 module driver_sd(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //
     input       [1:0]   avs_address,
@@ -33,29 +33,81 @@ module driver_sd(
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               sd_clk <= 1'b0;
-    else if(write_stop_sd_clk || read_stop_sd_clk)  sd_clk <= 1'b0;
-    else                                            sd_clk <= ~(sd_clk);
-end
-
-//------------------------------------------------------------------------------
-
 wire current_dat0;
-
 wire wr_data_done;
 wire wr_data_last_in_sector;
 wire wr_error;
 wire wr_finished_sector;
-
 wire        rd_data_done;
 wire        rd_data_last_in_sector;
 wire [31:0] rd_data;
 wire        rd_error;
+wire         reply_ready;
+wire [135:0] reply_contents;
+wire         reply_error;
+wire cmd_ready;
+wire [5:0] cmd_index ;
+wire [31:0] cmd_arg ;
+wire [7:0] cmd_resp_length ;
+wire cmd_resp_has_crc7;
+wire [31:0] read_data;
+wire        read_done;
+wire        write_done;
+wire operation_write;
+wire operation_read;
+wire operation_init;
+wire operation_sector_last;
+wire [31:0] sd_address;
+wire [31:0] avalon_address_base;
+wire operation_sector_update;
+wire operation_finished_ok;
+wire operation_finished_with_error;
+wire init_operation_finished_ok;
+wire init_operation_finished_with_error;
+wire        init_cmd_ready;
+wire [5:0]  init_cmd_index;
+wire [31:0] init_cmd_arg;
+wire [7:0]  init_cmd_resp_length;
+wire        init_cmd_resp_has_crc7;
+wire read_operation_sector_update;
+wire read_operation_finished_ok;
+wire read_operation_finished_with_error;
+wire rd_async_start;
+wire rd_async_abort;
+wire read_stop_sd_clk;
+wire        read_cmd_ready;
+wire [5:0]  read_cmd_index;
+wire [31:0] read_cmd_arg;
+wire [7:0]  read_cmd_resp_length;
+wire        read_cmd_resp_has_crc7;
+wire        write_start;
+wire        write_next;
+wire [31:0] write_data;
+wire write_operation_sector_update;
+wire write_operation_finished_ok;
+wire write_operation_finished_with_error;
+wire read_start;
+wire read_next;
+wire write_stop_sd_clk;
+wire        write_cmd_ready;
+wire [5:0]  write_cmd_index;
+wire [31:0] write_cmd_arg;
+wire [7:0]  write_cmd_resp_length;
+wire        write_cmd_resp_has_crc7;
+wire        wr_async_data_ready;
+wire [31:0] wr_async_data;
+   
+always @(posedge clk) begin
+    if(rst)                               sd_clk <= 1'b0;
+    else if(write_stop_sd_clk || read_stop_sd_clk)  sd_clk <= 1'b0;
+    else                                            sd_clk <= ~(sd_clk);
+end
+
+//------------------------------------------------------------------------------
 
 dat dat_inst(
     .clk                    (clk),
-    .rst_n                  (rst_n),
+    .rst                  (rst),
     
     //
     .sd_clk_is_one          (sd_clk),                   //input
@@ -85,19 +137,16 @@ dat dat_inst(
 
 //------------------------------------------------------------------------------
 
-wire         reply_ready;
-wire [135:0] reply_contents;
-wire         reply_error;
 
-wire        cmd_ready         = (operation_write)? write_cmd_ready         : (operation_read)? read_cmd_ready         : (operation_init)? init_cmd_ready         : 1'b0;
-wire [5:0]  cmd_index         = (operation_write)? write_cmd_index         : (operation_read)? read_cmd_index         : (operation_init)? init_cmd_index         : 6'b0;
-wire [31:0] cmd_arg           = (operation_write)? write_cmd_arg           : (operation_read)? read_cmd_arg           : (operation_init)? init_cmd_arg           : 32'b0;
-wire [7:0]  cmd_resp_length   = (operation_write)? write_cmd_resp_length   : (operation_read)? read_cmd_resp_length   : (operation_init)? init_cmd_resp_length   : 8'b0;
-wire        cmd_resp_has_crc7 = (operation_write)? write_cmd_resp_has_crc7 : (operation_read)? read_cmd_resp_has_crc7 : (operation_init)? init_cmd_resp_has_crc7 : 1'b0;
+ assign cmd_ready = (operation_write)? write_cmd_ready         : (operation_read)? read_cmd_ready         : (operation_init)? init_cmd_ready         : 1'b0;
+ assign cmd_index = (operation_write)? write_cmd_index         : (operation_read)? read_cmd_index         : (operation_init)? init_cmd_index         : 6'b0;
+ assign cmd_arg = (operation_write)? write_cmd_arg           : (operation_read)? read_cmd_arg           : (operation_init)? init_cmd_arg           : 32'b0;
+ assign cmd_resp_length = (operation_write)? write_cmd_resp_length   : (operation_read)? read_cmd_resp_length   : (operation_init)? init_cmd_resp_length   : 8'b0;
+ assign cmd_resp_has_crc7 = (operation_write)? write_cmd_resp_has_crc7 : (operation_read)? read_cmd_resp_has_crc7 : (operation_init)? init_cmd_resp_has_crc7 : 1'b0;
 
 cmd cmd_inst(
     .clk                (clk),
-    .rst_n              (rst_n),
+    .rst              (rst),
     
     //
     .sd_clk_is_one      (sd_clk),               //input
@@ -117,17 +166,11 @@ cmd cmd_inst(
     //
     .sd_cmd             (sd_cmd)                //inout
 );
-
 //------------------------------------------------------------------------------
 
-wire [31:0] read_data;
-wire        read_done;
-
-wire        write_done;
-
 avalon_master avalon_master_inst(
     .clk                    (clk),
-    .rst_n                  (rst_n),
+    .rst                  (rst),
     
     //
     .avm_address            (avm_address),          //output [31:0]
@@ -156,22 +199,13 @@ avalon_master avalon_master_inst(
 
 //------------------------------------------------------------------------------
 
-wire operation_write;
-wire operation_read;
-wire operation_init;
-
-wire operation_sector_last;
-
-wire [31:0] sd_address;
-wire [31:0] avalon_address_base;
-
-wire operation_sector_update       = (operation_write && write_operation_sector_update)       || (operation_read && read_operation_sector_update);
-wire operation_finished_ok         = (operation_write && write_operation_finished_ok)         || (operation_read && read_operation_finished_ok)         || (operation_init && init_operation_finished_ok);
-wire operation_finished_with_error = (operation_write && write_operation_finished_with_error) || (operation_read && read_operation_finished_with_error) || (operation_init && init_operation_finished_with_error);
+ assign operation_sector_update = (operation_write && write_operation_sector_update)       || (operation_read && read_operation_sector_update);
+ assign operation_finished_ok = (operation_write && write_operation_finished_ok)         || (operation_read && read_operation_finished_ok)         || (operation_init && init_operation_finished_ok);
+ assign operation_finished_with_error = (operation_write && write_operation_finished_with_error) || (operation_read && read_operation_finished_with_error) || (operation_init && init_operation_finished_with_error);
 
 avalon_slave avalon_slave_inst(
     .clk                            (clk),
-    .rst_n                          (rst_n),
+    .rst                          (rst),
     
     //
     .avs_address                    (avs_address),                      //input [1:0]
@@ -196,20 +230,14 @@ avalon_slave avalon_slave_inst(
     .avalon_address_base            (avalon_address_base)               //output [31:0]
 );
 
+   
+   
 //------------------------------------------------------------------------------
 
-wire init_operation_finished_ok;
-wire init_operation_finished_with_error;
-
-wire        init_cmd_ready;
-wire [5:0]  init_cmd_index;
-wire [31:0] init_cmd_arg;
-wire [7:0]  init_cmd_resp_length;
-wire        init_cmd_resp_has_crc7;
 
 card_init card_init_inst(
     .clk                            (clk),
-    .rst_n                          (rst_n),
+    .rst                          (rst),
     
     //
     .operation_init                 (operation_init),                       //input
@@ -233,28 +261,9 @@ card_init card_init_inst(
 
 //------------------------------------------------------------------------------
 
-wire read_operation_sector_update;
-wire read_operation_finished_ok;
-wire read_operation_finished_with_error;
-
-wire rd_async_start;
-wire rd_async_abort;
-
-wire read_stop_sd_clk;
-
-wire        read_cmd_ready;
-wire [5:0]  read_cmd_index;
-wire [31:0] read_cmd_arg;
-wire [7:0]  read_cmd_resp_length;
-wire        read_cmd_resp_has_crc7;
-
-wire        write_start;
-wire        write_next;
-wire [31:0] write_data;
-
 card_read card_read_inst(
     .clk                            (clk),
-    .rst_n                          (rst_n),
+    .rst                          (rst),
     
     //
     .operation_read                 (operation_read),                       //input
@@ -302,27 +311,9 @@ card_read card_read_inst(
 
 //------------------------------------------------------------------------------
 
-wire write_operation_sector_update;
-wire write_operation_finished_ok;
-wire write_operation_finished_with_error;
-
-wire read_start;
-wire read_next;
-
-wire write_stop_sd_clk;
-
-wire        write_cmd_ready;
-wire [5:0]  write_cmd_index;
-wire [31:0] write_cmd_arg;
-wire [7:0]  write_cmd_resp_length;
-wire        write_cmd_resp_has_crc7;
-
-wire        wr_async_data_ready;
-wire [31:0] wr_async_data;
-
 card_write card_write_inst(
     .clk                            (clk),
-    .rst_n                          (rst_n),
+    .rst                          (rst),
     
     //
     .operation_write                (operation_write),                      //input
@@ -367,7 +358,6 @@ card_write card_write_inst(
     //
     .stop_sd_clk                    (write_stop_sd_clk)                     //output
 );
-
 //------------------------------------------------------------------------------
 
 endmodule
diff --git a/rtl/soc/floppy/floppy.v b/rtl/soc/floppy/floppy.v
index c6c8180..55c6e2c 100644
--- a/rtl/soc/floppy/floppy.v
+++ b/rtl/soc/floppy/floppy.v
@@ -1,17 +1,17 @@
 /*
  * Copyright (c) 2014, Aleksander Osman
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
- * 
+ *
  * * Redistributions of source code must retain the above copyright notice, this
  *   list of conditions and the following disclaimer.
- * 
+ *
  * * Redistributions in binary form must reproduce the above copyright notice,
  *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
@@ -26,83 +26,33 @@
 
 module floppy(
     input               clk,
-    input               rst_n,
-    
-    //dma
-    output              dma_floppy_req,
-    input               dma_floppy_ack,
-    input               dma_floppy_terminal,
-    input       [7:0]   dma_floppy_readdata,
-    output      [7:0]   dma_floppy_writedata,
-    
-    //irq
-    output reg          irq,
-    
+    input               rst,
+
     //avalon slave
     input       [2:0]   io_address,
     input               io_read,
     output reg  [7:0]   io_readdata,
     input               io_write,
     input       [7:0]   io_writedata,
-    
+
     //ide shared port 0x3F6
     output              ide_3f6_read,
     input       [7:0]   ide_3f6_readdata,
     output              ide_3f6_write,
-    output      [7:0]   ide_3f6_writedata,
-    
-    //master to control sd
-    output      [31:0]  sd_master_address,
-    input               sd_master_waitrequest,
-    output              sd_master_read,
-    input               sd_master_readdatavalid,
-    input       [31:0]  sd_master_readdata,
-    output              sd_master_write,
-    output      [31:0]  sd_master_writedata,
-    
-    //slave for sd
-    input       [8:0]   sd_slave_address,
-    input               sd_slave_read,
-    output reg  [7:0]   sd_slave_readdata,
-    input               sd_slave_write,
-    input       [7:0]   sd_slave_writedata,
-    
-    //slave for management
-    /*
-     0x00.[0]:      media present
-     0x01.[0]:      media writeprotect
-     0x02.[7:0]:    media cylinders
-     0x03.[7:0]:    media sectors per track
-     0x04.[31:0]:   media total sector count
-     0x05.[1:0]:    media heads
-     0x06.[31:0]:   media sd base
-     0x07.[15:0]:   media wait cycles: 200000 us / spt
-     0x08.[15:0]:   media wait rate 0: 1000 us
-     0x09.[15:0]:   media wait rate 1: 1666 us
-     0x0A.[15:0]:   media wait rate 2: 2000 us
-     0x0B.[15:0]:   media wait rate 3: 500 us
-     0x0C.[7:0]:    media type: 8'h20 none; 8'h00 old; 8'hC0 720k; 8'h80 1_44M; 8'h40 2_88M
-    */
-    input       [3:0]   mgmt_address,
-    input               mgmt_write,
-    input       [31:0]  mgmt_writedata
+    output      [7:0]   ide_3f6_writedata
 );
 
 //------------------------------------------------------------------------------
 
-`define SD_AVALON_BASE_ADDRESS_FOR_FDD 32'h00000800
+reg io_read_last;
+wire _unused_ok;
 
 //TODO: in execute_ndma -- send irq after every byte
 
 //------------------------------------------------------------------------------
 
-reg io_read_last;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) io_read_last <= 1'b0; else if(io_read_last) io_read_last <= 1'b0; else io_read_last <= io_read; end 
-wire io_read_valid = io_read && io_read_last == 1'b0;
-
-reg sd_slave_read_last;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) sd_slave_read_last <= 1'b0; else if(sd_slave_read_last) sd_slave_read_last <= 1'b0; else sd_slave_read_last <= sd_slave_read; end 
-wire sd_slave_read_valid = sd_slave_read && sd_slave_read_last == 1'b0;
+always @(posedge clk) begin if(rst) io_read_last <= 1'b0; else if(io_read_last) io_read_last <= 1'b0; else io_read_last <= io_read; end
+ assign io_read_valid = io_read/* && io_read_last == 1'b0*/;
 
 //------------------------------------------------------------------------------ ide shared ports
 
@@ -110,886 +60,10 @@ assign ide_3f6_read      = io_read_valid && io_address == 3'd6;
 assign ide_3f6_write     = io_write && io_address == 3'd6;
 assign ide_3f6_writedata = io_writedata;
 
-//------------------------------------------------------------------------------ io read
-
-wire read_in_io_mode  = io_read_valid && io_address == 3'd5 && execute_ndma && cmd_read_normal_in_progress;
-
-wire write_in_io_mode = io_write && io_address == 3'h5 && execute_ndma && (cmd_write_normal_in_progress || cmd_format_in_progress);
-
-wire [7:0] io_readdata_prepare =
-    (io_address == 3'd2)?   { 3'b0, motor_enable, dma_irq_enable, enable, selected_drive } :        //digital output register
-    (io_address == 3'd3)?   media_type :                                                            //tape drive register
-    (io_address == 3'd4)?   { datareg_ready, transfer_to_cpu, execute_ndma, busy, in_seek_mode } :  //main status reg
-    (read_in_io_mode)?      from_floppy_q :
-    (io_address == 3'd5)?   reply[7:0] :
-    (io_address == 3'd6)?   ide_3f6_readdata :
-    (io_address == 3'd7)?   { change, 7'h7F } :
-                            8'd0;
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   io_readdata <= 8'd0;
-    else                io_readdata <= io_readdata_prepare;
-end
-
-//------------------------------------------------------------------------------ media management
-
-reg media_present;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_present <= 1'b0;
-    else if(mgmt_write && mgmt_address == 4'd0) media_present <= mgmt_writedata[0];
-end
-
-reg media_writeprotected;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_writeprotected <= 1'b0;
-    else if(mgmt_write && mgmt_address == 4'd1) media_writeprotected <= mgmt_writedata[0];
-end
-
-reg [7:0] media_cylinders;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_cylinders <= 8'd0;
-    else if(mgmt_write && mgmt_address == 4'd2) media_cylinders <= mgmt_writedata[7:0];
-end
-
-reg [7:0] media_sectors_per_track;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_sectors_per_track <= 8'd0;
-    else if(mgmt_write && mgmt_address == 4'd3) media_sectors_per_track <= mgmt_writedata[7:0];
-end
-
-reg [31:0] media_sector_count;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_sector_count <= 32'd0;
-    else if(mgmt_write && mgmt_address == 4'd4) media_sector_count <= mgmt_writedata;
-end
-
-reg [1:0] media_heads;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_heads <= 2'd2;
-    else if(mgmt_write && mgmt_address == 4'd5) media_heads <= mgmt_writedata[1:0];
-end
-
-reg [31:0] media_sd_base;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_sd_base <= 32'd0;
-    else if(mgmt_write && mgmt_address == 4'd6) media_sd_base <= mgmt_writedata;
-end
-
-reg [15:0] media_wait_cycles;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_wait_cycles <= 16'd0;
-    else if(mgmt_write && mgmt_address == 4'd7) media_wait_cycles <= mgmt_writedata[15:0];
-end
-
-reg [15:0] media_wait_rate_0;
-reg [15:0] media_wait_rate_1;
-reg [15:0] media_wait_rate_2;
-reg [15:0] media_wait_rate_3;
-
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) media_wait_rate_0 <= 16'd1000; else if(mgmt_write && mgmt_address == 4'h8) media_wait_rate_0 <= mgmt_writedata[15:0]; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) media_wait_rate_1 <= 16'd1666; else if(mgmt_write && mgmt_address == 4'h9) media_wait_rate_1 <= mgmt_writedata[15:0]; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) media_wait_rate_2 <= 16'd2000; else if(mgmt_write && mgmt_address == 4'hA) media_wait_rate_2 <= mgmt_writedata[15:0]; end
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) media_wait_rate_3 <= 16'd500;  else if(mgmt_write && mgmt_address == 4'hB) media_wait_rate_3 <= mgmt_writedata[15:0]; end
-
-reg [7:0] media_type;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_type <= 8'h20;
-    else if(mgmt_write && mgmt_address == 4'hC) media_type <= mgmt_writedata[7:0];
-end
-
-//------------------------------------------------------------------------------
-
-wire sw_reset = 
-    (io_write && io_address == 3'h2 && io_writedata[2] == 1'b0 && enable) ||
-    (io_write && io_address == 3'h4 && io_writedata[7]);
-
-reg [1:0] selected_drive;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           selected_drive <= 2'd0;
-    else if(io_write && io_address == 3'h2)     selected_drive <= io_writedata[1:0];
-    else if(cmd_recalibrate_start)              selected_drive <= io_writedata[1:0];
-    else if(cmd_seek_start)                     selected_drive <= command[1:0];
-    else if(cmd_read_id_start)                  selected_drive <= io_writedata[1:0];
-    else if(cmd_format_track_start)             selected_drive <= command[25:24];
-    else if(cmd_read_write_start)               selected_drive <= command[49:48];
-end
-
-reg motor_enable;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           motor_enable <= 1'b0;
-    else if(io_write && io_address == 3'h2)     motor_enable <= io_writedata[4];
-end
-
-reg dma_irq_enable;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           dma_irq_enable <= 1'b1;
-    else if(io_write && io_address == 3'h2)     dma_irq_enable <= io_writedata[3];
-end
-
-reg enable;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           enable <= 1'b1;
-    else if(io_write && io_address == 3'h2)     enable <= io_writedata[2];
-end
-
-reg [1:0] data_rate;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           data_rate <= 2'b10;
-    else if(io_write && io_address == 3'h4)     data_rate <= io_writedata[1:0];
-    else if(io_write && io_address == 3'h7)     data_rate <= io_writedata[1:0];
-end
-
-reg datareg_ready;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               datareg_ready <= 1'b1;
-    else if(sw_reset)                               datareg_ready <= 1'b1;
-    
-    else if(cmd_read_write_ok_at_start)             datareg_ready <= 1'b0;
-    else if(cmd_read_id_ok_at_start)                datareg_ready <= 1'b0;
-    else if(cmd_format_ok_at_start)                 datareg_ready <= 1'b0;
-    
-    else if(execute_ndma && state == S_WAIT_FOR_EMPTY_READ_FIFO && read_in_io_mode)                                 datareg_ready <= 1'b0;
-    else if(execute_ndma && state == S_WAIT_FOR_EMPTY_READ_FIFO && ~(from_floppy_empty))                            datareg_ready <= 1'b1;
-    
-    else if(execute_ndma && state == S_WAIT_FOR_FULL_WRITE_FIFO && to_floppy_count == 11'd511 && write_in_io_mode)  datareg_ready <= 1'b0;
-    else if(execute_ndma && state == S_WAIT_FOR_FULL_WRITE_FIFO && to_floppy_count < 11'd512)                       datareg_ready <= 1'b1;
-    
-    else if(execute_ndma && state == S_WAIT_FOR_FORMAT_INPUT && format_data_count == 3'd3 && write_in_io_mode)      datareg_ready <= 1'b0;
-    else if(execute_ndma && state == S_WAIT_FOR_FORMAT_INPUT && format_data_count < 3'd4)                           datareg_ready <= 1'b1;
-    
-    else if(enter_result_phase)                                                                                     datareg_ready <= 1'b1;
-end
-
-reg execute_ndma;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               execute_ndma <= 1'b0;
-    else if(cmd_read_write_ok_at_start && ndma)     execute_ndma <= 1'b1;
-    else if(cmd_format_ok_at_start && ndma)         execute_ndma <= 1'b1;
-    else if(enter_result_phase)                     execute_ndma <= 1'b0;
-end
-
-reg transfer_to_cpu;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   transfer_to_cpu <= 1'b0;
-    else if(sw_reset)                                                   transfer_to_cpu <= 1'b0;
-    else if(command_first && ~(enter_result_phase))                     transfer_to_cpu <= 1'b0;
-    else if(execute_ndma && state == S_WAIT_FOR_EMPTY_READ_FIFO)        transfer_to_cpu <= 1'b1;
-    else if(enter_result_phase)                                         transfer_to_cpu <= 1'b1;
-    else if(io_read_valid && io_address == 3'd5 && reply_left == 4'd1)  transfer_to_cpu <= 1'b0;
-end
-
-reg busy;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   busy <= 1'b0;
-    else if(sw_reset)                                                   busy <= 1'b0;
-    else if(command_first)                                              busy <= 1'b1;
-    else if(cmd_recalibrate_start)                                      busy <= 1'b0;
-    else if(cmd_seek_start)                                             busy <= 1'b0;
-    else if(cmd_specify_start)                                          busy <= 1'b0;
-    else if(cmd_configure_mode_start)                                   busy <= 1'b0;
-    else if(cmd_perpendicular_mode_start)                               busy <= 1'b0;
-    else if(enter_result_phase)                                         busy <= 1'b1;
-    else if(io_read_valid && io_address == 3'd5 && reply_left == 4'd1)  busy <= 1'b0;
-end
-
-reg change;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       change <= 1'b1;
-    else if(~(media_present))                                               change <= 1'b1;
-    else if(reset_changeline && selected_drive == 2'd0 && media_present)    change <= 1'b0;
-end
-
-reg [3:0] in_seek_mode;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   in_seek_mode <= 4'd0;
-    else if(sw_reset)                   in_seek_mode <= 4'd0;
-    else if(cmd_recalibrate_start)      in_seek_mode <= (io_writedata[1:0] == 2'd0)? 4'b0001 : (io_writedata[1:0] == 2'd1)? 4'b0010 : (io_writedata[1:0] == 2'd2)? 4'b0100 : 4'b1000;
-    else if(cmd_seek_start)             in_seek_mode <= (command[1:0] == 2'd0)? 4'b0001 : (command[1:0] == 2'd1)? 4'b0010 : (command[1:0] == 2'd2)? 4'b0100 : 4'b1000;
-end
-
-//------------------------------------------------------------------------------
-
-wire command_first = io_write && io_address == 3'h5 && state == S_IDLE && command_left == 4'd0 && ~(busy);
-wire command_next  = io_write && io_address == 3'h5 && state == S_IDLE && command_left > 4'd0;
-
-reg [71:0] command;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           command <= 72'd0;
-    else if(command_first)      command <= { command[63:0], io_writedata };
-    else if(command_next)       command <= { command[63:0], io_writedata };
-end
-
-wire [3:0] command_at_first =
-    (io_writedata == 8'h03)?                    4'd2 :                      //specify command
-    (io_writedata == 8'h04)?                    4'd1 :                      //get status
-    (io_writedata == 8'h07)?                    4'd1 :                      //recalibrate
-    (io_writedata == 8'h0F)?                    4'd2 :                      //seek
-    (io_writedata == 8'h4A)?                    4'd1 :                      //read ID
-    (io_writedata == 8'h4D)?                    4'd5 :                      //format track
-    ({ 1'b0, io_writedata[6:0] } == 8'h45)?     4'd8 :                      //write normal data
-    ({ 1'b0, io_writedata[6], 1'b0, io_writedata[4:0] } ==  8'h46)?  4'd8 : //read normal data
-    (io_writedata == 8'h12)?                    4'd1 :                      //perpendicular mode (Enhanced)
-    (io_writedata == 8'h13)?                    4'd3 :                      //configure command (Enhanced)
-                                                4'd0;
-
-reg [3:0] command_size;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   command_size <= 4'd0;
-    
-    else if(command_first && command_at_first != 4'd0)  command_size <= command_at_first;
-end
-
-reg [3:0] command_left;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       command_left <= 4'd0;
-    
-    else if(command_first && command_at_first != 4'd0)      command_left <= command_at_first;
-    else if(command_next)                                   command_left <= command_left - 4'd1;
-end
-
-reg [7:0] pending_command;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           pending_command <= 8'b0;
-    else if(sw_reset)                           pending_command <= 8'h00;
-    else if(cmd_read_write_ok_at_start)         pending_command <= command[63:56];
-    else if(cmd_read_id_ok_at_start)            pending_command <= 8'h4A;
-    else if(cmd_format_ok_at_start)             pending_command <= command[39:32];
-    else if(cmd_recalibrate_start)              pending_command <= 8'h07;
-    else if(enter_result_phase)                 pending_command <= 8'h00;
-end
-
-wire cmd_sense_interrupt_status_start   = command_first && io_writedata == 8'h08;       //enters result phase
-wire cmd_dump_registers_start           = command_first && io_writedata == 8'h0E;       //enters result phase
-wire cmd_version_start                  = command_first && io_writedata == 8'h10;       //enters result phase
-wire cmd_unlock_start                   = command_first && io_writedata == 8'h14;       //enters result phase
-wire cmd_lock_start                     = command_first && io_writedata == 8'h94;       //enters result phase
-
-wire cmd_specify_start        = command_size == 4'd2 && command_next && command_left == 4'd1 && command[15:8]  == 8'h03;    //immediate finish
-wire cmd_get_status_start     = command_size == 4'd1 && command_next && command_left == 4'd1 && command[7:0]   == 8'h04;    //enters result phase
-wire cmd_recalibrate_start    = command_size == 4'd1 && command_next && command_left == 4'd1 && command[7:0]   == 8'h07;    //interrupt after delay
-wire cmd_seek_start           = command_size == 4'd2 && command_next && command_left == 4'd1 && command[15:8]  == 8'h0F;    //interrupt after delay
-wire cmd_read_id_start        = command_size == 4'd1 && command_next && command_left == 4'd1 && command[7:0]   == 8'h4A;    //enters result phase
-wire cmd_format_track_start   = command_size == 4'd5 && command_next && command_left == 4'd1 && command[39:32] == 8'h4D;    //enters result pahse
-wire cmd_write_normal_start   = command_size == 4'd8 && command_next && command_left == 4'd1 && { 1'b0, command[62:56] } == 8'h45;                      //enters result phase
-wire cmd_read_normal_start    = command_size == 4'd8 && command_next && command_left == 4'd1 && { 1'b0, command[62], 1'b0, command[60:56] } ==  8'h46;  //enters result phase
-
-wire cmd_perpendicular_mode_start = command_size == 4'd1 && command_next && command_left == 4'd1 && command[7:0]   == 8'h12;    //immediate finish
-wire cmd_configure_mode_start     = command_size == 4'd3 && command_next && command_left == 4'd1 && command[23:16] == 8'h13;    //immediate finish
-
-wire cmd_invalid_start = command_first &&
-    io_writedata != 8'h03 &&
-    io_writedata != 8'h04 &&
-    io_writedata != 8'h07 &&
-    io_writedata != 8'h08 &&
-    io_writedata != 8'h0F &&
-    io_writedata != 8'h4A &&
-    io_writedata != 8'h4D &&
-    { 1'b0, io_writedata[6:0] } != 8'h45 &&
-    { 1'b0, io_writedata[6], 1'b0, io_writedata[4:0] } !=  8'h46 &&
-    io_writedata != 8'h0E &&
-    io_writedata != 8'h10 &&
-    io_writedata != 8'h14 &&
-    io_writedata != 8'h94 &&
-    io_writedata != 8'h12 &&
-    io_writedata != 8'h13;
-
-wire cmd_read_write_start = cmd_read_normal_start || cmd_write_normal_start;
-
-wire cmd_read_normal_in_progress  = { 1'b0, pending_command[6], 1'b0, pending_command[4:0] } ==  8'h46;
-wire cmd_write_normal_in_progress = { 1'b0, pending_command[6:0] } == 8'h45;
-wire cmd_format_in_progress       = pending_command == 8'h4D;
-wire cmd_recalibrate_in_progress  = pending_command == 8'h07;
-wire cmd_read_id_in_progress      = pending_command == 8'h4A;
-
-wire enter_result_phase =
-    cmd_invalid_start || cmd_sense_interrupt_status_start || cmd_dump_registers_start || cmd_version_start || cmd_unlock_start || cmd_lock_start ||
-    (cmd_read_write_start && (cmd_read_write_incorrect_head_at_start || cmd_read_write_incorrect_sector_at_start || cmd_write_and_writeprotected_at_start)) ||
-    (state == S_CHECK_TC && (cmd_read_write_finish || cmd_format_finish)) ||
-    (cmd_format_track_start && cmd_format_writeprotected_at_start) ||
-    (state == S_WAIT_FOR_FORMAT_INPUT && cmd_format_in_input_finish) ||
-    cmd_get_status_start ||
-    cmd_read_id_finished;
-
-wire raise_interrupt = dma_irq_enable && (
-    (cmd_read_write_start && (cmd_read_write_incorrect_head_at_start || cmd_read_write_incorrect_sector_at_start)) ||
-    (cmd_write_normal_start && cmd_write_and_writeprotected_at_start) ||
-    (state == S_CHECK_TC && (cmd_read_write_finish || cmd_format_finish)) ||
-    (cmd_format_track_start && cmd_format_writeprotected_at_start) ||
-    (state == S_WAIT_FOR_FORMAT_INPUT && cmd_format_in_input_finish) ||
-    delay_last_cycle
-);
-
-wire reset_changeline =
-    (cmd_read_write_ok_at_start) ||
-    (state == S_UPDATE_SECTOR && increment_cylinder) ||
-    (cmd_recalibrate_start && cylinder != 8'd0) ||
-    (cmd_seek_start && cylinder != io_writedata);
-
-
-//------------------------------------------------------------------------------ cmd: read / write
-
-wire cmd_read_write_hang_at_start =
-    ~(motor_enable) ||                  //motor off
-    command[49:48] != 2'b00 ||          //no drive
-    ~(media_present) ||                 //no media
-    command[23:16] != 8'h02 ||          //invalid sector size
-    command[47:40] >= media_cylinders;  //invalid cylinder
-
-wire cmd_read_write_incorrect_head_at_start   = motor_enable && command[49:48] == 2'b00 && (command[50] != command[32] || (command[32] && media_heads == 2'd1));
-wire cmd_read_write_incorrect_sector_at_start = ~(cmd_read_write_hang_at_start) && (command[31:24] > media_sectors_per_track || command[31:24] > command[15:8]);
-wire cmd_write_and_writeprotected_at_start    = ~(cmd_read_write_hang_at_start) && ~(cmd_read_write_incorrect_sector_at_start) && cmd_write_normal_start && media_writeprotected;
-    
-wire cmd_read_write_ok_at_start = 
-    cmd_read_write_start && ~(cmd_read_write_hang_at_start) && ~(cmd_read_write_incorrect_head_at_start) && ~(cmd_read_write_incorrect_sector_at_start) && ~(cmd_write_and_writeprotected_at_start);
-    
-reg cmd_read_write_multitrack;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   cmd_read_write_multitrack <= 1'b0;
-    else if(cmd_read_write_ok_at_start) cmd_read_write_multitrack <= command[63];
-end
-
-wire cmd_read_write_finish =
-    (cmd_read_normal_in_progress || cmd_write_normal_in_progress) && (
-        (~(execute_ndma) && was_dma_terminal) ||
-        (execute_ndma && cmd_read_write_was_ndma_terminal)
-);
-
-reg cmd_read_write_was_ndma_terminal;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                               cmd_read_write_was_ndma_terminal <= 1'd0;
-    else if(state == S_UPDATE_SECTOR && sector == eot && { 1'b0, head } == (media_heads - 2'd1))    cmd_read_write_was_ndma_terminal <= 1'd1;
-    else if(state == S_UPDATE_SECTOR)                                                               cmd_read_write_was_ndma_terminal <= 1'd0;
-end
-
-//------------------------------------------------------------------------------ cmd: read id
-    
-wire cmd_read_id_hang_at_start =
-    ~(motor_enable) ||                  //motor off
-    io_writedata[1:0] != 2'b00 ||       //no drive
-    ~(media_present);                   //no media
-
-wire cmd_read_id_ok_at_start = cmd_read_id_start && ~(cmd_read_id_hang_at_start);
-
-wire cmd_read_id_finished = state == S_WAIT && command_wait_counter == 16'd0 && cmd_read_id_in_progress;
-
-//------------------------------------------------------------------------------ cmd: specify
-    
-reg [3:0] specify_srt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           specify_srt <= 4'd0;
-    else if(cmd_specify_start)  specify_srt <= command[7:4];
-end
-
-reg [3:0] specify_hut;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           specify_hut <= 4'b0;
-    else if(cmd_specify_start)  specify_hut <= command[3:0];
-end
-
-reg [6:0] specify_hlt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           specify_hlt <= 7'b0;
-    else if(cmd_specify_start)  specify_hlt <= io_writedata[7:1];
-end
-
-reg ndma;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           ndma <= 1'b0;
-    else if(cmd_specify_start)  ndma <= io_writedata[0];
-end
-
-//------------------------------------------------------------------------------ cmd: sense interrupt status
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   irq <= 1'b0;
-    else if(sw_reset)                                                   irq <= 1'b1;
-    else if(raise_interrupt)                                            irq <= 1'b1;
-    else if(write_in_io_mode)                                           irq <= 1'b0;
-    else if(read_in_io_mode)                                            irq <= 1'b0;
-    else if(io_read_valid && io_address == 3'd5 && ~(read_in_io_mode))  irq <= 1'b0;
-end
-
-reg [2:0] reset_sensei;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   reset_sensei <= 3'd0;
-    else if(sw_reset)                                                   reset_sensei <= 3'd4;
-    else if(raise_interrupt)                                            reset_sensei <= 3'd0;
-    else if(cmd_sense_interrupt_status_start && reset_sensei > 3'd0)    reset_sensei <= reset_sensei - 3'd1;
-end
-
-wire [1:0] reset_sensei_drive =
-    (reset_sensei == 3'd4)?     2'd0 :
-    (reset_sensei == 3'd3)?     2'd1 :
-    (reset_sensei == 3'd2)?     2'd2 :
-                                2'd3;
-
-reg pending_interrupt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           pending_interrupt <= 1'b0;
-    else if(raise_interrupt)    pending_interrupt <= 1'b1;
-    else if(~(irq))             pending_interrupt <= 1'b0;
-end
-
-reg pending_interrupt_last;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   pending_interrupt_last <= 1'b0;
-    else                pending_interrupt_last <= pending_interrupt;
-end
-
-//------------------------------------------------------------------------------ cmd: recalibrate / seek
-
-reg [7:0] delay_steps;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       delay_steps <= 8'd0;
-    else if(cmd_recalibrate_start)                                          delay_steps <= (cylinder == 8'd0)? 8'd0 : cylinder - 8'd1;
-    else if(cmd_seek_start)                                                 delay_steps <= (cylinder == io_writedata)? 8'd0 : (cylinder > io_writedata)? cylinder - io_writedata - 8'd1 : io_writedata - cylinder - 8'd1; 
-    else if(delay_rate == 16'd0 && delay_srt == 4'd0 && delay_steps > 8'd0) delay_steps <= delay_steps - 8'd1;
-end
-
-reg [3:0] delay_srt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   delay_srt <= 4'd0;
-    else if(cmd_recalibrate_start)                      delay_srt <= specify_srt;
-    else if(cmd_seek_start)                             delay_srt <= specify_srt;
-    else if(delay_rate == 16'd0 && delay_srt > 4'd0)    delay_srt <= delay_srt - 4'd1;
-    else if(delay_rate == 16'd0 && delay_steps > 8'd0)  delay_srt <= specify_srt;
-end
-
-reg [15:0] delay_rate;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               delay_rate <= 16'd0;
-    else if(cmd_recalibrate_start)                  delay_rate <= (data_rate == 2'd0)? media_wait_rate_0 : (data_rate == 2'd1)? media_wait_rate_1 : (data_rate == 2'd2)? media_wait_rate_2 : media_wait_rate_3;
-    else if(cmd_seek_start)                         delay_rate <= (data_rate == 2'd0)? media_wait_rate_0 : (data_rate == 2'd1)? media_wait_rate_1 : (data_rate == 2'd2)? media_wait_rate_2 : media_wait_rate_3;
-    else if(delay_rate > 16'd0)                     delay_rate <= delay_rate - 16'd1;
-    else if(delay_srt > 4'd0 || delay_steps > 8'd0) delay_rate <= (data_rate == 2'd0)? media_wait_rate_0 : (data_rate == 2'd1)? media_wait_rate_1 : (data_rate == 2'd2)? media_wait_rate_2 : media_wait_rate_3;
-end
-
-wire delay_last_cycle = delay_steps == 8'd0 && delay_srt == 4'd0 && delay_rate == 16'd1;
-
-reg [7:0] status_reg0_temp;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   status_reg0_temp <= 8'd0;
-    else if(pending_interrupt && pending_interrupt_last == 1'b0)        status_reg0_temp <= reply[7:0];
-    else if(cmd_sense_interrupt_status_start && reset_sensei > 3'd0)    status_reg0_temp <= { status_reg0_temp[7:3], (reset_sensei == 3'd4)? head : 1'b0, reset_sensei_drive };
-end
-
-//------------------------------------------------------------------------------ cmd: configure / lock / unlock
-
-reg [7:0] config_config;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   config_config <= 8'd0;
-    else if(cmd_configure_mode_start)   config_config <= command[7:0];
-end
-
-reg [7:0] config_pretrk;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   config_pretrk <= 8'd0;
-    else if(cmd_configure_mode_start)   config_pretrk <= io_writedata;
-end
-
-reg [7:0] perp_mode;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       perp_mode <= 8'd0;
-    else if(cmd_perpendicular_mode_start)   perp_mode <= io_writedata;
-end
-
-reg lock;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           lock <= 1'd0;
-    else if(cmd_unlock_start)   lock <= 1'd0;
-    else if(cmd_lock_start)     lock <= 1'd1;
-end
-
-//------------------------------------------------------------------------------ cmd: format
-
-wire cmd_format_writeprotected_at_start = ~(cmd_format_hang_on_start) && cmd_format_track_start && media_writeprotected;
-    
-wire cmd_format_hang_on_start =
-    ~(motor_enable) ||                          //motor off
-    command[25:24] != 2'b00 ||                  //no drive
-    ~(media_present) ||                         //no media
-    command[23:16] != 8'h02 ||                  //invalid sector size
-    command[15:8] != media_sectors_per_track;   //invalid secotr count
-
-wire cmd_format_ok_at_start = cmd_format_track_start && ~(cmd_format_writeprotected_at_start) && ~(cmd_format_hang_on_start);
-
-reg [31:0] format_data;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       format_data <= 32'd0;
-    else if(write_in_io_mode && format_data_count < 3'd4)   format_data <= { format_data[23:0], io_writedata };
-    else if(dma_floppy_ack && format_data_count < 3'd4)     format_data <= { format_data[23:0], dma_floppy_readdata };
-end
-
-reg [2:0] format_data_count;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           format_data_count <= 3'd0;
-    else if(state != S_WAIT_FOR_FORMAT_INPUT)                                   format_data_count <= 3'd0;
-    else if((write_in_io_mode || dma_floppy_ack) && format_data_count < 3'd4)   format_data_count <= format_data_count + 3'd1;
-end
-
-reg [7:0] format_filler_byte;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   format_filler_byte <= 8'd0;
-    else if(cmd_format_ok_at_start)     format_filler_byte <= io_writedata;
-end
-
-reg [7:0] format_sector_count;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                               format_sector_count <= 8'd0;
-    else if(cmd_format_ok_at_start)                                                                 format_sector_count <= command[15:8];
-    else if(state == S_SD_FORMAT_WAIT_FOR_FILL && sd_read_counter == 9'd511 && sd_slave_read_valid) format_sector_count <= format_sector_count - 8'd1;
-end
-
-wire cmd_format_in_input_finish = ~(execute_ndma) && was_dma_terminal;
-
-wire cmd_format_finish = cmd_format_in_progress && (
-    cmd_format_in_input_finish ||
-    (execute_ndma && format_sector_count == 8'd0)
-);
-
-//------------------------------------------------------------------------------ reply
-
-reg [3:0] reply_left;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                               reply_left <= 4'd0;
-    else if(sw_reset)                                                               reply_left <= 4'd0;
-    else if(cmd_invalid_start)                                                      reply_left <= 4'd1;
-    else if(cmd_read_write_start   && cmd_read_write_incorrect_head_at_start)       reply_left <= 4'd7;
-    else if(cmd_read_write_start   && cmd_read_write_incorrect_sector_at_start)     reply_left <= 4'd7;
-    else if(cmd_write_normal_start && cmd_write_and_writeprotected_at_start)        reply_left <= 4'd7;
-    else if(cmd_format_track_start && cmd_format_writeprotected_at_start)           reply_left <= 4'd7;
-    else if(state == S_CHECK_TC && (cmd_read_write_finish || cmd_format_finish))    reply_left <= 4'd7;
-    else if(state == S_WAIT_FOR_FORMAT_INPUT && cmd_format_in_input_finish)         reply_left <= 4'd7;
-    else if(cmd_read_id_finished)                                                   reply_left <= 4'd7;
-    else if(cmd_get_status_start)                                                   reply_left <= 4'd1;
-    else if(cmd_sense_interrupt_status_start)                                       reply_left <= 4'd2;
-    else if(cmd_dump_registers_start)                                               reply_left <= 4'd10;
-    else if(cmd_version_start)                                                      reply_left <= 4'd1;
-    else if(cmd_unlock_start || cmd_lock_start)                                     reply_left <= 4'd1;
-    else if(io_read_valid && io_address == 3'h5 && reply_left > 4'd0)               reply_left <= reply_left - 3'd1;
-end
-
-reg [79:0] reply;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           reply <= 80'd0;
-    else if(sw_reset)                                                           reply <= { 72'd0, 8'hC0 };
-    
-    else if(cmd_invalid_start)                                                  reply <= { reply[79:8], 8'h80 };
-    else if(delay_last_cycle && cmd_recalibrate_in_progress)                    reply <= { reply[79:8], 8'h20 | { 6'd0, selected_drive[1:0] } | ((selected_drive != 2'd0 || ~(motor_enable))? 8'h50 : 8'h00) };
-    else if(delay_last_cycle)                                                   reply <= { reply[79:8], 8'h20 | { 5'd0, (selected_drive != 2'd0)? 1'b0 : head, selected_drive[1:0] } }; 
-    else if(cmd_read_write_start && cmd_read_write_incorrect_head_at_start)     reply <= { 24'd0, 8'd2, sector,         7'b0,head,         cylinder,       8'h00, 8'h04, (8'h40 | { 5'd0, head,        2'b0 }) };
-    else if(cmd_read_write_start && cmd_read_write_incorrect_sector_at_start)   reply <= { 24'd0, 8'd2, command[31:24], 7'b0,command[32],  command[47:40], 8'h00, 8'h04, (8'h40 | { 5'd0, command[32], 2'b0 }) };
-    else if(cmd_write_normal_start && cmd_write_and_writeprotected_at_start)    reply <= { 24'd0, 8'd2, command[31:24], 7'b0,command[32],  command[47:40], 8'h31, 8'h27, (8'h40 | { 5'd0, command[32], 2'b0 }) };
-    else if(cmd_format_track_start && cmd_format_writeprotected_at_start)       reply <= { 24'd0, 8'd2, sector,         7'b0,command[26],  cylinder,       8'h31, 8'h27, (8'h40 | { 5'd0, command[26], 2'b0 }) };
-    else if(state == S_CHECK_TC && cmd_read_write_finish)                       reply <= { 24'd0, 8'd2, sector,         7'b0,head,         cylinder,       8'h00, 8'h00, (8'h00 | { 5'd0, head,        2'b0 }) };
-    else if(state == S_CHECK_TC && cmd_format_finish)                           reply <= { 24'd0, 8'd2, sector,         7'b0,head,         cylinder,       8'h00, 8'h00, (8'h00 | { 5'd0, head,        2'b0 }) };
-    else if(state == S_WAIT_FOR_FORMAT_INPUT && cmd_format_in_input_finish)     reply <= { 24'd0, 8'd2, sector,         7'b0,head,         cylinder,       8'h00, 8'h00, (8'h40 | { 5'd0, head,        2'b0 }) };
-    else if(cmd_read_id_finished)                                               reply <= { 24'd0, 8'd2, sector,         7'b0,head,         cylinder,       8'h00, 8'h00, (8'h00 | { 5'd0, head,        2'b0 }) };
-    else if(cmd_get_status_start)                                               reply <= { 72'd0, 1'b0, media_writeprotected, 1'b1, (io_writedata[1:0] == 2'b00 && cylinder == 8'd0)? 1'b1 : 1'b0, 1'b1, io_writedata[2:0] };
-    else if(cmd_sense_interrupt_status_start && reset_sensei > 3'd0)            reply <= { 64'd0, cylinder, status_reg0_temp[7:3], (reset_sensei == 3'd4)? head : 1'b0, reset_sensei_drive };
-    else if(cmd_sense_interrupt_status_start && pending_interrupt)              reply <= { 64'd0, cylinder, status_reg0_temp };
-    else if(cmd_sense_interrupt_status_start && ~(pending_interrupt))           reply <= { 64'd0, cylinder, 8'h80 };
-    else if(cmd_dump_registers_start)                                           reply <= { config_pretrk, config_config, lock, perp_mode[6:0], (selected_drive == 2'd0)? eot : 8'd0,
-                                                                                           specify_hlt, ndma, specify_srt, specify_hut, 8'h0, 8'h0, 8'h0, cylinder };
-    else if(cmd_version_start)                                                  reply <= { 72'd0, 8'h90 };
-    else if(cmd_unlock_start)                                                   reply <= 80'd0;
-    else if(cmd_lock_start)                                                     reply <= { 72'd0, 3'd0, 1'b1, 4'd0 };
-    else if(io_read_valid && io_address == 3'h5)                                reply <= { 8'd0, reply[79:8] };
-end
-
-//------------------------------------------------------------------------------ state
-
-localparam [4:0] S_IDLE                         = 5'd0;
-
-localparam [4:0] S_PREPARE_COUNT                = 5'd1;
-localparam [4:0] S_COUNT_LOGICAL                = 5'd2;
-
-localparam [4:0] S_SD_MUTEX                     = 5'd3;
-localparam [4:0] S_SD_AVALON_BASE               = 5'd4;
-localparam [4:0] S_SD_ADDRESS                   = 5'd5;
-localparam [4:0] S_SD_BLOCK_COUNT               = 5'd6;
-
-localparam [4:0] S_SD_CONTROL                   = 5'd7;
-localparam [4:0] S_SD_READ_WAIT_FOR_DATA        = 5'd8;
-localparam [4:0] S_WAIT_FOR_EMPTY_READ_FIFO     = 5'd9;
-
-localparam [4:0] S_UPDATE_SECTOR                = 5'd10;
-localparam [4:0] S_CHECK_TC                     = 5'd11;
-localparam [4:0] S_WAIT                         = 5'd12;
-
-localparam [4:0] S_WAIT_FOR_FULL_WRITE_FIFO     = 5'd13;
-localparam [4:0] S_SD_WRITE_WAIT_FOR_EMPTY_FIFO = 5'd14;
-
-localparam [4:0] S_WAIT_FOR_FORMAT_INPUT        = 5'd15;
-localparam [4:0] S_SD_FORMAT_WAIT_FOR_FILL      = 5'd16;
-
-reg [4:0] state;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                   state <= S_IDLE;
-    
-    //start read/write
-    else if(state == S_IDLE && cmd_read_write_ok_at_start)                                              state <= S_PREPARE_COUNT;
-    
-    //read
-    else if(state == S_COUNT_LOGICAL && mult_b == 8'd0 && cmd_read_normal_in_progress)                  state <= S_SD_MUTEX;
-        //sd
-    else if(state == S_SD_CONTROL && sd_master_waitrequest == 1'b0 && cmd_read_normal_in_progress)      state <= S_SD_READ_WAIT_FOR_DATA;
-    else if(state == S_SD_READ_WAIT_FOR_DATA && sd_slave_write && sd_write_counter == 9'd511)           state <= S_WAIT_FOR_EMPTY_READ_FIFO;
-    else if(state == S_WAIT_FOR_EMPTY_READ_FIFO && from_floppy_empty)                                   state <= S_UPDATE_SECTOR;
-    
-    //write
-    else if(state == S_COUNT_LOGICAL && mult_b == 8'd0 && cmd_write_normal_in_progress)                 state <= S_WAIT_FOR_FULL_WRITE_FIFO;
-    else if(state == S_WAIT_FOR_FULL_WRITE_FIFO && to_floppy_count == 11'd512)                          state <= S_SD_MUTEX;
-        //sd
-    else if(state == S_SD_CONTROL && sd_master_waitrequest == 1'b0 && cmd_write_normal_in_progress)     state <= S_SD_WRITE_WAIT_FOR_EMPTY_FIFO;
-    else if(state == S_SD_WRITE_WAIT_FOR_EMPTY_FIFO && to_floppy_empty)                                 state <= S_UPDATE_SECTOR;
-    
-    //format
-    else if(state == S_IDLE && cmd_format_ok_at_start)                                                  state <= S_WAIT_FOR_FORMAT_INPUT;
-    else if(state == S_WAIT_FOR_FORMAT_INPUT && cmd_format_in_input_finish)                             state <= S_IDLE;
-    else if(state == S_WAIT_FOR_FORMAT_INPUT && format_data_count == 3'd4)                              state <= S_PREPARE_COUNT;
-        //count
-    else if(state == S_COUNT_LOGICAL && mult_b == 8'd0 && cmd_format_in_progress)                       state <= S_SD_MUTEX;
-        //sd
-    else if(state == S_SD_CONTROL && sd_master_waitrequest == 1'b0 && cmd_format_in_progress)           state <= S_SD_FORMAT_WAIT_FOR_FILL;
-    else if(state == S_SD_FORMAT_WAIT_FOR_FILL && sd_read_counter == 9'd511 && sd_slave_read_valid)     state <= S_WAIT;
-    
-    //read id
-    else if(state == S_IDLE && cmd_read_id_ok_at_start)                                                 state <= S_WAIT;
-    else if(state == S_WAIT && command_wait_counter == 16'd0 && cmd_read_id_in_progress)                state <= S_IDLE;
-    
-    //count
-    else if(state == S_PREPARE_COUNT)                                                                   state <= S_COUNT_LOGICAL;
-    
-    //sd read/write
-    else if(state == S_SD_MUTEX && sd_master_readdatavalid && sd_master_readdata[2:0] == 3'd1)          state <= S_SD_AVALON_BASE;
-    else if(state == S_SD_AVALON_BASE && sd_master_waitrequest == 1'b0)                                 state <= S_SD_ADDRESS;
-    else if(state == S_SD_ADDRESS     && sd_master_waitrequest == 1'b0)                                 state <= S_SD_BLOCK_COUNT;
-    else if(state == S_SD_BLOCK_COUNT && sd_master_waitrequest == 1'b0)                                 state <= S_SD_CONTROL;
-    
-    //update read/write/format
-    else if(state == S_UPDATE_SECTOR)                                                                   state <= S_WAIT;
-    else if(state == S_WAIT && command_wait_counter == 16'd0 && ~(cmd_read_id_in_progress))             state <= S_CHECK_TC;
-    else if(state == S_CHECK_TC && (cmd_read_write_finish || cmd_format_finish))                        state <= S_IDLE;
-    else if(state == S_CHECK_TC && cmd_format_in_progress)                                              state <= S_WAIT_FOR_FORMAT_INPUT;
-    else if(state == S_CHECK_TC)                                                                        state <= S_PREPARE_COUNT;
-end
-
-reg [15:0] command_wait_counter;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                           command_wait_counter <= 16'd0;
-    else if(state != S_WAIT)                                    command_wait_counter <= media_wait_cycles;
-    else if(state == S_WAIT && command_wait_counter > 16'd0)    command_wait_counter <= command_wait_counter - 16'd1;
-end
-
-//------------------------------------------------------------------------------ count logical sector
-
-reg [15:0] mult_a; //sectors per track * heads
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)	                mult_a <= 16'd0;
-    else if(state == S_PREPARE_COUNT)   mult_a <= (media_heads == 2'd2)? { 7'd0, media_sectors_per_track, 1'b0 } : { 8'b0, media_sectors_per_track };
-    else if(state == S_COUNT_LOGICAL)   mult_a <= { mult_a[14:0], 1'b0 };
-end
-
-reg [7:0] mult_b; //cylinder
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   mult_b <= 8'd0;
-    else if(state == S_PREPARE_COUNT)   mult_b <= cylinder;
-    else if(state == S_COUNT_LOGICAL)   mult_b <= { 1'b0, mult_b[7:1] };
-end
-
-reg [15:0] logical_sector;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               logical_sector <= 16'd0;
-    else if(state == S_PREPARE_COUNT)               logical_sector <= ((head == 1'b1)? { 8'd0, media_sectors_per_track } : 16'd0) + { 8'd0, sector } - 16'd1;
-    else if(state == S_COUNT_LOGICAL && mult_b[0])  logical_sector <= logical_sector + mult_a;
-end
-
-//------------------------------------------------------------------------------ location
-
-wire increment_only_sector = sector < eot && sector < media_sectors_per_track;
-wire increment_cylinder    = ~(increment_only_sector) && (~(cmd_read_write_multitrack) || head == 1'b1);
-
-reg [7:0] cylinder;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                                       cylinder <= 8'd0;
-    else if(sw_reset)                                                                                                       cylinder <= 8'd0;
-    else if(cmd_read_write_start && (cmd_read_write_incorrect_sector_at_start || cmd_write_and_writeprotected_at_start))    cylinder <= command[47:40];
-    else if(cmd_read_write_ok_at_start)                                                                                     cylinder <= command[47:40];
-    else if(cmd_recalibrate_start)                                                                                          cylinder <= 8'd0;
-    else if(cmd_seek_start)                                                                                                 cylinder <= io_writedata;
-    else if(state == S_UPDATE_SECTOR && increment_cylinder)                                                                 cylinder <= (cylinder >= media_cylinders)? media_cylinders - 8'd1 : cylinder + 8'd1;
-    else if(state == S_WAIT_FOR_FORMAT_INPUT && format_data_count == 3'd4)                                                  cylinder <= format_data[31:24];
-end
-
-reg head;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                                       head <= 1'd0;
-    else if(sw_reset)                                                                                                       head <= 1'b0;
-    else if(cmd_read_write_start && (cmd_read_write_incorrect_sector_at_start || cmd_write_and_writeprotected_at_start))    head <= command[32];
-    else if(cmd_format_track_start && cmd_format_writeprotected_at_start)                                                   head <= command[26];
-    else if(cmd_read_write_ok_at_start)                                                                                     head <= command[32];
-    else if(cmd_format_ok_at_start)                                                                                         head <= command[26];
-    else if(cmd_get_status_start)                                                                                           head <= io_writedata[2];
-    else if(cmd_seek_start)                                                                                                 head <= command[2];
-    else if(cmd_read_id_start)                                                                                              head <= io_writedata[2];
-    else if(state == S_UPDATE_SECTOR && ~(increment_only_sector) && cmd_read_write_multitrack)                              head <= ~(head);
-end
-
-reg [7:0] sector;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                                       sector <= 8'd1;
-    else if(sw_reset)                                                                                                       sector <= 8'd1;
-    else if(cmd_read_write_start && (cmd_read_write_incorrect_sector_at_start || cmd_write_and_writeprotected_at_start))    sector <= command[31:24];
-    else if(cmd_read_write_ok_at_start)                                                                                     sector <= command[31:24];
-    else if(state == S_UPDATE_SECTOR && increment_only_sector)                                                              sector <= sector + 8'd1;
-    else if(state == S_UPDATE_SECTOR && ~(increment_only_sector))                                                           sector <= 8'd1;
-    else if(state == S_WAIT_FOR_FORMAT_INPUT && format_data_count == 3'd4)                                                  sector <= format_data[15:8];
-end
-
-reg [7:0] eot;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       eot <= 8'd0;
-    else if(sw_reset)                       eot <= 8'd0;
-    else if(cmd_read_write_ok_at_start)     eot <= (command[15:8] == 8'd0)? media_sectors_per_track : command[15:8];
-end
-
-//------------------------------------------------------------------------------ sd
-
-assign sd_master_address =
-    (state == S_SD_MUTEX)?          32'd4 :
-    (state == S_SD_AVALON_BASE)?    32'd0 :
-    (state == S_SD_ADDRESS)?        32'd4 :
-    (state == S_SD_BLOCK_COUNT)?    32'd8 :
-    (state == S_SD_CONTROL)?        32'd12 :
-                                    32'd0;
-
-reg [2:0] sd_mutex_wait;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       sd_mutex_wait <= 3'd0;
-    else if(state == S_SD_MUTEX && sd_master_read == 1'b0)  sd_mutex_wait <= sd_mutex_wait + 3'd1;
-end
-
-reg sd_read_done;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                           sd_read_done <= 1'b0;
-    else if(sd_master_read && sd_master_waitrequest == 1'b0)    sd_read_done <= 1'b1;
-    else if(sd_master_readdatavalid)                            sd_read_done <= 1'b0;
-end
-
-assign sd_master_read = state == S_SD_MUTEX && sd_mutex_wait == 3'd5 && ~(sd_read_done);
-
-assign sd_master_write = state == S_SD_AVALON_BASE || state == S_SD_ADDRESS || state == S_SD_BLOCK_COUNT || state == S_SD_CONTROL;
-
-assign sd_master_writedata =
-    (state == S_SD_AVALON_BASE)?                                `SD_AVALON_BASE_ADDRESS_FOR_FDD :
-    (state == S_SD_ADDRESS)?                                    sd_sector :
-    (state == S_SD_BLOCK_COUNT)?                                32'd1 :
-    (state == S_SD_CONTROL && cmd_read_normal_in_progress)?     32'd2 : //CONTROL_READ
-    (state == S_SD_CONTROL && cmd_write_normal_in_progress)?    32'd3 : //CONTROL_WRITE
-    (state == S_SD_CONTROL && cmd_format_in_progress)?          32'd3 : //CONTROL_WRITE
-                                                                32'd0;
-
-reg [8:0] sd_write_counter;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           sd_write_counter <= 9'd0;
-    else if(sd_slave_write)     sd_write_counter <= sd_write_counter + 9'd1;
-end
-
-reg [8:0] sd_read_counter;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               sd_read_counter <= 9'd0;
-    else if(sd_slave_read_valid)    sd_read_counter <= sd_read_counter + 9'd1;
-end
-
-reg [31:0] sd_sector;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   sd_sector <= 32'd0;
-    else if(state == S_SD_AVALON_BASE)  sd_sector <= ({ 16'd0, logical_sector } >= media_sector_count)? media_sd_base + media_sector_count - 32'd1 : media_sd_base + { 16'd0, logical_sector };
-end
-
-//------------------------------------------------------------------------------ dma
-
-assign dma_floppy_writedata = from_floppy_q;
-
-assign dma_floppy_req = ~(execute_ndma) && ~(was_dma_terminal) && dma_irq_enable && ~(dma_floppy_ack) && (
-    (cmd_read_normal_in_progress  && ~(from_floppy_empty) && state == S_WAIT_FOR_EMPTY_READ_FIFO) ||
-    (cmd_write_normal_in_progress && to_floppy_count <= 11'd511 && state == S_WAIT_FOR_FULL_WRITE_FIFO) ||
-    (cmd_format_in_progress       && format_data_count < 3'd4 && state == S_WAIT_FOR_FORMAT_INPUT)
-);
-
-reg was_dma_terminal;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               was_dma_terminal <= 1'd0;
-    else if(state == S_IDLE)        was_dma_terminal <= 1'd0;
-    else if(dma_floppy_terminal)    was_dma_terminal <= 1'd1;
-end
-
-//------------------------------------------------------------------------------ fifo
-
-wire [10:0] to_floppy_count = { to_floppy_full, to_floppy_usedw };
-wire [9:0]  to_floppy_usedw;
-wire        to_floppy_full;
-wire        to_floppy_empty;
-wire [7:0]  to_floppy_q;
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   sd_slave_readdata <= 8'b0;
-    else if(cmd_format_in_progress)     sd_slave_readdata <= format_filler_byte;
-    else                                sd_slave_readdata <= to_floppy_q;
-end
-
-simple_fifo #(
-    .width      (8),
-    .widthu     (10)
-)
-fifo_to_floppy_inst(
-    .clk        (clk),
-    .rst_n      (rst_n),
-    
-    .sclr       (state == S_IDLE), //input
-    
-    .data       ((execute_ndma)? io_writedata : (was_dma_terminal)? 8'h00 : dma_floppy_readdata),                                                                                           //input [7:0]
-    .wrreq      (state == S_WAIT_FOR_FULL_WRITE_FIFO && (write_in_io_mode || (~(execute_ndma) && dma_floppy_ack) || (~(execute_ndma) && was_dma_terminal)) && to_floppy_count < 11'd512),   //input
-    .full       (to_floppy_full),   //output
-    
-    .rdreq      (sd_slave_read_valid),  //input
-    .empty      (to_floppy_empty),      //output
-    .q          (to_floppy_q),          //output [7:0]
-    
-    .usedw      (to_floppy_usedw)       //output [9:0]
-);
-
-wire [7:0] from_floppy_q;
-wire       from_floppy_empty;
-
-simple_fifo #(
-    .width      (8),
-    .widthu     (10)
-)
-fifo_from_floppy_inst(
-    .clk        (clk),
-    .rst_n      (rst_n),
-    
-     .sclr      (state == S_IDLE || (state == S_WAIT_FOR_EMPTY_READ_FIFO && ~(execute_ndma) && dma_floppy_terminal)),   //input
-    
-    .data       (sd_slave_writedata),   //input [7:0]
-    .wrreq      (sd_slave_write),       //input
-    
-    .rdreq      (state == S_WAIT_FOR_EMPTY_READ_FIFO && (read_in_io_mode || (~(execute_ndma) && dma_floppy_ack))),      //input
-    .empty      (from_floppy_empty),    //output
-    .q          (from_floppy_q),        //output [7:0]
-
-    /* verilator lint_off PINNOCONNECT */
-    .full       (),                     //output
-    .usedw      ()                      //output [9:0]
-    /* verilator lint_on PINNOCONNECT */
-);
-
 //------------------------------------------------------------------------------
 
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, sd_master_readdata[31:3], sd_slave_address, command[71:64], perp_mode[7], 1'b0 };
+ assign _unused_ok = &{ 1'b0, sd_master_readdata[31:3], sd_slave_address, command[71:64], perp_mode[7], 1'b0 };
 // synthesis translate_on
 
 //------------------------------------------------------------------------------
diff --git a/rtl/soc/hdd/hdd.v b/rtl/soc/hdd/hdd.v
index 4d65ae2..6f00414 100644
--- a/rtl/soc/hdd/hdd.v
+++ b/rtl/soc/hdd/hdd.v
@@ -1,17 +1,17 @@
 /*
  * Copyright (c) 2014, Aleksander Osman
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
- * 
+ *
  * * Redistributions of source code must retain the above copyright notice, this
  *   list of conditions and the following disclaimer.
- * 
+ *
  * * Redistributions in binary form must reproduce the above copyright notice,
  *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
@@ -24,975 +24,1608 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-module hdd(
-    input               clk,
-    input               rst_n,
-    
-    //irq
-    output reg          irq,
-    
-    //avalon slave
-    input               io_address,
-    input       [3:0]   io_byteenable,
-    input               io_read,
-    output reg  [31:0]  io_readdata,
-    input               io_write,
-    input       [31:0]  io_writedata, 
-    
-    //ide shared port 0x3F6
-    input               ide_3f6_read,
-    output reg  [7:0]   ide_3f6_readdata,
-    input               ide_3f6_write,
-    input       [7:0]   ide_3f6_writedata,
-    
-    //master to control sd
-    output      [31:0]  sd_master_address,
-    input               sd_master_waitrequest,
-    output              sd_master_read,
-    input               sd_master_readdatavalid,
-    input       [31:0]  sd_master_readdata,
-    output              sd_master_write,
-    output      [31:0]  sd_master_writedata,
-    
-    //slave with data from/to sd
-    input       [8:0]   sd_slave_address,
-    input               sd_slave_read,
-    output reg  [31:0]  sd_slave_readdata,
-    input               sd_slave_write,
-    input       [31:0]  sd_slave_writedata,
-    
-    //management slave
-    /*
-    0x00.[31:0]:    identify write
-    0x01.[16:0]:    media cylinders
-    0x02.[4:0]:     media heads
-    0x03.[8:0]:     media spt
-    0x04.[13:0]:    media sectors per cylinder = spt * heads
-    0x05.[31:0]:    media sectors total
-    0x06.[31:0]:    media sd base
-    */
-    input       [2:0]   mgmt_address,
-    input               mgmt_write,
-    input       [31:0]  mgmt_writedata
-);
-
-//------------------------------------------------------------------------------
+`include "../rtl/params.v"
 
+module hdd(
+	   input 	     clk,
+	   input 	     rst,
+
+	   //irq
+	   output reg 	     irq,
+
+	   //avalon slave
+	   input 	     io_address,
+	   input [3:0] 	     io_byteenable,
+	   input 	     io_read,
+	   output reg [31:0] io_readdata,
+	   input 	     io_write,
+	   input [31:0]      io_writedata,
+
+	   //ide shared port 0x3F6
+	   input 	     ide_3f6_read,
+	   output reg [7:0]  ide_3f6_readdata,
+	   input 	     ide_3f6_write,
+	   input [7:0] 	     ide_3f6_writedata,
+
+	   //master to control sd
+	   output [31:0]     sd_master_address,
+	   input 	     sd_master_waitrequest,
+	   output 	     sd_master_read,
+	   input 	     sd_master_readdatavalid,
+	   input [31:0]      sd_master_readdata,
+	   output 	     sd_master_write,
+	   output [31:0]     sd_master_writedata,
+
+	   //slave with data from/to sd
+	   input [8:0] 	     sd_slave_address,
+	   input 	     sd_slave_read,
+	   output reg [31:0] sd_slave_readdata,
+	   input 	     sd_slave_write,
+	   input [31:0]      sd_slave_writedata,
+
+	   //management slave
+	   /*
+	    0x00.[31:0]:    identify write
+	    0x01.[16:0]:    media cylinders
+	    0x02.[4:0]:     media heads
+	    0x03.[8:0]:     media spt
+	    0x04.[13:0]:    media sectors per cylinder = spt * heads
+	    0x05.[31:0]:    media sectors total
+	    0x06.[31:0]:    media sd base
+	    */
+	   input [2:0] 	     mgmt_address,
+	   input 	     mgmt_write,
+	   input [31:0]      mgmt_writedata
+	   );
+
+   //------------------------------------------------------------------------------
 `define SD_AVALON_BASE_ADDRESS_FOR_HDD 32'h00000000
+`define MAX_MULTIPLE_SECTORS 16
+   localparam [3:0] S_IDLE                     = 4'd0;
+   localparam [3:0] S_PREPARE_COUNT            = 4'd1;
+   localparam [3:0] S_COUNT_LOGICAL            = 4'd2;
+   localparam [3:0] S_COUNT_FINAL              = 4'd3;
+   localparam [3:0] S_COUNT_DECISION           = 4'd4;
+   localparam [3:0] S_SD_MUTEX                 = 4'd5;
+   localparam [3:0] S_SD_AVALON_BASE           = 4'd6;
+   localparam [3:0] S_SD_ADDRESS               = 4'd7;
+   localparam [3:0] S_SD_BLOCK_COUNT           = 4'd8;
+   localparam [3:0] S_SD_CONTROL               = 4'd9;
+   localparam [3:0] S_SD_READ_WAIT_FOR_DATA    = 4'd10;
+   localparam [3:0] S_WAIT_FOR_EMPTY_READ_FIFO = 4'd11;
+   localparam [3:0] S_IDENTIFY_COPY            = 4'd12;
+   localparam [3:0] S_WAIT_FOR_FULL_WRITE_FIFO = 4'd13;
+   localparam [3:0] S_SD_WRITE_WAIT_FOR_DATA   = 4'd14;
+   localparam [3:0] S_IDENTIFY_FILL            = 4'd15;
+   reg 			     io_read_last;
+   reg 			     sd_slave_read_last;
+   reg [8:0] 		     init_cnt;
+   reg [15:0] 		     init_high, init_low;
+   reg 			     init_flag;
+   reg 			     init_we;
+   reg [16:0] 		     media_cylinders;
+   reg [4:0] 		     media_heads;
+   reg [8:0] 		     media_spt;
+   reg [13:0] 		     media_spc; //sectors per cylinder = spt * heads
+   reg [31:0] 		     media_sectors;
+   reg [31:0] 		     media_sd_base;
+   reg 			     status_drq;
+   reg 			     status_busy;
+   reg 			     status_drive_ready;
+   reg 			     status_err;
+   reg [7:0] 		     error_register;
+   reg 			     status_index_pulse_first;
+   reg [3:0] 		     status_index_pulse_counter;
+   reg [7:0] 		     features;
+   reg [16:0] 		     num_sectors;
+   reg [7:0] 		     sector_count;
+   reg [7:0] 		     hob_nsector;
+   reg 			     drive_select;
+   reg 			     disable_irq;
+   reg 			     reset_in_progress;
+   reg [7:0] 		     current_command;
+   reg 			     lba_mode;
+   reg [4:0] 		     multiple_sectors;
+   reg [15:0] 		     cylinder;
+   reg [3:0] 		     head;
+   reg [7:0] 		     sector;
+   reg [7:0] 		     hob_hcyl;
+   reg [7:0] 		     hob_lcyl;
+   reg [7:0] 		     hob_sector;
+   reg [3:0] 		     state;
+   reg [4:0] 		     logical_sector_count;
+   reg [29:0] 		     mult1_a; //cylinder
+   reg [13:0] 		     mult1_b; //media_spc
+   reg [29:0] 		     logical_sector1; //cylinder * media_spc
+   reg [12:0] 		     mult2_a; //head
+   reg [8:0] 		     mult2_b; //media_spt
+   reg [12:0] 		     logical_sector2; //head * media_spt
+   reg [47:0] 		     logical_sector;
+   reg [6:0] 		     sd_counter;
+   reg [31:0] 		     sd_sector;
+   reg 			     sd_read_done;
+   reg [3:0] 		     sd_mutex_wait;
+   reg [6:0] 		     identify_counter;
+   reg [1:0] 		     from_hdd_stored_index;
+   reg [23:0] 		     from_hdd_stored;
+   reg [1:0] 		     to_hdd_stored_index;
+   reg [23:0] 		     to_hdd_stored;
+   wire 		     io_read_valid;
+   wire 		     sd_slave_read_valid;
+   wire 		     write_data_io;
+   wire 		     read_data_io;
+   wire [2:0] 		     data_io_size ;
+   wire [7:0] 		     status_value ;
+   wire [15:0] 		     cylinder_final ;
+   wire [31:0] 		     io_readdata_next ;
+   wire [31:0] 		     init_data;
+   wire [3:0] 		     status_index_pulse_counter_next ;
+   wire 		     sw_reset_start;
+   wire 		     sw_reset_end;
+   wire [16:0] 		     media_cylinders_minus_1 ;
+   wire [27:0] 		     location_lba28_plus_1 ;
+   wire [47:0] 		     location_lba48_plus_1 ;
+   wire [27:0] 		     location_lba28_max ;
+   wire [47:0] 		     location_lba48_max ;
+   wire 		     update_location_to_overflow;
+   wire 		     update_location_to_max;
+   wire 		     update_location_by_one;
+   wire 		     update_location_chs_sector_only;
+   wire 		     update_location_chs_head_only;
+   wire 		     update_location_chs_cylinder_only;
+   wire 		     current_command_lba48;
+   wire 		     cmd_read_in_progress;
+   wire 		     current_command_read_multiple;
+   wire 		     current_command_read_lba48;
+   wire 		     cmd_identify_in_progress;
+   wire 		     cmd_write_in_progress;
+   wire 		     current_command_write_multiple;
+   wire 		     current_command_write_lba48;
+   wire 		     cmd_start;
+   wire 		     cmd_calibrate_start;
+   wire 		     cmd_read_prepare;
+   wire 		     cmd_read_abort_at_start;
+   wire 		     cmd_read_start;
+   wire 		     cmd_write_prepare;
+   wire 		     cmd_write_abort_at_start;
+   wire 		     cmd_write_start;
+   wire 		     write_data_ready;
+   wire 		     cmd_execute_drive_diag;
+   wire 		     cmd_initialize_prepare;
+   wire 		     cmd_initialize_abort_at_start;
+   wire 		     cmd_initialize_start;
+   wire 		     cmd_identify_start;
+   wire 		     cmd_features_prepare;
+   wire 		     cmd_features_abort_at_start;
+   wire 		     cmd_features_start;
+   wire 		     cmd_verify_start;
+   wire 		     cmd_multiple_prepare;
+   wire 		     cmd_multiple_abort_at_start;
+   wire 		     cmd_multiple_start;
+   wire 		     cmd_power_start;
+   wire 		     cmd_checkpower_start;
+   wire 		     cmd_seek_start;
+   wire 		     cmd_seek_in_progress;
+   wire 		     cmd_max_prepare;
+   wire 		     cmd_max_abort_at_start;
+   wire 		     cmd_max_start;
+   wire 		     cmd_unknown_start;
+   wire 		     lba48_transform_active;
+   wire 		     lba48_transform_inactive;
+   wire 		     set_signature;
+   wire 		     drq_zero;
+   wire 		     command_finished;
+   wire 		     command_requires_drq;
+   wire 		     raise_interrupt;
+   wire 		     lower_interrupt;
+   wire 		     command_abort;
+   wire [31:0] 		     sectors_left ;
+   wire [4:0] 		     multiple_final_write ;
+   wire [4:0] 		     multiple_final_read ;
+   wire 		     count_decision_immediate_error;
+   wire [31:0] 		     identify_q;
+   wire [31:0] 		     identify_q_final ;
+   wire [2:0] 		     from_hdd_stored_index_next ;
+   wire [55:0] 		     from_hdd_result ;
+   wire 		     from_hdd_empty_valid;
+   wire 		     from_hdd_empty;
+   wire [31:0] 		     from_hdd_q;
+   wire [55:0] 		     to_hdd_result ;
+   wire [2:0] 		     to_hdd_sum ;
+   wire [11:0] 		     to_hdd_count ;
+   wire [10:0] 		     to_hdd_usedw;
+   wire 		     to_hdd_full;
+   wire [31:0] 		     to_hdd_q;
+   wire 		     _unused_ok;
+
+   //------------------------------------------------------------------------------
+
+   always @(posedge clk) begin if(rst) io_read_last <= 1'b0; else if(io_read_last) io_read_last <= 1'b0; else io_read_last <= io_read; end
+   assign io_read_valid = io_read && io_read_last == 1'b0;
+
+   always @(posedge clk) begin if(rst) sd_slave_read_last <= 1'b0; else if(sd_slave_read_last) sd_slave_read_last <= 1'b0; else sd_slave_read_last <= sd_slave_read; end
+   assign sd_slave_read_valid = sd_slave_read && sd_slave_read_last == 1'b0;
+
+   //------------------------------------------------------------------------------
+
+   assign write_data_io =
+			 io_write && io_address == 1'b0 && io_byteenable[0] &&
+			 cmd_write_in_progress;
+
+   assign read_data_io =
+			io_read_valid && io_address == 1'b0 && io_byteenable[0] && status_drq &&
+			(cmd_read_in_progress || cmd_identify_in_progress);
+
+   assign data_io_size =
+			(io_byteenable[3:0] == 4'b1111)?    3'd4 :
+			(io_byteenable[1:0] == 2'b11)?      3'd2 :
+			(io_byteenable[0])?                 3'd1 :
+			3'd0;
+
+   assign status_value =
+			(drive_select)?     8'h00 :
+			{ status_busy,
+			  status_drive_ready,
+			  1'b0, //status write fault
+			  1'b1, //status seek complete
+			  status_drq,
+			  1'b0, //status data corrected
+			  status_index_pulse_counter == 4'd0 && status_index_pulse_first,
+			  status_err
+			  };
+
+   assign cylinder_final = (drive_select)? 16'hFFFF : cylinder;
+
+   assign io_readdata_next =
+			    (read_data_io)?                                                             from_hdd_result[31:0] :
+			    (io_read_valid && io_address == 1'b0 && io_byteenable[1:0] == 2'b10)?       { 16'd0, error_register, 8'd0 } :
+			    (io_read_valid && io_address == 1'b0 && io_byteenable[2:0] == 3'b100)?      { 8'd0,  sector_count,   16'd0 } :
+			    (io_read_valid && io_address == 1'b0 && io_byteenable[3:0] == 4'b1000)?     { sector, 24'd0 } :
+			    (io_read_valid && io_address == 1'b1 && io_byteenable[0] == 1'b1)?          { 24'd0, cylinder_final[7:0] } :
+			    (io_read_valid && io_address == 1'b1 && io_byteenable[1:0] == 2'b10)?       { 16'd0, cylinder_final[15:8], 8'd0 } :
+			    (io_read_valid && io_address == 1'b1 && io_byteenable[2:0] == 3'b100)?      { 8'd0, 8'h80 | ((lba_mode)? 8'h40 : 8'h00) | 8'h20 | ((drive_select)? 8'h10 : 8'h00) | ((drive_select)? 8'h00 : { 4'd0, head }), 16'd0 } :
+			    (io_read_valid && io_address == 1'b1 && io_byteenable[3:0] == 4'b1000)?     { status_value, 24'd0 } :
+			    32'd0; //used
+
+   always @(posedge clk) begin
+      if(rst)   io_readdata <= 32'b0;
+      else                io_readdata <= io_readdata_next;
+   end
+
+   always @(posedge clk) begin
+      if(rst)   ide_3f6_readdata <= 8'b0;
+      else                ide_3f6_readdata <= status_value;
+   end
+
+   //------------------------------------------------------------------------------ media management
+
+   //------------------------------------------------------------------------------ modified by matsuda
+
+   assign init_data = {init_high, init_low};
+
+   always @(posedge clk) begin
+      if(rst) begin
+	 init_flag <= 1;
+	 init_we <= 0;
+	 init_cnt <= 0;
+      end else begin
+	 if(init_flag) begin
+	    init_we <= 1;
+	    init_cnt <= init_cnt + 1;
+	    case(init_cnt)
+              0: begin
+		 init_low  <= `HDD_GENERAL_CONFIGRATION;
+		 init_high <= `HDD_DEFAULT_NUMBER_OF_CYLINDERS;
+              end
+              1: begin
+		 init_low  <= `HDD_RESERVED0;
+		 init_high <= `HDD_DEFAULT_NUMBER_OF_HEADS;
+              end
+              2: begin
+		 init_low  <= `HDD_SECTOR_CAPACITY;
+		 init_high <= `HDD_TRACK_CAPACITY;
+              end
+              3: begin
+		 init_low  <= `HDD_DEFAULT_NUMBER_OF_SPT;
+		 init_high <= `HDD_MIN_SIZE_OF_ISG;
+              end
+              4: begin
+		 init_low  <= `HDD_RESERVED1;
+		 init_high <= `HDD_MIN_PLO_BYTES;
+              end
+              5: begin
+		 init_low  <= `HDD_SERIAL_NUMBER0; // 'A', 'O'
+		 init_high <= `HDD_SERIAL_NUMBER1; // 'H', 'D'
+              end
+              6: begin
+		 init_low  <= `HDD_SERIAL_NUMBER2; // '0', '0'
+		 init_high <= `HDD_SERIAL_NUMBER3; // '0', '0'
+              end
+              7: begin
+		 init_low  <= `HDD_SERIAL_NUMBER4; // '0', ' '
+		 init_high <= `HDD_SERIAL_NUMBER5; // ' ', ' '
+              end
+              8: begin
+		 init_low  <= `HDD_SERIAL_NUMBER6; // ' ', ' '
+		 init_high <= `HDD_SERIAL_NUMBER7; // ' ', ' '
+              end
+              9: begin
+		 init_low  <= `HDD_SERIAL_NUMBER8; // ' ', ' '
+		 init_high <= `HDD_SERIAL_NUMBER9; // ' ', ' '
+              end
+              10: begin
+		 init_low  <= `HDD_BUFFER_TYPE;
+		 init_high <= `HDD_CACHE_SIZE;
+              end
+              11: begin
+		 init_low  <= `HDD_ECC_BYTES;
+		 init_high <= `HDD_FIRMWARE_REVISION0;
+              end
+              12: begin
+		 init_low  <= `HDD_FIRMWARE_REVISION1;
+		 init_high <= `HDD_FIRMWARE_REVISION2;
+              end
+              13: begin
+		 init_low  <= `HDD_FIRMWARE_REVISION3;
+		 init_high <= `HDD_MODEL_NUMBER0; // 'A', 'O'
+              end
+              14: begin
+		 init_low  <= `HDD_MODEL_NUMBER1; // ' ', 'H'
+		 init_high <= `HDD_MODEL_NUMBER2; // 'a', 'r'
+              end
+              15: begin
+		 init_low  <= `HDD_MODEL_NUMBER3; // 'd', 'd'
+		 init_high <= `HDD_MODEL_NUMBER4; // 'r', 'i'
+              end
+              16: begin
+		 init_low  <= `HDD_MODEL_NUMBER5; // 'v', 'e'
+		 init_high <= `HDD_MODEL_NUMBER6; // ' ', ' '
+              end
+              17: begin
+		 init_low  <= `HDD_MODEL_NUMBER7; // ' ', ' '
+		 init_high <= `HDD_MODEL_NUMBER8; // ' ', ' '
+              end
+              18: begin
+		 init_low  <= `HDD_MODEL_NUMBER9; // ' ', ' '
+		 init_high <= `HDD_MODEL_NUMBER10; // ' ', ' '
+              end
+              19: begin
+		 init_low  <= `HDD_MODEL_NUMBER11; // ' ', ' '
+		 init_high <= `HDD_MODEL_NUMBER12; // ' ', ' '
+              end
+              20: begin
+		 init_low  <= `HDD_MODEL_NUMBER13; // ' ', ' '
+		 init_high <= `HDD_MODEL_NUMBER14; // ' ', ' '
+              end
+              21: begin
+		 init_low  <= `HDD_MODEL_NUMBER15; // ' ', ' '
+		 init_high <= `HDD_MODEL_NUMBER16; // ' ', ' '
+              end
+              22: begin
+		 init_low  <= `HDD_MODEL_NUMBER17; // ' ', ' '
+		 init_high <= `HDD_MODEL_NUMBER18; // ' ', ' '
+              end
+              23: begin
+		 init_low  <= `HDD_MODEL_NUMBER19; // ' ', ' '
+		 init_high <= `HDD_MAX_MULTIPLE_SECTORS;
+              end
+              24: begin
+		 init_low  <= `HDD_DWORD_IO_SUPPORT;
+		 init_high <= `HDD_LBA_SUPPORT;
+              end
+              25: begin
+		 init_low  <= `HDD_RESERVED2;
+		 init_high <= `HDD_PIO_TIMING0;
+              end
+              26: begin
+		 init_low  <= `HDD_PIO_TIMING1;
+		 init_high <= `HDD_VALID_FIELDS;
+              end
+              27: begin
+		 init_low  <= `HDD_CURRENT_NUMBER_OF_CYLINDERS;
+		 init_high <= `HDD_CURRENT_NUMBER_OF_HEADS;
+              end
+              28: begin
+		 init_low  <= `HDD_CURRENT_NUMBER_OF_SPT;
+		 init_high <= `HDD_CURRENT_TOTAL_SECTORS_LOW;
+              end
+              29: begin
+		 init_low  <= `HDD_CURRENT_TOTAL_SECTORS_HIGH;
+		 init_high <= `HDD_CURRENT_MULTIPLE_SECTORS;
+              end
+              30: begin
+		 init_low  <= `HDD_CURRENT_ALLOCATED_SECTORS_LOW;
+		 init_high <= `HDD_CURRENT_ALLOCATED_SECTORS_HIGH;
+              end
+              31: begin
+		 init_low  <= `HDD_SINGLE_WORD_DMA_MODES;
+		 init_high <= `HDD_MULTIPLE_WORD_DMA_MODES;
+              end
+              32: begin
+		 init_low  <= `HDD_PIO_MODES;
+		 init_high <= `HDD_MIN_CYCLE_TIME_OF_MULTIWORD_DMA;
+              end
+              33: begin
+		 init_low  <= `HDD_MIN_CYCLE_TIME_OF_MULTIWORD_DMA_DEVICE;
+		 init_high <= `HDD_MIN_CYCLE_TIME_OF_PIO_WITHOUT_IORDY;
+              end
+              34: begin
+		 init_low  <= `HDD_MIN_CYCLE_TIME_OF_PIO_WITHOUT_IORDY;
+		 init_high <= `HDD_RESERVED3;
+              end
+              35: begin
+		 init_low  <= `HDD_RESERVED4;
+		 init_high <= `HDD_RESERVED5;
+              end
+              36: begin
+		 init_low  <= `HDD_RESERVED6;
+		 init_high <= `HDD_RESERVED7;
+              end
+              37: begin
+		 init_low  <= `HDD_RESERVED8;
+		 init_high <= `HDD_QUEUE_SIZE;
+              end
+              38: begin
+		 init_low  <= `HDD_RESERVED9;
+		 init_high <= `HDD_RESERVED10;
+              end
+              39: begin
+		 init_low  <= `HDD_RESERVED11;
+		 init_high <= `HDD_RESERVED12;
+              end
+              40: begin
+		 init_low  <= `HDD_ATA_MODES;
+		 init_high <= `HDD_MINOR_VERSION_NUMBER;
+              end
+              41: begin
+		 init_low  <= `HDD_COMMANDS_SET0;
+		 init_high <= `HDD_COMMANDS_SET1;
+              end
+              42: begin
+		 init_low  <= `HDD_COMMANDS_SET2;
+		 init_high <= `HDD_COMMANDS_SET3;
+              end
+              43: begin
+		 init_low  <= `HDD_COMMANDS_SET4;
+		 init_high <= `HDD_COMMANDS_SET5;
+              end
+              44: begin
+		 init_low  <= `HDD_ULTRA_DMA_SUPPORT;
+		 init_high <= `HDD_RESERVED13;
+              end
+              45: begin
+		 init_low  <= `HDD_RESERVED14;
+		 init_high <= `HDD_RESERVED15;
+              end
+              46: begin
+		 init_low  <= `HDD_RESERVED16;
+		 init_high <= `HDD_RESULT_OF_HARDWARE_RESET;
+              end
+              47: begin
+		 init_low  <= `HDD_RESERVED17;
+		 init_high <= `HDD_RESERVED17;
+              end
+              48: begin
+		 init_low  <= `HDD_RESERVED17;
+		 init_high <= `HDD_RESERVED17;
+              end
+              49: begin
+		 init_low  <= `HDD_RESERVED17;
+		 init_high <= `HDD_RESERVED17;
+              end
+              50: begin
+		 init_low  <= `HDD_MAX_USER_LBA0;
+		 init_high <= `HDD_MAX_USER_LBA1;
+              end
+              51: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              52: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              53: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              54: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              55: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              56: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              57: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              58: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              59: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              60: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              61: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              62: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              63: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              64: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              65: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              66: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              67: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              68: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              69: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              70: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              71: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              72: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              73: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              74: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              75: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              76: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              77: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              78: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              79: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              80: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              81: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              82: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              83: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              84: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              85: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              86: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              87: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              88: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              89: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              90: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              91: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              92: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              93: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              94: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              95: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              96: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              97: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              98: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              99: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              100: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              101: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              102: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              103: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              104: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              105: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              106: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              107: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              108: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              109: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              110: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              111: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              112: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              113: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              114: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              115: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              116: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              117: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              118: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              119: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              120: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              121: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              122: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              123: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              124: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              125: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              126: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+              end
+              127: begin
+		 init_low  <= `HDD_RESERVED18;
+		 init_high <= `HDD_RESERVED18;
+		 init_flag <= 0;
+              end
+	    endcase
+	 end else begin // if (init_flag)
+	    init_we <= 0;
+	 end
+      end
+   end
+
+
+   always @(posedge clk) begin
+      //   if(rst)                           media_cylinders <= 17'd0;
+      if(rst)                           media_cylinders <= 17'd`HDD_CYLINDERS;
+      else if(mgmt_address == 3'd1 && mgmt_write) media_cylinders <= mgmt_writedata[16:0];
+   end
+
+   always @(posedge clk) begin
+      //    if(rst)                           media_heads <= 5'd0;
+      if(rst)                           media_heads <= 5'd`HDD_HEADS;
+      else if(mgmt_address == 3'd2 && mgmt_write) media_heads <= mgmt_writedata[4:0];
+   end
+
+   always @(posedge clk) begin
+      //    if(rst)                           media_spt <= 9'd0;
+      if(rst)                           media_spt <= 9'd`HDD_SPT;
+      else if(mgmt_address == 3'd3 && mgmt_write) media_spt <= mgmt_writedata[8:0];
+   end
+
+   always @(posedge clk) begin
+      //    if(rst)                           media_spc <= 14'd0; //14'd1008;
+      if(rst)                           media_spc <= `HDD_SPH; //14'd1008;
+      else if(mgmt_address == 3'd4 && mgmt_write) media_spc <= mgmt_writedata[13:0];
+   end
+
+   always @(posedge clk) begin
+      //    if(rst)                           media_sectors <= 32'd0; //32'd1032192;
+      if(rst)                           media_sectors <= `HDD_TOTAL_SECTORS; //32'd1032192;
+      else if(mgmt_address == 3'd5 && mgmt_write) media_sectors <= mgmt_writedata;
+   end
+
+   always @(posedge clk) begin
+      //    if(rst)                           media_sd_base <= 32'd0;
+      if(rst)                           media_sd_base <= 32'd`HDD_SD_BASE;
+      else if(mgmt_address == 3'd6 && mgmt_write) media_sd_base <= mgmt_writedata;
+   end
+
+   //------------------------------------------------------------------------------ modified by matsuda
+
+   //------------------------------------------------------------------------------
+
+   always @(posedge clk) begin
+      if(rst)                                                   status_drq <= 1'b0;
+      else if(sw_reset_start)                                             status_drq <= 1'b0;
+      else if(cmd_read_start || cmd_identify_start || cmd_seek_start)     status_drq <= 1'b0;
+      else if(cmd_execute_drive_diag)                                     status_drq <= 1'b0;
+      else if(cmd_initialize_start)                                       status_drq <= 1'b0;
+      else if(cmd_verify_start)                                           status_drq <= 1'b0;
+      else if(command_requires_drq)                                       status_drq <= 1'b1;
+      else if(command_finished)                                           status_drq <= 1'b0;
+      else if(drq_zero)                                                   status_drq <= 1'b0;
+      else if(command_abort)                                              status_drq <= 1'b0;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                                   status_busy <= 1'b0;
+      else if(sw_reset_start)                                             status_busy <= 1'b1;
+      else if(sw_reset_end)                                               status_busy <= 1'b0;
+      else if(cmd_read_start || cmd_identify_start || cmd_seek_start)     status_busy <= 1'b1;
+      else if(cmd_initialize_start)                                       status_busy <= 1'b0;
+      else if(cmd_verify_start)                                           status_busy <= 1'b0;
+      else if(command_requires_drq)                                       status_busy <= 1'b0;
+      else if(command_finished)                                           status_busy <= 1'b0;
+      else if(drq_zero)                                                   status_busy <= 1'b1;
+      else if(command_abort)                                              status_busy <= 1'b0;
+   end
+
+   always @(posedge clk) begin
+      if(rst)               status_drive_ready <= 1'b1;
+      else if(sw_reset_start)         status_drive_ready <= 1'b0;
+      else if(sw_reset_end)           status_drive_ready <= 1'b1;
+      else if(cmd_initialize_start)   status_drive_ready <= 1'b1;
+      else if(cmd_features_start)     status_drive_ready <= 1'b1;
+      else if(cmd_verify_start)       status_drive_ready <= 1'b1;
+      else if(cmd_max_start)          status_drive_ready <= 1'b1;
+      else if(command_requires_drq)   status_drive_ready <= 1'b1;
+      else if(command_finished)       status_drive_ready <= 1'b1;
+      else if(command_abort)          status_drive_ready <= 1'b1;
+   end
+
+   always @(posedge clk) begin
+      if(rst)               status_err <= 1'b0;
+      else if(sw_reset_start)         status_err <= 1'b0;
+      else if(command_requires_drq)   status_err <= 1'b0;
+      else if(command_abort)          status_err <= 1'b1;
+      else if(command_finished)       status_err <= 1'b0;
+      else if(cmd_start)              status_err <= 1'b0;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                                   error_register <= 8'h01;
+      else if(sw_reset_start)                                             error_register <= 8'h01;
+      else if(cmd_execute_drive_diag)                                     error_register <= 8'h01;
+      else if(cmd_read_start || cmd_identify_start || cmd_seek_start)     error_register <= 8'h00;
+      else if(command_requires_drq)                                       error_register <= 8'h00;
+      else if(command_finished)                                           error_register <= 8'h00;
+      else if(command_abort)                                              error_register <= 8'h04;
+   end
+
+   assign status_index_pulse_counter_next = (status_index_pulse_counter == 4'd9)? 4'd0 : status_index_pulse_counter + 4'd1;
+
+   always @(posedge clk) begin
+      if(rst)                           status_index_pulse_first <= 1'b0;
+      else if(status_index_pulse_counter != 4'd0) status_index_pulse_first <= 1'b1;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                                                                                       status_index_pulse_counter <= 4'd0;
+      else if(~(drive_select) && (ide_3f6_read || (io_read_valid && io_address == 1'b1 && io_byteenable[3:0] == 4'b1000)))    status_index_pulse_counter <= status_index_pulse_counter_next;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                                       features <= 8'h00;
+      else if(io_write && io_address == 1'b0 && io_byteenable[1:0] == 2'b10)  features <= io_writedata[15:8];
+   end
+
+   always @(posedge clk) begin
+      if(rst)                   num_sectors <= 17'd0;
+      else if(lba48_transform_active)     num_sectors <= (sector_count == 8'd0 && hob_nsector == 8'd0)? 17'd65536 : { 1'b0, hob_nsector, sector_count };
+      else if(lba48_transform_inactive)   num_sectors <= (sector_count == 8'd0)? 17'd256 : { 9'd0, sector_count };
+      else if(update_location_by_one)     num_sectors <= num_sectors - 17'd1;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                                           sector_count <= 8'd1;
+      else if(set_signature)                                                      sector_count <= 8'd1;
+      else if(cmd_checkpower_start)                                               sector_count <= 8'hFF;
+      else if(io_write && io_address == 1'b0 && io_byteenable[2:0] == 3'b100)     sector_count <= io_writedata[23:16];
+      else if(update_location_by_one)                                             sector_count <= sector_count - 8'd1;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                                       hob_nsector <= 8'd0;
+      else if(io_write && io_address == 1'b0 && io_byteenable[2:0] == 3'b100) hob_nsector <= sector_count;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                                       drive_select <= 1'b0;
+      else if(set_signature)                                                  drive_select <= 1'b0;
+      else if(io_write && io_address == 1'b1 && io_byteenable[2:0] == 3'b100) drive_select <= io_writedata[20];
+   end
+
+   always @(posedge clk) begin
+      if(rst)       disable_irq <= 1'b0;
+      else if(sw_reset_start) disable_irq <= 1'b0;
+      else if(ide_3f6_write)  disable_irq <= ide_3f6_writedata[1];
+   end
+
+   assign sw_reset_start = ide_3f6_write && ide_3f6_writedata[2];
+   assign sw_reset_end = ide_3f6_write && ~(ide_3f6_writedata[2]) && reset_in_progress;
+
+   always @(posedge clk) begin
+      if(rst)       reset_in_progress <= 1'b0;
+      else if(ide_3f6_write)  reset_in_progress <= ide_3f6_writedata[2];
+   end
+
+   always @(posedge clk) begin
+      if(rst)                           irq <= 1'b0;
+      else if(sw_reset_start)                     irq <= 1'b0;
+      else if(raise_interrupt && ~(disable_irq))  irq <= 1'b1; //raise more important than lower
+      else if(lower_interrupt)                    irq <= 1'b0;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                                                   current_command <= 8'b0;
+      else if(sw_reset_start)                                                             current_command <= 8'b0;
+      else if(cmd_read_start || cmd_write_start || cmd_identify_start || cmd_seek_start)  current_command <= io_writedata[31:24];
+      else if(state == S_IDLE)                                                            current_command <= 8'd0;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                                       lba_mode <= 1'b0;
+      else if(sw_reset_start)                                                 lba_mode <= 1'b0;
+      else if(io_write && io_address == 1'b1 && io_byteenable[2:0] == 3'b100) lba_mode <= io_writedata[22];
+   end
+
+   always @(posedge clk) begin
+      if(rst)           multiple_sectors <= 5'd0;
+      else if(sw_reset_start)     multiple_sectors <= 5'd0;
+      else if(cmd_multiple_start) multiple_sectors <= sector_count[4:0];
+   end
+
+   //------------------------------------------------------------------------------
+
+   assign media_cylinders_minus_1 = media_cylinders - 17'd1;
+
+   always @(posedge clk) begin
+      if(rst)                                                                           cylinder <= 16'd0;
+      else if(set_signature)                                                                      cylinder <= 16'd0;
+      else if(io_write && io_address == 1'b1 && io_byteenable[0] == 1'b1)                         cylinder <= { cylinder[15:8], io_writedata[7:0] };
+      else if(io_write && io_address == 1'b1 && io_byteenable[1:0] == 2'b10)                      cylinder <= { io_writedata[15:8], cylinder[7:0] };
+      else if(update_location_to_overflow)                                                        cylinder <= media_sectors[23:8];
+      else if(update_location_by_one && lba_mode && current_command_lba48)                        cylinder <= location_lba48_plus_1[23:8];
+      else if(update_location_by_one && lba_mode)                                                 cylinder <= location_lba28_plus_1[23:8];
+
+      else if(update_location_to_max && lba_mode && current_command_lba48)                        cylinder <= location_lba48_max[23:8];
+      else if(update_location_to_max && lba_mode)                                                 cylinder <= location_lba28_max[23:8];
+
+      else if(update_location_chs_cylinder_only && { 1'b0, cylinder } < media_cylinders - 17'd1)  cylinder <= cylinder + 16'd1;
+      else if(update_location_chs_cylinder_only)                                                  cylinder <= media_cylinders_minus_1[15:0];
+      else if(cmd_calibrate_start)                                                                cylinder <= 16'd0;
+   end
+
+   always @(posedge clk) begin
+      if(rst)   head <= 4'd0;
+      else if(set_signature)                                                      head <= 4'd0;
+      else if(io_write && io_address == 1'b1 && io_byteenable[2:0] == 3'b100)     head <= io_writedata[19:16];
+      else if(update_location_to_overflow && ~(current_command_read_lba48))       head <= media_sectors[27:24];
+      else if(update_location_by_one && lba_mode && ~(current_command_lba48))     head <= location_lba28_plus_1[27:24];
+      else if(update_location_to_max && lba_mode && ~(current_command_lba48))     head <= location_lba28_max[27:24];
+      else if(update_location_chs_head_only)                                      head <= head + 4'd1;
+      else if(update_location_chs_cylinder_only)                                  head <= 4'd0;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                                           sector <= 8'd1;
+      else if(set_signature)                                                      sector <= 8'd1;
+      else if(io_write && io_address == 1'b0 && io_byteenable[3:0] == 4'b1000)    sector <= io_writedata[31:24];
+      else if(update_location_to_overflow)                                        sector <= media_sectors[7:0];
+      else if(update_location_by_one && lba_mode && current_command_lba48)        sector <= location_lba48_plus_1[7:0];
+      else if(update_location_by_one && lba_mode)                                 sector <= location_lba28_plus_1[7:0];
+      else if(update_location_to_max && lba_mode && current_command_lba48)        sector <= location_lba48_max[7:0];
+      else if(update_location_to_max && lba_mode)                                 sector <= location_lba28_max[7:0];
+      else if(update_location_chs_sector_only)                                    sector <= sector + 8'd1;
+      else if(update_location_chs_head_only || update_location_chs_cylinder_only) sector <= 8'd1;
+   end
+
+   always @(posedge clk) begin
+      if(rst)   hob_hcyl <= 8'd0;
+      else if(io_write && io_address == 1'b1 && io_byteenable[1:0] == 2'b10)      hob_hcyl <= cylinder[15:8];
+      else if(update_location_to_overflow && current_command_read_lba48)          hob_hcyl <= 8'd0;
+      else if(update_location_by_one && lba_mode && current_command_lba48)        hob_hcyl <= location_lba48_plus_1[47:40];
+      else if(update_location_to_max && lba_mode && current_command_lba48)        hob_hcyl <= location_lba48_max[47:40];
+   end
+
+   always @(posedge clk) begin
+      if(rst)   hob_lcyl <= 8'd0;
+      else if(io_write && io_address == 1'b1 && io_byteenable[0] == 1'b1)         hob_lcyl <= cylinder[7:0];
+      else if(update_location_to_overflow && current_command_read_lba48)          hob_lcyl <= 8'd0;
+      else if(update_location_by_one && lba_mode && current_command_lba48)        hob_lcyl <= location_lba48_plus_1[39:32];
+      else if(update_location_to_max && lba_mode && current_command_lba48)        hob_lcyl <= location_lba48_max[39:32];
+   end
+
+   always @(posedge clk) begin
+      if(rst)   hob_sector <= 8'd0;
+      else if(io_write && io_address == 1'b0 && io_byteenable[3:0] == 4'b1000)    hob_sector <= sector;
+      else if(update_location_to_overflow && current_command_read_lba48)          hob_sector <= media_sectors[31:24];
+      else if(update_location_by_one && lba_mode && current_command_lba48)        hob_sector <= location_lba48_plus_1[31:24];
+      else if(update_location_to_max && lba_mode && current_command_lba48)        hob_sector <= location_lba48_max[31:24];
+   end
+
+   assign location_lba28_plus_1 = { head, cylinder, sector } + 28'd1;
+   assign location_lba48_plus_1 = { hob_hcyl, hob_lcyl, hob_sector, cylinder, sector } + 48'd1;
+
+   assign location_lba28_max = (media_sectors[31:28] != 4'd0)? 28'hFFFFFFF : media_sectors[27:0] - 28'd1;
+   assign location_lba48_max = { 16'd0, media_sectors - 32'd1 };
+
+   //------------------------------------------------------------------------------ update location
+
+   assign update_location_to_overflow =
+				       state == S_COUNT_DECISION && logical_sector[47:32] == 16'd0 && logical_sector[31:0] < media_sectors &&
+				       current_command_read_multiple && lba_mode && (current_command_read_lba48 || media_sectors[31:28] == 4'd0) &&
+				       (logical_sector[31:0] + { 27'd0, multiple_final_read }) > media_sectors;
+
+   assign update_location_to_max = cmd_max_start;
 
-//------------------------------------------------------------------------------
-
-reg io_read_last;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) io_read_last <= 1'b0; else if(io_read_last) io_read_last <= 1'b0; else io_read_last <= io_read; end 
-wire io_read_valid = io_read && io_read_last == 1'b0;
-
-reg sd_slave_read_last;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) sd_slave_read_last <= 1'b0; else if(sd_slave_read_last) sd_slave_read_last <= 1'b0; else sd_slave_read_last <= sd_slave_read; end 
-wire sd_slave_read_valid = sd_slave_read && sd_slave_read_last == 1'b0;
-
-//------------------------------------------------------------------------------
-
-wire write_data_io =
-    io_write && io_address == 1'b0 && io_byteenable[0] &&
-    cmd_write_in_progress;
-
-wire read_data_io =
-    io_read_valid && io_address == 1'b0 && io_byteenable[0] && status_drq &&
-    (cmd_read_in_progress || cmd_identify_in_progress);
-
-wire [2:0] data_io_size =
-    (io_byteenable[3:0] == 4'b1111)?    3'd4 :
-    (io_byteenable[1:0] == 2'b11)?      3'd2 :
-    (io_byteenable[0])?                 3'd1 :
-                                        3'd0;
-
-wire [7:0] status_value =
-    (drive_select)?     8'h00 :
-                        { status_busy,
-                          status_drive_ready,
-                          1'b0, //status write fault
-                          1'b1, //status seek complete
-                          status_drq,
-                          1'b0, //status data corrected
-                          status_index_pulse_counter == 4'd0 && status_index_pulse_first,
-                          status_err
-                        };
-
-wire [15:0] cylinder_final = (drive_select)? 16'hFFFF : cylinder;
-
-wire [31:0] io_readdata_next =
-    (read_data_io)?                                                             from_hdd_result[31:0] :
-    (io_read_valid && io_address == 1'b0 && io_byteenable[1:0] == 2'b10)?       { 16'd0, error_register, 8'd0 } :
-    (io_read_valid && io_address == 1'b0 && io_byteenable[2:0] == 3'b100)?      { 8'd0,  sector_count,   16'd0 } :
-    (io_read_valid && io_address == 1'b0 && io_byteenable[3:0] == 4'b1000)?     { sector, 24'd0 } :
-    (io_read_valid && io_address == 1'b1 && io_byteenable[0] == 1'b1)?          { 24'd0, cylinder_final[7:0] } :
-    (io_read_valid && io_address == 1'b1 && io_byteenable[1:0] == 2'b10)?       { 16'd0, cylinder_final[15:8], 8'd0 } :
-    (io_read_valid && io_address == 1'b1 && io_byteenable[2:0] == 3'b100)?      { 8'd0, 8'h80 | ((lba_mode)? 8'h40 : 8'h00) | 8'h20 | ((drive_select)? 8'h10 : 8'h00) | ((drive_select)? 8'h00 : { 4'd0, head }), 16'd0 } :
-    (io_read_valid && io_address == 1'b1 && io_byteenable[3:0] == 4'b1000)?     { status_value, 24'd0 } :
-                                                                                32'd0; //used
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   io_readdata <= 32'b0;
-    else                io_readdata <= io_readdata_next;
-end
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   ide_3f6_readdata <= 8'b0;
-    else                ide_3f6_readdata <= status_value;
-end
-
-//------------------------------------------------------------------------------ media management
-
-reg [16:0] media_cylinders;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_cylinders <= 17'd0;
-    else if(mgmt_address == 3'd1 && mgmt_write) media_cylinders <= mgmt_writedata[16:0];
-end
-
-reg [4:0] media_heads;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_heads <= 5'd0;
-    else if(mgmt_address == 3'd2 && mgmt_write) media_heads <= mgmt_writedata[4:0];
-end
-
-reg [8:0] media_spt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_spt <= 9'd0;
-    else if(mgmt_address == 3'd3 && mgmt_write) media_spt <= mgmt_writedata[8:0];
-end
-
-reg [13:0] media_spc; //sectors per cylinder = spt * heads
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_spc <= 14'd0; //14'd1008;
-    else if(mgmt_address == 3'd4 && mgmt_write) media_spc <= mgmt_writedata[13:0];
-end
-
-reg [31:0] media_sectors;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_sectors <= 32'd0; //32'd1032192;
-    else if(mgmt_address == 3'd5 && mgmt_write) media_sectors <= mgmt_writedata;
-end
-
-reg [31:0] media_sd_base;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           media_sd_base <= 32'd0;
-    else if(mgmt_address == 3'd6 && mgmt_write) media_sd_base <= mgmt_writedata;
-end
-
-//------------------------------------------------------------------------------
-
-reg status_drq;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   status_drq <= 1'b0;
-    else if(sw_reset_start)                                             status_drq <= 1'b0;
-    else if(cmd_read_start || cmd_identify_start || cmd_seek_start)     status_drq <= 1'b0;
-    else if(cmd_execute_drive_diag)                                     status_drq <= 1'b0;
-    else if(cmd_initialize_start)                                       status_drq <= 1'b0;
-    else if(cmd_verify_start)                                           status_drq <= 1'b0;
-    else if(command_requires_drq)                                       status_drq <= 1'b1;
-    else if(command_finished)                                           status_drq <= 1'b0;
-    else if(drq_zero)                                                   status_drq <= 1'b0;
-    else if(command_abort)                                              status_drq <= 1'b0;
-end
-
-reg status_busy;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   status_busy <= 1'b0;
-    else if(sw_reset_start)                                             status_busy <= 1'b1;
-    else if(sw_reset_end)                                               status_busy <= 1'b0;
-    else if(cmd_read_start || cmd_identify_start || cmd_seek_start)     status_busy <= 1'b1;
-    else if(cmd_initialize_start)                                       status_busy <= 1'b0;
-    else if(cmd_verify_start)                                           status_busy <= 1'b0;
-    else if(command_requires_drq)                                       status_busy <= 1'b0;
-    else if(command_finished)                                           status_busy <= 1'b0;
-    else if(drq_zero)                                                   status_busy <= 1'b1;
-    else if(command_abort)                                              status_busy <= 1'b0;
-end
-
-reg status_drive_ready;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               status_drive_ready <= 1'b1;
-    else if(sw_reset_start)         status_drive_ready <= 1'b0;
-    else if(sw_reset_end)           status_drive_ready <= 1'b1;
-    else if(cmd_initialize_start)   status_drive_ready <= 1'b1;
-    else if(cmd_features_start)     status_drive_ready <= 1'b1;
-    else if(cmd_verify_start)       status_drive_ready <= 1'b1;
-    else if(cmd_max_start)          status_drive_ready <= 1'b1;
-    else if(command_requires_drq)   status_drive_ready <= 1'b1;
-    else if(command_finished)       status_drive_ready <= 1'b1;
-    else if(command_abort)          status_drive_ready <= 1'b1;
-end
-
-reg status_err;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)               status_err <= 1'b0;
-    else if(sw_reset_start)         status_err <= 1'b0;
-    else if(command_requires_drq)   status_err <= 1'b0;
-    else if(command_abort)          status_err <= 1'b1;
-    else if(command_finished)       status_err <= 1'b0;
-    else if(cmd_start)              status_err <= 1'b0;
-end
-
-reg [7:0] error_register;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   error_register <= 8'h01;
-    else if(sw_reset_start)                                             error_register <= 8'h01;
-    else if(cmd_execute_drive_diag)                                     error_register <= 8'h01;
-    else if(cmd_read_start || cmd_identify_start || cmd_seek_start)     error_register <= 8'h00;
-    else if(command_requires_drq)                                       error_register <= 8'h00;
-    else if(command_finished)                                           error_register <= 8'h00;
-    else if(command_abort)                                              error_register <= 8'h04;
-end
-
-wire [3:0] status_index_pulse_counter_next = (status_index_pulse_counter == 4'd9)? 4'd0 : status_index_pulse_counter + 4'd1;
-
-reg status_index_pulse_first;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           status_index_pulse_first <= 1'b0;
-    else if(status_index_pulse_counter != 4'd0) status_index_pulse_first <= 1'b1;
-end
-
-reg [3:0] status_index_pulse_counter;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                                       status_index_pulse_counter <= 4'd0;
-    else if(~(drive_select) && (ide_3f6_read || (io_read_valid && io_address == 1'b1 && io_byteenable[3:0] == 4'b1000)))    status_index_pulse_counter <= status_index_pulse_counter_next;
-end
-
-reg [7:0] features;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       features <= 8'h00;
-    else if(io_write && io_address == 1'b0 && io_byteenable[1:0] == 2'b10)  features <= io_writedata[15:8];
-end
-
-reg [16:0] num_sectors;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   num_sectors <= 17'd0;
-    else if(lba48_transform_active)     num_sectors <= (sector_count == 8'd0 && hob_nsector == 8'd0)? 17'd65536 : { 1'b0, hob_nsector, sector_count };
-    else if(lba48_transform_inactive)   num_sectors <= (sector_count == 8'd0)? 17'd256 : { 9'd0, sector_count };
-    else if(update_location_by_one)     num_sectors <= num_sectors - 17'd1;
-end
-
-reg [7:0] sector_count;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           sector_count <= 8'd1;
-    else if(set_signature)                                                      sector_count <= 8'd1;
-    else if(cmd_checkpower_start)                                               sector_count <= 8'hFF;
-    else if(io_write && io_address == 1'b0 && io_byteenable[2:0] == 3'b100)     sector_count <= io_writedata[23:16];
-    else if(update_location_by_one)                                             sector_count <= sector_count - 8'd1;
-end
-
-reg [7:0] hob_nsector;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       hob_nsector <= 8'd0;
-    else if(io_write && io_address == 1'b0 && io_byteenable[2:0] == 3'b100) hob_nsector <= sector_count;
-end
-
-reg drive_select;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       drive_select <= 1'b0;
-    else if(set_signature)                                                  drive_select <= 1'b0;
-    else if(io_write && io_address == 1'b1 && io_byteenable[2:0] == 3'b100) drive_select <= io_writedata[20];
-end
-
-reg disable_irq;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       disable_irq <= 1'b0;
-    else if(sw_reset_start) disable_irq <= 1'b0;
-    else if(ide_3f6_write)  disable_irq <= ide_3f6_writedata[1];
-end
-
-wire sw_reset_start = ide_3f6_write && ide_3f6_writedata[2];
-wire sw_reset_end   = ide_3f6_write && ~(ide_3f6_writedata[2]) && reset_in_progress;
-
-reg reset_in_progress;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       reset_in_progress <= 1'b0;
-    else if(ide_3f6_write)  reset_in_progress <= ide_3f6_writedata[2];
-end
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           irq <= 1'b0;
-    else if(sw_reset_start)                     irq <= 1'b0;
-    else if(raise_interrupt && ~(disable_irq))  irq <= 1'b1; //raise more important than lower
-    else if(lower_interrupt)                    irq <= 1'b0;
-end
-
-reg [7:0] current_command;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                   current_command <= 8'b0;
-    else if(sw_reset_start)                                                             current_command <= 8'b0;
-    else if(cmd_read_start || cmd_write_start || cmd_identify_start || cmd_seek_start)  current_command <= io_writedata[31:24];
-    else if(state == S_IDLE)                                                            current_command <= 8'd0;
-end
-
-reg lba_mode;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       lba_mode <= 1'b0;
-    else if(sw_reset_start)                                                 lba_mode <= 1'b0;
-    else if(io_write && io_address == 1'b1 && io_byteenable[2:0] == 3'b100) lba_mode <= io_writedata[22];
-end
-
-reg [4:0] multiple_sectors;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           multiple_sectors <= 5'd0;
-    else if(sw_reset_start)     multiple_sectors <= 5'd0;
-    else if(cmd_multiple_start) multiple_sectors <= sector_count[4:0];
-end
-
-//------------------------------------------------------------------------------
-
-wire [16:0] media_cylinders_minus_1 = media_cylinders - 17'd1;
-
-reg [15:0] cylinder;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                           cylinder <= 16'd0;
-    else if(set_signature)                                                                      cylinder <= 16'd0;
-    else if(io_write && io_address == 1'b1 && io_byteenable[0] == 1'b1)                         cylinder <= { cylinder[15:8], io_writedata[7:0] };
-    else if(io_write && io_address == 1'b1 && io_byteenable[1:0] == 2'b10)                      cylinder <= { io_writedata[15:8], cylinder[7:0] };
-    else if(update_location_to_overflow)                                                        cylinder <= media_sectors[23:8];
-    else if(update_location_by_one && lba_mode && current_command_lba48)                        cylinder <= location_lba48_plus_1[23:8];
-    else if(update_location_by_one && lba_mode)                                                 cylinder <= location_lba28_plus_1[23:8];
-    
-    else if(update_location_to_max && lba_mode && current_command_lba48)                        cylinder <= location_lba48_max[23:8];
-    else if(update_location_to_max && lba_mode)                                                 cylinder <= location_lba28_max[23:8];
-    
-    else if(update_location_chs_cylinder_only && { 1'b0, cylinder } < media_cylinders - 17'd1)  cylinder <= cylinder + 16'd1;
-    else if(update_location_chs_cylinder_only)                                                  cylinder <= media_cylinders_minus_1[15:0];
-    else if(cmd_calibrate_start)                                                                cylinder <= 16'd0;
-end
-
-reg [3:0] head;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   head <= 4'd0;
-    else if(set_signature)                                                      head <= 4'd0;
-    else if(io_write && io_address == 1'b1 && io_byteenable[2:0] == 3'b100)     head <= io_writedata[19:16];
-    else if(update_location_to_overflow && ~(current_command_read_lba48))       head <= media_sectors[27:24];
-    else if(update_location_by_one && lba_mode && ~(current_command_lba48))     head <= location_lba28_plus_1[27:24];
-    else if(update_location_to_max && lba_mode && ~(current_command_lba48))     head <= location_lba28_max[27:24];
-    else if(update_location_chs_head_only)                                      head <= head + 4'd1;
-    else if(update_location_chs_cylinder_only)                                  head <= 4'd0;
-end
-
-reg [7:0] sector;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           sector <= 8'd1;
-    else if(set_signature)                                                      sector <= 8'd1;
-    else if(io_write && io_address == 1'b0 && io_byteenable[3:0] == 4'b1000)    sector <= io_writedata[31:24];
-    else if(update_location_to_overflow)                                        sector <= media_sectors[7:0];
-    else if(update_location_by_one && lba_mode && current_command_lba48)        sector <= location_lba48_plus_1[7:0];
-    else if(update_location_by_one && lba_mode)                                 sector <= location_lba28_plus_1[7:0];
-    else if(update_location_to_max && lba_mode && current_command_lba48)        sector <= location_lba48_max[7:0];
-    else if(update_location_to_max && lba_mode)                                 sector <= location_lba28_max[7:0];
-    else if(update_location_chs_sector_only)                                    sector <= sector + 8'd1;
-    else if(update_location_chs_head_only || update_location_chs_cylinder_only) sector <= 8'd1;
-end
-
-reg [7:0] hob_hcyl;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   hob_hcyl <= 8'd0;
-    else if(io_write && io_address == 1'b1 && io_byteenable[1:0] == 2'b10)      hob_hcyl <= cylinder[15:8];
-    else if(update_location_to_overflow && current_command_read_lba48)          hob_hcyl <= 8'd0;
-    else if(update_location_by_one && lba_mode && current_command_lba48)        hob_hcyl <= location_lba48_plus_1[47:40];
-    else if(update_location_to_max && lba_mode && current_command_lba48)        hob_hcyl <= location_lba48_max[47:40];
-end
-
-reg [7:0] hob_lcyl;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   hob_lcyl <= 8'd0;
-    else if(io_write && io_address == 1'b1 && io_byteenable[0] == 1'b1)         hob_lcyl <= cylinder[7:0];
-    else if(update_location_to_overflow && current_command_read_lba48)          hob_lcyl <= 8'd0;
-    else if(update_location_by_one && lba_mode && current_command_lba48)        hob_lcyl <= location_lba48_plus_1[39:32];
-    else if(update_location_to_max && lba_mode && current_command_lba48)        hob_lcyl <= location_lba48_max[39:32];
-end
-
-reg [7:0] hob_sector;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   hob_sector <= 8'd0;
-    else if(io_write && io_address == 1'b0 && io_byteenable[3:0] == 4'b1000)    hob_sector <= sector;
-    else if(update_location_to_overflow && current_command_read_lba48)          hob_sector <= media_sectors[31:24];
-    else if(update_location_by_one && lba_mode && current_command_lba48)        hob_sector <= location_lba48_plus_1[31:24];
-    else if(update_location_to_max && lba_mode && current_command_lba48)        hob_sector <= location_lba48_max[31:24];
-end
-
-wire [27:0] location_lba28_plus_1 = { head, cylinder, sector } + 28'd1;
-wire [47:0] location_lba48_plus_1 = { hob_hcyl, hob_lcyl, hob_sector, cylinder, sector } + 48'd1;
-
-wire [27:0] location_lba28_max = (media_sectors[31:28] != 4'd0)? 28'hFFFFFFF : media_sectors[27:0] - 28'd1; 
-wire [47:0] location_lba48_max = { 16'd0, media_sectors - 32'd1 };
-
-//------------------------------------------------------------------------------ update location
-
-wire update_location_to_overflow =
-    state == S_COUNT_DECISION && logical_sector[47:32] == 16'd0 && logical_sector[31:0] < media_sectors &&
-    current_command_read_multiple && lba_mode && (current_command_read_lba48 || media_sectors[31:28] == 4'd0) &&
-    (logical_sector[31:0] + { 27'd0, multiple_final_read }) > media_sectors;
-
-wire update_location_to_max = cmd_max_start;
-
-wire update_location_by_one =
-    (state == S_SD_READ_WAIT_FOR_DATA && sd_slave_write && sd_counter == 7'd127) ||
-    (state == S_SD_WRITE_WAIT_FOR_DATA && sd_slave_read_valid && sd_counter == 7'd127); 
-
-wire update_location_chs_sector_only = update_location_by_one && ~(lba_mode) &&
-    { 1'b0, sector } < media_spt;
-    
-wire update_location_chs_head_only = update_location_by_one && ~(lba_mode) &&
-    { 1'b0, sector } == media_spt && { 1'b0, head } < media_heads - 5'd1;
-    
-wire update_location_chs_cylinder_only = update_location_by_one && ~(lba_mode) &&
-    { 1'b0, sector } == media_spt && { 1'b0, head } == media_heads - 5'd1;
-
-//------------------------------------------------------------------------------ current command
-
-wire current_command_lba48 = current_command_read_lba48 || current_command_write_lba48 ||
-    (cmd_max_start && io_writedata[31:24] == 8'h27);
-
-wire cmd_read_in_progress          = current_command == 8'h24 || current_command == 8'h29 || current_command == 8'h20 || current_command == 8'h21 || current_command == 8'hC4;
-wire current_command_read_multiple = current_command == 8'hC4 || current_command == 8'h29;
-wire current_command_read_lba48    = current_command == 8'h24 || current_command == 8'h29;
-
-wire cmd_identify_in_progress = current_command == 8'hEC || current_command == 8'hA1;
-
-wire cmd_write_in_progress          = current_command == 8'h30 || current_command == 8'hC5 || current_command == 8'h34 || current_command == 8'h39;
-wire current_command_write_multiple = current_command == 8'hC5 || current_command == 8'h39;
-wire current_command_write_lba48    = current_command == 8'h34 || current_command == 8'h39;
-    
-//------------------------------------------------------------------------------ command
-
-wire cmd_start =
-    io_write && io_address == 1'b1 && io_byteenable[3:0] == 4'b1000 && ~(drive_select) && ~(status_busy);
-    
-//calibrate
-wire cmd_calibrate_start = cmd_start && io_writedata[31:24] >= 8'h10 && io_writedata[31:24] <= 8'h1F;
-
-//read
-wire cmd_read_prepare = cmd_start && (io_writedata[31:24] == 8'h24 || io_writedata[31:24] == 8'h29 || io_writedata[31:24] == 8'h20 || io_writedata[31:24] == 8'h21 || io_writedata[31:24] == 8'hC4);
-
-wire cmd_read_abort_at_start = cmd_read_prepare && (
-    (~(lba_mode) && head == 4'd0 && cylinder == 16'd0 && sector == 8'd0) ||
-    ((io_writedata[31:24] == 8'hC4 || io_writedata[31:24] == 8'h29) && multiple_sectors == 5'd0)
-);
-
-wire cmd_read_start = cmd_read_prepare && ~(cmd_read_abort_at_start);
-
-//write
-wire cmd_write_prepare = cmd_start && (io_writedata[31:24] == 8'h30 || io_writedata[31:24] == 8'hC5 || io_writedata[31:24] == 8'h34 || io_writedata[31:24] == 8'h39);
-
-wire cmd_write_abort_at_start = cmd_write_prepare && (
-    ((io_writedata[31:24] == 8'hC5 || io_writedata[31:24] == 8'h39) && multiple_sectors == 5'd0)
-);
+   assign update_location_by_one =
+				  (state == S_SD_READ_WAIT_FOR_DATA && sd_slave_write && sd_counter == 7'd127) ||
+				  (state == S_SD_WRITE_WAIT_FOR_DATA && sd_slave_read_valid && sd_counter == 7'd127);
 
-wire cmd_write_start = cmd_write_prepare && ~(cmd_write_abort_at_start);
+   assign update_location_chs_sector_only = update_location_by_one && ~(lba_mode) &&
+					    { 1'b0, sector } < media_spt;
 
-wire write_data_ready =
-    (current_command_write_multiple    && to_hdd_count >= { multiple_final_read, 7'd0 }) ||
-    (~(current_command_write_multiple) && to_hdd_count >= 12'd128);
+   assign update_location_chs_head_only = update_location_by_one && ~(lba_mode) &&
+					  { 1'b0, sector } == media_spt && { 1'b0, head } < media_heads - 5'd1;
 
-//diag
-wire cmd_execute_drive_diag = cmd_start && io_writedata[31:24] == 8'h90;
+   assign update_location_chs_cylinder_only = update_location_by_one && ~(lba_mode) &&
+					      { 1'b0, sector } == media_spt && { 1'b0, head } == media_heads - 5'd1;
 
-//initialize
-wire cmd_initialize_prepare = cmd_start && io_writedata[31:24] == 8'h91;
+   //------------------------------------------------------------------------------ current command
 
-wire cmd_initialize_abort_at_start = cmd_initialize_prepare && (
-    ({ 1'b0, sector_count } != media_spt) ||
-    (head != 4'd0 && { 1'b0, head } != media_heads - 5'd1)
-);
+   assign current_command_lba48 = current_command_read_lba48 || current_command_write_lba48 ||
+				  (cmd_max_start && io_writedata[31:24] == 8'h27);
 
-wire cmd_initialize_start = cmd_initialize_prepare && ~(cmd_initialize_abort_at_start);
+   assign cmd_read_in_progress = current_command == 8'h24 || current_command == 8'h29 || current_command == 8'h20 || current_command == 8'h21 || current_command == 8'hC4;
+   assign current_command_read_multiple = current_command == 8'hC4 || current_command == 8'h29;
+   assign current_command_read_lba48 = current_command == 8'h24 || current_command == 8'h29;
 
-//identify
-wire cmd_identify_start = cmd_start && io_writedata[31:24] == 8'hEC;
+   assign cmd_identify_in_progress = current_command == 8'hEC || current_command == 8'hA1;
 
-//set features
-wire cmd_features_prepare = cmd_start && io_writedata[31:24] == 8'hEF;
+   assign cmd_write_in_progress = current_command == 8'h30 || current_command == 8'hC5 || current_command == 8'h34 || current_command == 8'h39;
+   assign current_command_write_multiple = current_command == 8'hC5 || current_command == 8'h39;
+   assign current_command_write_lba48 = current_command == 8'h34 || current_command == 8'h39;
 
-wire cmd_features_abort_at_start = cmd_features_prepare && (
-    (features == 8'h03 && (sector_count[7:3] != 5'd0 && sector_count[7:3] != 5'd1 && sector_count[7:3] != 5'd4 && sector_count[7:3] != 5'd8)) ||
-    (features != 8'h03 && features != 8'h02 && features != 8'h82 && features != 8'hAA && features != 8'h55 && features != 8'hCC && features != 8'h66)
-);
+   //------------------------------------------------------------------------------ command
 
-wire cmd_features_start = cmd_features_prepare && ~(cmd_features_abort_at_start);
+   assign cmd_start =
+		     io_write && io_address == 1'b1 && io_byteenable[3:0] == 4'b1000 && ~(drive_select) && ~(status_busy);
 
-//read verify sectors
-wire cmd_verify_start = cmd_start && (io_writedata[31:24] == 8'h40 || io_writedata[31:24] == 8'h41 || io_writedata[31:24] == 8'h42);
+   //calibrate
+   assign cmd_calibrate_start = cmd_start && io_writedata[31:24] >= 8'h10 && io_writedata[31:24] <= 8'h1F;
 
-//set multiple
+   //read
+   assign cmd_read_prepare = cmd_start && (io_writedata[31:24] == 8'h24 || io_writedata[31:24] == 8'h29 || io_writedata[31:24] == 8'h20 || io_writedata[31:24] == 8'h21 || io_writedata[31:24] == 8'hC4);
 
-//if changed - fix cmd_multiple_abort_at_start
-`define MAX_MULTIPLE_SECTORS 16
+   assign cmd_read_abort_at_start = cmd_read_prepare && (
+							 (~(lba_mode) && head == 4'd0 && cylinder == 16'd0 && sector == 8'd0) ||
+							 ((io_writedata[31:24] == 8'hC4 || io_writedata[31:24] == 8'h29) && multiple_sectors == 5'd0)
+							 );
+
+   assign cmd_read_start = cmd_read_prepare && ~(cmd_read_abort_at_start);
+
+   //write
+   assign cmd_write_prepare = cmd_start && (io_writedata[31:24] == 8'h30 || io_writedata[31:24] == 8'hC5 || io_writedata[31:24] == 8'h34 || io_writedata[31:24] == 8'h39);
+
+   assign cmd_write_abort_at_start = cmd_write_prepare && (
+							   ((io_writedata[31:24] == 8'hC5 || io_writedata[31:24] == 8'h39) && multiple_sectors == 5'd0)
+							   );
+
+   assign cmd_write_start = cmd_write_prepare && ~(cmd_write_abort_at_start);
+
+   assign write_data_ready =
+			    (current_command_write_multiple    && to_hdd_count >= { multiple_final_read, 7'd0 }) ||
+			    (~(current_command_write_multiple) && to_hdd_count >= 12'd128);
+
+   //diag
+   assign cmd_execute_drive_diag = cmd_start && io_writedata[31:24] == 8'h90;
+
+   //initialize
+   assign cmd_initialize_prepare = cmd_start && io_writedata[31:24] == 8'h91;
+
+   assign cmd_initialize_abort_at_start = cmd_initialize_prepare && (
+								     ({ 1'b0, sector_count } != media_spt) ||
+								     (head != 4'd0 && { 1'b0, head } != media_heads - 5'd1)
+								     );
+
+   assign cmd_initialize_start = cmd_initialize_prepare && ~(cmd_initialize_abort_at_start);
+
+   //identify
+   assign cmd_identify_start = cmd_start && io_writedata[31:24] == 8'hEC;
+
+   //set features
+   assign cmd_features_prepare = cmd_start && io_writedata[31:24] == 8'hEF;
+
+   assign cmd_features_abort_at_start = cmd_features_prepare && (
+								 (features == 8'h03 && (sector_count[7:3] != 5'd0 && sector_count[7:3] != 5'd1 && sector_count[7:3] != 5'd4 && sector_count[7:3] != 5'd8)) ||
+								 (features != 8'h03 && features != 8'h02 && features != 8'h82 && features != 8'hAA && features != 8'h55 && features != 8'hCC && features != 8'h66)
+								 );
+
+   assign cmd_features_start = cmd_features_prepare && ~(cmd_features_abort_at_start);
+
+   //read verify sectors
+   assign cmd_verify_start = cmd_start && (io_writedata[31:24] == 8'h40 || io_writedata[31:24] == 8'h41 || io_writedata[31:24] == 8'h42);
+
+   //set multiple
+
+   //if changed - fix cmd_multiple_abort_at_start
+
+   assign cmd_multiple_prepare = cmd_start && io_writedata[31:24] == 8'hC6;
+
+   assign cmd_multiple_abort_at_start = cmd_multiple_prepare && (
+								 (sector_count > `MAX_MULTIPLE_SECTORS) ||
+								 (sector_count != 8'd1 && sector_count != 8'd2 && sector_count != 8'd4 && sector_count != 8'd8 && sector_count != 8'd16) ||
+								 (sector_count == 8'd0)
+								 );
+
+   assign cmd_multiple_start = cmd_multiple_prepare && ~(cmd_multiple_abort_at_start);
+
+   //power
+   assign cmd_power_start = cmd_start && (io_writedata[31:24] == 8'hE0 || io_writedata[31:24] == 8'hE1 || io_writedata[31:24] == 8'hE7 || io_writedata[31:24] == 8'hEA);
+
+   //check power
+   assign cmd_checkpower_start = cmd_start && io_writedata[31:24] == 8'hE5;
+
+   //seek
+   assign cmd_seek_start = cmd_start && io_writedata[31:24] == 8'h70;
+
+   assign cmd_seek_in_progress = current_command == 8'h70;
+
+   //max address
+   assign cmd_max_prepare = cmd_start && (io_writedata[31:24] == 8'h27 || io_writedata[31:24] == 8'hF8);
+
+   assign cmd_max_abort_at_start = cmd_max_prepare && (
+						       ~(lba_mode)
+						       );
+
+   assign cmd_max_start = cmd_max_prepare && ~(cmd_max_abort_at_start);
+
+   //unknown
+   assign cmd_unknown_start = cmd_start &&
+			      ~(cmd_calibrate_start) &&
+			      ~(cmd_read_prepare) &&
+			      ~(cmd_write_prepare) &&
+			      ~(cmd_execute_drive_diag) &&
+			      ~(cmd_initialize_prepare) &&
+			      ~(cmd_identify_start) &&
+			      ~(cmd_features_prepare) &&
+			      ~(cmd_verify_start) &&
+			      ~(cmd_multiple_prepare) &&
+			      ~(cmd_power_start) &&
+			      ~(cmd_checkpower_start) &&
+			      ~(cmd_seek_start) &&
+			      ~(cmd_max_prepare);
+
+   //location
+   assign lba48_transform_active =
+				  (cmd_read_start   && (io_writedata[31:24] == 8'h24 || io_writedata[31:24] == 8'h29)) ||
+				  (cmd_write_start  && (io_writedata[31:24] == 8'h34 || io_writedata[31:24] == 8'h39)) ||
+				  (cmd_verify_start &&  io_writedata[31:24] == 8'h42) ||
+				  (cmd_max_start    &&  io_writedata[31:24] == 8'h27);
+
+   assign lba48_transform_inactive = ~(lba48_transform_active) && (cmd_read_start || cmd_write_start || cmd_verify_start || cmd_max_start);
+
+   assign set_signature =
+			 cmd_execute_drive_diag ||
+			 sw_reset_end;
+
+   //------------------------------------------------------------------------------
+
+
+
+
+
+
+
+
+
+   always @(posedge clk) begin
+      if(rst)                                                                                                       state <= S_IDLE;
+
+      //read
+      else if(state == S_IDLE && cmd_read_start)                                                                              state <= S_PREPARE_COUNT;
+      //count
+      else if(state == S_COUNT_DECISION && ~(count_decision_immediate_error) && cmd_read_in_progress)                         state <= S_SD_MUTEX;
+      //sd
+      else if(state == S_SD_CONTROL && sd_master_waitrequest == 1'b0 && cmd_read_in_progress)                                 state <= S_SD_READ_WAIT_FOR_DATA;
+      else if(state == S_SD_READ_WAIT_FOR_DATA && logical_sector_count == 5'd0)                                               state <= S_WAIT_FOR_EMPTY_READ_FIFO;
+      else if(state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && num_sectors == 17'd0 && cmd_read_in_progress)    state <= S_IDLE;
+      else if(state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && cmd_read_in_progress)                            state <= S_PREPARE_COUNT;
+
+      //seek
+      else if(state == S_IDLE && cmd_seek_start)                                                                      state <= S_PREPARE_COUNT;
+      //count
+      else if(state == S_COUNT_DECISION && ~(count_decision_immediate_error) && cmd_seek_in_progress)                 state <= S_IDLE;
+
+      //identify
+      else if(state == S_IDLE && cmd_identify_start)                                                                  state <= S_IDENTIFY_FILL;
+      else if(state == S_IDENTIFY_FILL && identify_counter == 7'd127)                                                 state <= S_WAIT_FOR_EMPTY_READ_FIFO;
+      else if(state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && cmd_identify_in_progress)                state <= S_IDLE;
+
+      //write
+      else if(state == S_IDLE && cmd_write_start)                                                                     state <= S_WAIT_FOR_FULL_WRITE_FIFO;
+      else if(state == S_WAIT_FOR_FULL_WRITE_FIFO && write_data_ready)                                                state <= S_PREPARE_COUNT;
+      //count
+      else if(state == S_COUNT_DECISION && ~(count_decision_immediate_error) && cmd_write_in_progress)                state <= S_SD_MUTEX;
+      //sd
+      else if(state == S_SD_CONTROL && sd_master_waitrequest == 1'b0 && cmd_write_in_progress)                        state <= S_SD_WRITE_WAIT_FOR_DATA;
+      else if(state == S_SD_WRITE_WAIT_FOR_DATA && logical_sector_count == 5'd0 && num_sectors == 17'd0)              state <= S_IDLE;
+      else if(state == S_SD_WRITE_WAIT_FOR_DATA && logical_sector_count == 5'd0)                                      state <= S_WAIT_FOR_FULL_WRITE_FIFO;
+
+      //count
+      else if(state == S_PREPARE_COUNT)                                                                               state <= S_COUNT_LOGICAL;
+      else if(state == S_COUNT_LOGICAL && mult1_b == 14'd0 && mult2_b == 9'd0)                                        state <= S_COUNT_FINAL;
+      else if(state == S_COUNT_FINAL)                                                                                 state <= S_COUNT_DECISION;
+      else if(state == S_COUNT_DECISION && count_decision_immediate_error)                                            state <= S_IDLE;
+
+      //sd read/write
+      else if(state == S_SD_MUTEX && sd_master_readdatavalid && sd_master_readdata[2:0] == 3'd2)                      state <= S_SD_AVALON_BASE;
+      else if(state == S_SD_AVALON_BASE && sd_master_waitrequest == 1'b0)                                             state <= S_SD_ADDRESS;
+      else if(state == S_SD_ADDRESS     && sd_master_waitrequest == 1'b0)                                             state <= S_SD_BLOCK_COUNT;
+      else if(state == S_SD_BLOCK_COUNT && sd_master_waitrequest == 1'b0)                                             state <= S_SD_CONTROL;
+   end
+
+   //------------------------------------------------------------------------------
+
+   assign drq_zero =
+		    (state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && cmd_read_in_progress) ||
+		    (state == S_WAIT_FOR_FULL_WRITE_FIFO && write_data_ready);
+
+   assign command_finished =
+			    (state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && cmd_read_in_progress && num_sectors == 17'd0) ||
+			    (state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && cmd_identify_in_progress) ||
+			    (state == S_SD_WRITE_WAIT_FOR_DATA && logical_sector_count == 5'd0 && num_sectors == 17'd0) ||
+			    cmd_calibrate_start ||
+			    cmd_multiple_start ||
+			    cmd_power_start ||
+			    cmd_checkpower_start ||
+			    (state == S_COUNT_DECISION && ~(count_decision_immediate_error) && cmd_seek_in_progress);
+
+   assign command_requires_drq =
+				(state == S_SD_READ_WAIT_FOR_DATA && logical_sector_count == 5'd0) ||
+				(state == S_IDENTIFY_FILL && identify_counter == 7'd127) ||
+				(state == S_SD_WRITE_WAIT_FOR_DATA && logical_sector_count == 5'd0 && num_sectors > 17'd0) ||
+				(state == S_IDLE && cmd_write_start);
+
+   assign raise_interrupt =
+			   command_requires_drq ||
+			   command_abort ||
+			   (state == S_SD_WRITE_WAIT_FOR_DATA && logical_sector_count == 5'd0 && num_sectors == 17'd0) ||
+			   cmd_calibrate_start ||
+			   cmd_execute_drive_diag ||
+			   cmd_initialize_start ||
+			   cmd_features_start ||
+			   cmd_verify_start ||
+			   cmd_multiple_start ||
+			   cmd_power_start ||
+			   cmd_checkpower_start ||
+			   (state == S_COUNT_DECISION && ~(count_decision_immediate_error) && cmd_seek_in_progress) ||
+			   cmd_max_start;
+
+   assign lower_interrupt =
+			   (io_read_valid  && io_address == 1'b1 && io_byteenable[3:0] == 4'b1000) ||
+			   (io_write && io_address == 1'b1 && io_byteenable[3:0] == 4'b1000 && ~(drive_select));
+
+   assign command_abort =
+			 (state == S_COUNT_DECISION && count_decision_immediate_error) ||
+			 cmd_read_abort_at_start ||
+			 cmd_write_abort_at_start ||
+			 cmd_initialize_abort_at_start ||
+			 cmd_features_abort_at_start ||
+			 cmd_multiple_abort_at_start ||
+			 cmd_max_abort_at_start ||
+			 cmd_unknown_start;
+
+   //------------------------------------------------------------------------------ count logical sector count
+
+   assign sectors_left = media_sectors - logical_sector[31:0] - 32'd1;
+
+   assign multiple_final_write =
+				 (current_command_write_multiple && lba_mode && (current_command_write_lba48 || media_sectors[31:28] == 4'd0) && sectors_left < { 27'd0, multiple_final_read })? sectors_left[4:0] : multiple_final_read;
+
+   assign multiple_final_read =
+			       (num_sectors >= { 12'd0, multiple_sectors })? multiple_sectors : num_sectors[4:0];
+
+   always @(posedge clk) begin
+      if(rst)                                                                                                           logical_sector_count <= 5'd0;
+      else if(state == S_SD_AVALON_BASE && current_command_read_multiple)                                                         logical_sector_count <= multiple_final_read;
+      else if(state == S_SD_AVALON_BASE && current_command_write_multiple)                                                        logical_sector_count <= multiple_final_write;
+      else if(state == S_SD_AVALON_BASE)                                                                                          logical_sector_count <= 5'd1;
+
+      else if(state == S_SD_READ_WAIT_FOR_DATA  && sd_slave_write       && sd_counter == 7'd127 && logical_sector_count > 5'd0)   logical_sector_count <= logical_sector_count - 5'd1;
+      else if(state == S_SD_WRITE_WAIT_FOR_DATA && sd_slave_read_valid  && sd_counter == 7'd127 && logical_sector_count > 5'd0)   logical_sector_count <= logical_sector_count - 5'd1;
+   end
+
+   assign count_decision_immediate_error =
+					  logical_sector[47:32] != 16'd0 ||
+					  logical_sector[31:0] >= media_sectors ||
+					  (current_command_read_multiple && lba_mode && (current_command_read_lba48 || media_sectors[31:28] == 4'd0) && (logical_sector[31:0] + { 27'd0, multiple_final_read }) > media_sectors);
+
+   //------------------------------------------------------------------------------ count logical sector
+
+   always @(posedge clk) begin
+      if(rst)                 mult1_a <= 30'd0;
+      else if(state == S_PREPARE_COUNT)   mult1_a <= { 14'd0, cylinder };
+      else if(state == S_COUNT_LOGICAL)   mult1_a <= { mult1_a[28:0], 1'b0 };
+   end
+
+   always @(posedge clk) begin
+      if(rst)                   mult1_b <= 14'd0;
+      else if(state == S_PREPARE_COUNT)   mult1_b <= media_spc;
+      else if(state == S_COUNT_LOGICAL)   mult1_b <= { 1'b0, mult1_b[13:1] };
+   end
+
+   always @(posedge clk) begin
+      if(rst)                               logical_sector1 <= 30'd0;
+      else if(state == S_PREPARE_COUNT)               logical_sector1 <= { 22'd0, sector } - 30'd1;
+      else if(state == S_COUNT_LOGICAL && mult1_b[0]) logical_sector1 <= logical_sector1 + mult1_a;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                 mult2_a <= 13'd0;
+      else if(state == S_PREPARE_COUNT)   mult2_a <= { 9'd0, head };
+      else if(state == S_COUNT_LOGICAL)   mult2_a <= { mult2_a[11:0], 1'b0 };
+   end
+
+   always @(posedge clk) begin
+      if(rst)                   mult2_b <= 9'd0;
+      else if(state == S_PREPARE_COUNT)   mult2_b <= media_spt;
+      else if(state == S_COUNT_LOGICAL)   mult2_b <= { 1'b0, mult2_b[8:1] };
+   end
+
+   always @(posedge clk) begin
+      if(rst)                               logical_sector2 <= 13'd0;
+      else if(state == S_PREPARE_COUNT)               logical_sector2 <= 13'd0;
+      else if(state == S_COUNT_LOGICAL && mult2_b[0]) logical_sector2 <= logical_sector2 + mult2_a;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                                       logical_sector <= 48'd0;
+      else if(state == S_COUNT_FINAL && lba_mode && current_command_lba48)    logical_sector <= { hob_hcyl, hob_lcyl, hob_sector, cylinder, sector };
+      else if(state == S_COUNT_FINAL && lba_mode)                             logical_sector <= { 20'd0, head, cylinder, sector };
+      else if(state == S_COUNT_FINAL)                                         logical_sector <= { 18'b0, logical_sector1 } + { 35'd0, logical_sector2 };
+   end
+
+   //------------------------------------------------------------------------------ sd
+
+   always @(posedge clk) begin
+      if(rst)                                                             sd_counter <= 7'd0;
+      else if(state != S_SD_READ_WAIT_FOR_DATA && state != S_SD_WRITE_WAIT_FOR_DATA)  sd_counter <= 7'd0;
+      else if(sd_slave_write || sd_slave_read_valid)                                  sd_counter <= sd_counter + 7'd1;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                   sd_sector <= 32'd0;
+      else if(state == S_SD_AVALON_BASE)  sd_sector <= (logical_sector >= { 16'd0, media_sectors })? media_sd_base + media_sectors - 32'd1 : media_sd_base + logical_sector[31:0];
+   end
+
+   assign sd_master_address =
+			     (state == S_SD_MUTEX)?          32'd8 :
+			     (state == S_SD_AVALON_BASE)?    32'd0 :
+			     (state == S_SD_ADDRESS)?        32'd4 :
+			     (state == S_SD_BLOCK_COUNT)?    32'd8 :
+			     (state == S_SD_CONTROL)?        32'd12 :
+                             32'd0;
+
+   always @(posedge clk) begin
+      if(rst)                                           sd_read_done <= 1'b0;
+      else if(sd_master_read && sd_master_waitrequest == 1'b0)    sd_read_done <= 1'b1;
+      else if(sd_master_readdatavalid)                            sd_read_done <= 1'b0;
+   end
+
+   always @(posedge clk) begin
+      if(rst)                                       sd_mutex_wait <= 4'd0;
+      else if(state == S_SD_MUTEX && sd_master_read == 1'b0)  sd_mutex_wait <= sd_mutex_wait + 4'd1;
+   end
+
+   assign sd_master_read = state == S_SD_MUTEX && sd_mutex_wait == 4'd9 && ~(sd_read_done);
+
+   assign sd_master_write = state == S_SD_AVALON_BASE || state == S_SD_ADDRESS || state == S_SD_BLOCK_COUNT || state == S_SD_CONTROL;
+
+   assign sd_master_writedata =
+			       (state == S_SD_AVALON_BASE)?                        `SD_AVALON_BASE_ADDRESS_FOR_HDD :
+			       (state == S_SD_ADDRESS)?                            sd_sector :
+			       (state == S_SD_BLOCK_COUNT)?                        { 27'd0, logical_sector_count } :
+			       (state == S_SD_CONTROL && cmd_read_in_progress)?    32'd2 : //CONTROL_READ
+			       (state == S_SD_CONTROL && cmd_write_in_progress)?   32'd3 : //CONTROL_WRITE
+                               32'd0;
+
+   //------------------------------------------------------------------------------ fifo for identify
+
+   always @(posedge clk) begin
+      if(rst)                   identify_counter <= 7'd0;
+      else if(state != S_IDENTIFY_FILL)   identify_counter <= 7'd0;
+      else                                identify_counter <= identify_counter + 7'd1;
+   end
+
+   assign identify_q_final =
+			    (identify_counter == 7'd29)?    { (multiple_sectors > 5'd0)? (16'h0100 | { 11'd0, multiple_sectors }) : 16'h0000,  identify_q[15:0] } :
+			    identify_q;
+
+   //------------------------------------------------------------------------------ modified by matsuda
+
+   simple_fifo #(
+		 .width      (32),
+		 .widthu     (8)
+		 )
+   fifo_identify_inst(
+		      .clk        (clk),
+		      .rst      (rst),
+
+		      .sclr       (1'b0),                                                                 //input
+
+		      .data       ((init_we) ? init_data : (mgmt_write)? mgmt_writedata : identify_q),                            //input [31:0]
+		      .wrreq      (init_we || (mgmt_address == 3'd0 && mgmt_write) || state == S_IDENTIFY_FILL),     //input
+
+		      .rdreq      (state == S_IDENTIFY_FILL),                                             //input
+		      .q          (identify_q),                                                           //output [31:0]
+
+		      /* verilator lint_off PINNOCONNECT */
+		      .full       (),                                                                     //output
+		      .empty      (),                                                                     //output
+		      .usedw      ()                                                                      //output [6:0]
+		      /* verilator lint_on PINNOCONNECT */
+		      );
+
+   //------------------------------------------------------------------------------ modified by matsuda
+
+   //------------------------------------------------------------------------------ fifo from hdd
+
+   assign from_hdd_stored_index_next = 3'd4 + { 1'b0, from_hdd_stored_index } - data_io_size;
+
+   always @(posedge clk) begin
+      if(rst)                                                           from_hdd_stored_index <= 2'd0;
+      else if(state == S_IDLE)                                                    from_hdd_stored_index <= 2'd0;
+      else if(read_data_io && { 1'b0, from_hdd_stored_index } >= data_io_size)    from_hdd_stored_index <= from_hdd_stored_index - data_io_size[1:0];
+      else if(read_data_io && from_hdd_empty)                                     from_hdd_stored_index <= 2'd0;
+      else if(read_data_io)                                                       from_hdd_stored_index <= from_hdd_stored_index_next[1:0];
+   end
+
+   assign from_hdd_result =
+			   (from_hdd_stored_index == 2'd0)?        { 24'd0, from_hdd_q } :
+			   (from_hdd_stored_index == 2'd1)?        { 16'd0, from_hdd_q, from_hdd_stored[7:0] } :
+			   (from_hdd_stored_index == 2'd2)?        { 8'd0,  from_hdd_q, from_hdd_stored[15:0] } :
+			   {        from_hdd_q, from_hdd_stored[23:0] };
+
+   always @(posedge clk) begin
+      if(rst)                               from_hdd_stored <= 24'd0;
+      else if(read_data_io && data_io_size == 3'd1)   from_hdd_stored <= from_hdd_result[31:8];
+      else if(read_data_io && data_io_size == 3'd2)   from_hdd_stored <= from_hdd_result[39:16];
+      else if(read_data_io && data_io_size == 3'd4)   from_hdd_stored <= from_hdd_result[55:32];
+   end
+
+   assign from_hdd_empty_valid = from_hdd_empty && from_hdd_stored_index == 2'd0;
+
+
+   simple_fifo #(
+		 .width      (32),
+		 .widthu     (11)
+		 )
+   fifo_from_hdd_inst(
+		      .clk        (clk),
+		      .rst      (rst),
+
+		      .sclr       (sw_reset_start),                                                                   //input
+
+		      .data       ((state == S_IDENTIFY_FILL)? identify_q_final : sd_slave_writedata),                //input [31:0]
+		      .wrreq      ((state == S_SD_READ_WAIT_FOR_DATA && sd_slave_write) || state == S_IDENTIFY_FILL), //input
+
+		      .rdreq      (read_data_io && { 1'b0, from_hdd_stored_index } < data_io_size),                   //input
+		      .empty      (from_hdd_empty),                                                                   //output
+		      .q          (from_hdd_q),                                                                       //output [31:0]
+
+		      /* verilator lint_off PINNOCONNECT */
+		      .full       (),                                                                                 //output
+		      .usedw      ()                                                                                  //output [10:0]
+		      /* verilator lint_on PINNOCONNECT */
+		      );
+
+
+   //------------------------------------------------------------------------------ fifo to hdd
+
+   always @(posedge clk) begin
+      if(rst)       to_hdd_stored_index <= 2'd0;
+      else if(write_data_io)  to_hdd_stored_index <= to_hdd_sum[1:0];
+   end
+
+   assign to_hdd_result =
+			 (to_hdd_stored_index == 2'd0)?        { 24'd0, io_writedata } :
+			 (to_hdd_stored_index == 2'd1)?        { 16'd0, io_writedata, to_hdd_stored[7:0] } :
+			 (to_hdd_stored_index == 2'd2)?        { 8'd0,  io_writedata, to_hdd_stored[15:0] } :
+			 {        io_writedata, to_hdd_stored[23:0] };
+
+   assign to_hdd_sum = data_io_size + { 1'b0, to_hdd_stored_index };
+
+   always @(posedge clk) begin
+      if(rst)                               to_hdd_stored <= 24'd0;
+      else if(write_data_io && to_hdd_sum == 3'd1)    to_hdd_stored <= { 16'd0, to_hdd_result[7:0] };
+      else if(write_data_io && to_hdd_sum == 3'd2)    to_hdd_stored <= { 8'd0,  to_hdd_result[15:0] };
+      else if(write_data_io && to_hdd_sum == 3'd3)    to_hdd_stored <= {        to_hdd_result[23:0] };
+      else if(write_data_io && to_hdd_sum == 3'd5)    to_hdd_stored <= { 16'd0, to_hdd_result[39:32] };
+      else if(write_data_io && to_hdd_sum == 3'd6)    to_hdd_stored <= { 8'd0,  to_hdd_result[47:32] };
+      else if(write_data_io && to_hdd_sum == 3'd7)    to_hdd_stored <= {        to_hdd_result[55:32] };
+   end
+
+   always @(posedge clk) begin
+      if(rst)   sd_slave_readdata <= 32'b0;
+      else                sd_slave_readdata <= to_hdd_q;
+   end
+
+   assign to_hdd_count = { to_hdd_full, to_hdd_usedw };
+
+   simple_fifo #(
+		 .width      (32),
+		 .widthu     (11)
+		 )
+   fifo_to_hdd_inst(
+		    .clk        (clk),
+		    .rst      (rst),
+
+		    .sclr       (sw_reset_start),                                               //input
+
+		    .data       (to_hdd_result[31:0]),                                          //input [31:0]
+		    .wrreq      (write_data_io && to_hdd_sum >= 3'd4 && ~(write_data_ready)),   //input
+		    .full       (to_hdd_full),                                                  //output
+
+		    .rdreq      (state == S_SD_WRITE_WAIT_FOR_DATA && sd_slave_read_valid),     //input
+		    .q          (to_hdd_q),                                                     //output [31:0]
+
+		    .usedw      (to_hdd_usedw),                                                 //output [10:0]
+
+		    /* verilator lint_off PINNOCONNECT */
+		    .empty      ()                                                             //output
+		    /* verilator lint_on PINNOCONNECT */
+		    );
+
+   //------------------------------------------------------------------------------
+
+   // synthesis translate_off
+   assign _unused_ok = &{ 1'b0, ide_3f6_writedata[7:3], ide_3f6_writedata[0],
+                          sd_master_readdata[31:3], sd_slave_address[8:0],
+                          media_cylinders_minus_1[16], from_hdd_stored_index_next[2], 1'b0 };
+   // synthesis translate_on
 
-wire cmd_multiple_prepare = cmd_start && io_writedata[31:24] == 8'hC6;
-
-wire cmd_multiple_abort_at_start = cmd_multiple_prepare && (
-    (sector_count > `MAX_MULTIPLE_SECTORS) ||
-    (sector_count != 8'd1 && sector_count != 8'd2 && sector_count != 8'd4 && sector_count != 8'd8 && sector_count != 8'd16) ||
-    (sector_count == 8'd0)
-);
-
-wire cmd_multiple_start = cmd_multiple_prepare && ~(cmd_multiple_abort_at_start);
-
-//power
-wire cmd_power_start = cmd_start && (io_writedata[31:24] == 8'hE0 || io_writedata[31:24] == 8'hE1 || io_writedata[31:24] == 8'hE7 || io_writedata[31:24] == 8'hEA);
-
-//check power
-wire cmd_checkpower_start = cmd_start && io_writedata[31:24] == 8'hE5;
-
-//seek
-wire cmd_seek_start = cmd_start && io_writedata[31:24] == 8'h70;
-
-wire cmd_seek_in_progress = current_command == 8'h70;
-
-//max address
-wire cmd_max_prepare = cmd_start && (io_writedata[31:24] == 8'h27 || io_writedata[31:24] == 8'hF8);
-
-wire cmd_max_abort_at_start = cmd_max_prepare && (
-    ~(lba_mode)
-);
-
-wire cmd_max_start = cmd_max_prepare && ~(cmd_max_abort_at_start);
-
-//unknown
-wire cmd_unknown_start = cmd_start &&
-    ~(cmd_calibrate_start) &&
-    ~(cmd_read_prepare) &&
-    ~(cmd_write_prepare) &&
-    ~(cmd_execute_drive_diag) &&
-    ~(cmd_initialize_prepare) &&
-    ~(cmd_identify_start) &&
-    ~(cmd_features_prepare) &&
-    ~(cmd_verify_start) &&
-    ~(cmd_multiple_prepare) &&
-    ~(cmd_power_start) &&
-    ~(cmd_checkpower_start) &&
-    ~(cmd_seek_start) &&
-    ~(cmd_max_prepare);
-
-//location
-wire lba48_transform_active =
-    (cmd_read_start   && (io_writedata[31:24] == 8'h24 || io_writedata[31:24] == 8'h29)) ||
-    (cmd_write_start  && (io_writedata[31:24] == 8'h34 || io_writedata[31:24] == 8'h39)) ||
-    (cmd_verify_start &&  io_writedata[31:24] == 8'h42) ||
-    (cmd_max_start    &&  io_writedata[31:24] == 8'h27);
-    
-wire lba48_transform_inactive = ~(lba48_transform_active) && (cmd_read_start || cmd_write_start || cmd_verify_start || cmd_max_start);
-
-wire set_signature =
-    cmd_execute_drive_diag ||
-    sw_reset_end;
-
-//------------------------------------------------------------------------------
-
-localparam [3:0] S_IDLE                     = 4'd0;
-
-localparam [3:0] S_PREPARE_COUNT            = 4'd1;
-localparam [3:0] S_COUNT_LOGICAL            = 4'd2;
-localparam [3:0] S_COUNT_FINAL              = 4'd3;
-localparam [3:0] S_COUNT_DECISION           = 4'd4;
-
-localparam [3:0] S_SD_MUTEX                 = 4'd5;
-localparam [3:0] S_SD_AVALON_BASE           = 4'd6;
-localparam [3:0] S_SD_ADDRESS               = 4'd7;
-localparam [3:0] S_SD_BLOCK_COUNT           = 4'd8;
-
-localparam [3:0] S_SD_CONTROL               = 4'd9;
-localparam [3:0] S_SD_READ_WAIT_FOR_DATA    = 4'd10;
-
-localparam [3:0] S_WAIT_FOR_EMPTY_READ_FIFO = 4'd11;
-
-localparam [3:0] S_IDENTIFY_COPY            = 4'd12;
-
-localparam [3:0] S_WAIT_FOR_FULL_WRITE_FIFO = 4'd13;
-localparam [3:0] S_SD_WRITE_WAIT_FOR_DATA   = 4'd14;
-
-localparam [3:0] S_IDENTIFY_FILL            = 4'd15;
-
-reg [3:0] state;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                                       state <= S_IDLE;
-    
-    //read
-    else if(state == S_IDLE && cmd_read_start)                                                                              state <= S_PREPARE_COUNT;
-        //count
-    else if(state == S_COUNT_DECISION && ~(count_decision_immediate_error) && cmd_read_in_progress)                         state <= S_SD_MUTEX;
-        //sd
-    else if(state == S_SD_CONTROL && sd_master_waitrequest == 1'b0 && cmd_read_in_progress)                                 state <= S_SD_READ_WAIT_FOR_DATA;
-    else if(state == S_SD_READ_WAIT_FOR_DATA && logical_sector_count == 5'd0)                                               state <= S_WAIT_FOR_EMPTY_READ_FIFO;
-    else if(state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && num_sectors == 17'd0 && cmd_read_in_progress)    state <= S_IDLE;
-    else if(state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && cmd_read_in_progress)                            state <= S_PREPARE_COUNT;
-    
-    //seek
-    else if(state == S_IDLE && cmd_seek_start)                                                                      state <= S_PREPARE_COUNT;
-        //count
-    else if(state == S_COUNT_DECISION && ~(count_decision_immediate_error) && cmd_seek_in_progress)                 state <= S_IDLE;
-    
-    //identify
-    else if(state == S_IDLE && cmd_identify_start)                                                                  state <= S_IDENTIFY_FILL;
-    else if(state == S_IDENTIFY_FILL && identify_counter == 7'd127)                                                 state <= S_WAIT_FOR_EMPTY_READ_FIFO;
-    else if(state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && cmd_identify_in_progress)                state <= S_IDLE;
-    
-    //write
-    else if(state == S_IDLE && cmd_write_start)                                                                     state <= S_WAIT_FOR_FULL_WRITE_FIFO;
-    else if(state == S_WAIT_FOR_FULL_WRITE_FIFO && write_data_ready)                                                state <= S_PREPARE_COUNT;
-        //count
-    else if(state == S_COUNT_DECISION && ~(count_decision_immediate_error) && cmd_write_in_progress)                state <= S_SD_MUTEX;
-        //sd
-    else if(state == S_SD_CONTROL && sd_master_waitrequest == 1'b0 && cmd_write_in_progress)                        state <= S_SD_WRITE_WAIT_FOR_DATA;
-    else if(state == S_SD_WRITE_WAIT_FOR_DATA && logical_sector_count == 5'd0 && num_sectors == 17'd0)              state <= S_IDLE;
-    else if(state == S_SD_WRITE_WAIT_FOR_DATA && logical_sector_count == 5'd0)                                      state <= S_WAIT_FOR_FULL_WRITE_FIFO;
-    
-    //count
-    else if(state == S_PREPARE_COUNT)                                                                               state <= S_COUNT_LOGICAL;
-    else if(state == S_COUNT_LOGICAL && mult1_b == 14'd0 && mult2_b == 9'd0)                                        state <= S_COUNT_FINAL;
-    else if(state == S_COUNT_FINAL)                                                                                 state <= S_COUNT_DECISION;
-    else if(state == S_COUNT_DECISION && count_decision_immediate_error)                                            state <= S_IDLE;
-     
-    //sd read/write
-    else if(state == S_SD_MUTEX && sd_master_readdatavalid && sd_master_readdata[2:0] == 3'd2)                      state <= S_SD_AVALON_BASE;
-    else if(state == S_SD_AVALON_BASE && sd_master_waitrequest == 1'b0)                                             state <= S_SD_ADDRESS;
-    else if(state == S_SD_ADDRESS     && sd_master_waitrequest == 1'b0)                                             state <= S_SD_BLOCK_COUNT;
-    else if(state == S_SD_BLOCK_COUNT && sd_master_waitrequest == 1'b0)                                             state <= S_SD_CONTROL;
-end
-
-//------------------------------------------------------------------------------
-
-wire drq_zero =
-    (state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && cmd_read_in_progress) ||
-    (state == S_WAIT_FOR_FULL_WRITE_FIFO && write_data_ready);
-
-wire command_finished =
-    (state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && cmd_read_in_progress && num_sectors == 17'd0) ||
-    (state == S_WAIT_FOR_EMPTY_READ_FIFO && from_hdd_empty_valid && cmd_identify_in_progress) ||
-    (state == S_SD_WRITE_WAIT_FOR_DATA && logical_sector_count == 5'd0 && num_sectors == 17'd0) ||
-    cmd_calibrate_start ||
-    cmd_multiple_start ||
-    cmd_power_start ||
-    cmd_checkpower_start ||
-    (state == S_COUNT_DECISION && ~(count_decision_immediate_error) && cmd_seek_in_progress);
-
-wire command_requires_drq =
-    (state == S_SD_READ_WAIT_FOR_DATA && logical_sector_count == 5'd0) ||
-    (state == S_IDENTIFY_FILL && identify_counter == 7'd127) ||
-    (state == S_SD_WRITE_WAIT_FOR_DATA && logical_sector_count == 5'd0 && num_sectors > 17'd0) ||
-    (state == S_IDLE && cmd_write_start);
-
-wire raise_interrupt =
-    command_requires_drq ||
-    command_abort ||
-    (state == S_SD_WRITE_WAIT_FOR_DATA && logical_sector_count == 5'd0 && num_sectors == 17'd0) ||
-    cmd_calibrate_start ||
-    cmd_execute_drive_diag ||
-    cmd_initialize_start ||
-    cmd_features_start ||
-    cmd_verify_start ||
-    cmd_multiple_start ||
-    cmd_power_start ||
-    cmd_checkpower_start ||
-    (state == S_COUNT_DECISION && ~(count_decision_immediate_error) && cmd_seek_in_progress) ||
-    cmd_max_start;
-
-wire lower_interrupt =
-    (io_read_valid  && io_address == 1'b1 && io_byteenable[3:0] == 4'b1000) ||
-    (io_write && io_address == 1'b1 && io_byteenable[3:0] == 4'b1000 && ~(drive_select));
-
-wire command_abort =
-    (state == S_COUNT_DECISION && count_decision_immediate_error) ||
-    cmd_read_abort_at_start ||
-    cmd_write_abort_at_start ||
-    cmd_initialize_abort_at_start ||
-    cmd_features_abort_at_start ||
-    cmd_multiple_abort_at_start ||
-    cmd_max_abort_at_start ||
-    cmd_unknown_start;
-
-//------------------------------------------------------------------------------ count logical sector count
-
-wire [31:0] sectors_left = media_sectors - logical_sector[31:0] - 32'd1;
-
-wire [4:0] multiple_final_write = 
-    (current_command_write_multiple && lba_mode && (current_command_write_lba48 || media_sectors[31:28] == 4'd0) && sectors_left < { 27'd0, multiple_final_read })? sectors_left[4:0] : multiple_final_read;
-
-wire [4:0] multiple_final_read =
-    (num_sectors >= { 12'd0, multiple_sectors })? multiple_sectors : num_sectors[4:0];
-
-reg [4:0] logical_sector_count;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                                           logical_sector_count <= 5'd0;
-    else if(state == S_SD_AVALON_BASE && current_command_read_multiple)                                                         logical_sector_count <= multiple_final_read;
-    else if(state == S_SD_AVALON_BASE && current_command_write_multiple)                                                        logical_sector_count <= multiple_final_write;
-    else if(state == S_SD_AVALON_BASE)                                                                                          logical_sector_count <= 5'd1;
-    
-    else if(state == S_SD_READ_WAIT_FOR_DATA  && sd_slave_write       && sd_counter == 7'd127 && logical_sector_count > 5'd0)   logical_sector_count <= logical_sector_count - 5'd1;
-    else if(state == S_SD_WRITE_WAIT_FOR_DATA && sd_slave_read_valid  && sd_counter == 7'd127 && logical_sector_count > 5'd0)   logical_sector_count <= logical_sector_count - 5'd1;
-end
-
-wire count_decision_immediate_error =
-    logical_sector[47:32] != 16'd0 ||
-    logical_sector[31:0] >= media_sectors ||
-    (current_command_read_multiple && lba_mode && (current_command_read_lba48 || media_sectors[31:28] == 4'd0) && (logical_sector[31:0] + { 27'd0, multiple_final_read }) > media_sectors);
-    
-//------------------------------------------------------------------------------ count logical sector
-
-reg [29:0] mult1_a; //cylinder
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)	                mult1_a <= 30'd0;
-    else if(state == S_PREPARE_COUNT)   mult1_a <= { 14'd0, cylinder };
-    else if(state == S_COUNT_LOGICAL)   mult1_a <= { mult1_a[28:0], 1'b0 };
-end
-
-reg [13:0] mult1_b; //media_spc
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   mult1_b <= 14'd0;
-    else if(state == S_PREPARE_COUNT)   mult1_b <= media_spc;
-    else if(state == S_COUNT_LOGICAL)   mult1_b <= { 1'b0, mult1_b[13:1] };
-end
-
-reg [29:0] logical_sector1; //cylinder * media_spc
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               logical_sector1 <= 30'd0;
-    else if(state == S_PREPARE_COUNT)               logical_sector1 <= { 22'd0, sector } - 30'd1;
-    else if(state == S_COUNT_LOGICAL && mult1_b[0]) logical_sector1 <= logical_sector1 + mult1_a;
-end
-
-reg [12:0] mult2_a; //head
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)	                mult2_a <= 13'd0;
-    else if(state == S_PREPARE_COUNT)   mult2_a <= { 9'd0, head };
-    else if(state == S_COUNT_LOGICAL)   mult2_a <= { mult2_a[11:0], 1'b0 };
-end
-
-reg [8:0] mult2_b; //media_spt
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   mult2_b <= 9'd0;
-    else if(state == S_PREPARE_COUNT)   mult2_b <= media_spt;
-    else if(state == S_COUNT_LOGICAL)   mult2_b <= { 1'b0, mult2_b[8:1] };
-end
-
-reg [12:0] logical_sector2; //head * media_spt
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               logical_sector2 <= 13'd0;
-    else if(state == S_PREPARE_COUNT)               logical_sector2 <= 13'd0;
-    else if(state == S_COUNT_LOGICAL && mult2_b[0]) logical_sector2 <= logical_sector2 + mult2_a;
-end
-
-reg [47:0] logical_sector;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       logical_sector <= 48'd0;
-    else if(state == S_COUNT_FINAL && lba_mode && current_command_lba48)    logical_sector <= { hob_hcyl, hob_lcyl, hob_sector, cylinder, sector };
-    else if(state == S_COUNT_FINAL && lba_mode)                             logical_sector <= { 20'd0, head, cylinder, sector };
-    else if(state == S_COUNT_FINAL)                                         logical_sector <= { 18'b0, logical_sector1 } + { 35'd0, logical_sector2 };
-end
-    
-//------------------------------------------------------------------------------ sd
-
-reg [6:0] sd_counter;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)	                                                            sd_counter <= 7'd0;
-    else if(state != S_SD_READ_WAIT_FOR_DATA && state != S_SD_WRITE_WAIT_FOR_DATA)  sd_counter <= 7'd0;
-    else if(sd_slave_write || sd_slave_read_valid)                                  sd_counter <= sd_counter + 7'd1;
-end
-
-reg [31:0] sd_sector;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   sd_sector <= 32'd0;
-    else if(state == S_SD_AVALON_BASE)  sd_sector <= (logical_sector >= { 16'd0, media_sectors })? media_sd_base + media_sectors - 32'd1 : media_sd_base + logical_sector[31:0];
-end
-
-assign sd_master_address =
-    (state == S_SD_MUTEX)?          32'd8 :
-    (state == S_SD_AVALON_BASE)?    32'd0 :
-    (state == S_SD_ADDRESS)?        32'd4 :
-    (state == S_SD_BLOCK_COUNT)?    32'd8 :
-    (state == S_SD_CONTROL)?        32'd12 :
-                                    32'd0;
-
-reg sd_read_done;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                           sd_read_done <= 1'b0;
-    else if(sd_master_read && sd_master_waitrequest == 1'b0)    sd_read_done <= 1'b1;
-    else if(sd_master_readdatavalid)                            sd_read_done <= 1'b0;
-end
-
-reg [3:0] sd_mutex_wait;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       sd_mutex_wait <= 4'd0;
-    else if(state == S_SD_MUTEX && sd_master_read == 1'b0)  sd_mutex_wait <= sd_mutex_wait + 4'd1;
-end
-
-assign sd_master_read = state == S_SD_MUTEX && sd_mutex_wait == 4'd9 && ~(sd_read_done);
-
-assign sd_master_write = state == S_SD_AVALON_BASE || state == S_SD_ADDRESS || state == S_SD_BLOCK_COUNT || state == S_SD_CONTROL;
-
-assign sd_master_writedata =
-    (state == S_SD_AVALON_BASE)?                        `SD_AVALON_BASE_ADDRESS_FOR_HDD :
-    (state == S_SD_ADDRESS)?                            sd_sector :
-    (state == S_SD_BLOCK_COUNT)?                        { 27'd0, logical_sector_count } :
-    (state == S_SD_CONTROL && cmd_read_in_progress)?    32'd2 : //CONTROL_READ
-    (state == S_SD_CONTROL && cmd_write_in_progress)?   32'd3 : //CONTROL_WRITE
-                                                        32'd0;
-
-//------------------------------------------------------------------------------ fifo for identify
-
-reg [6:0] identify_counter;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   identify_counter <= 7'd0;
-    else if(state != S_IDENTIFY_FILL)   identify_counter <= 7'd0;
-    else                                identify_counter <= identify_counter + 7'd1;
-end
-
-wire [31:0] identify_q;
-wire [31:0] identify_q_final =
-    (identify_counter == 7'd29)?    { (multiple_sectors > 5'd0)? (16'h0100 | { 11'd0, multiple_sectors }) : 16'h0000,  identify_q[15:0] } :
-                                    identify_q;
-
-simple_fifo #(
-    .width      (32),
-    .widthu     (7)
-)
-fifo_identify_inst(
-    .clk        (clk),
-    .rst_n      (rst_n),
-    
-    .sclr       (1'b0),                                                                 //input
-    
-    .data       ((mgmt_write)? mgmt_writedata : identify_q),                            //input [31:0]
-    .wrreq      ((mgmt_address == 3'd0 && mgmt_write) || state == S_IDENTIFY_FILL),     //input
-    
-    .rdreq      (state == S_IDENTIFY_FILL),                                             //input
-    .q          (identify_q),                                                           //output [31:0]
-    
-    /* verilator lint_off PINNOCONNECT */
-    .full       (),                                                                     //output
-    .empty      (),                                                                     //output
-    .usedw      ()                                                                      //output [6:0]
-    /* verilator lint_on PINNOCONNECT */
-);
-
-//------------------------------------------------------------------------------ fifo from hdd
-
-wire [2:0] from_hdd_stored_index_next = 3'd4 + { 1'b0, from_hdd_stored_index } - data_io_size;
-
-reg [1:0] from_hdd_stored_index;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           from_hdd_stored_index <= 2'd0;
-    else if(state == S_IDLE)                                                    from_hdd_stored_index <= 2'd0;
-    else if(read_data_io && { 1'b0, from_hdd_stored_index } >= data_io_size)    from_hdd_stored_index <= from_hdd_stored_index - data_io_size[1:0];
-    else if(read_data_io && from_hdd_empty)                                     from_hdd_stored_index <= 2'd0;
-    else if(read_data_io)                                                       from_hdd_stored_index <= from_hdd_stored_index_next[1:0];
-end
-
-wire [55:0] from_hdd_result =
-    (from_hdd_stored_index == 2'd0)?        { 24'd0, from_hdd_q } :
-    (from_hdd_stored_index == 2'd1)?        { 16'd0, from_hdd_q, from_hdd_stored[7:0] } :
-    (from_hdd_stored_index == 2'd2)?        { 8'd0,  from_hdd_q, from_hdd_stored[15:0] } :
-                                            {        from_hdd_q, from_hdd_stored[23:0] };
-    
-reg [23:0] from_hdd_stored;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               from_hdd_stored <= 24'd0;
-    else if(read_data_io && data_io_size == 3'd1)   from_hdd_stored <= from_hdd_result[31:8];
-    else if(read_data_io && data_io_size == 3'd2)   from_hdd_stored <= from_hdd_result[39:16];
-    else if(read_data_io && data_io_size == 3'd4)   from_hdd_stored <= from_hdd_result[55:32];
-end
-
-wire from_hdd_empty_valid = from_hdd_empty && from_hdd_stored_index == 2'd0;
-
-wire        from_hdd_empty;
-wire [31:0] from_hdd_q;
-
-simple_fifo #(
-    .width      (32),
-    .widthu     (11)
-)
-fifo_from_hdd_inst(
-    .clk        (clk),
-    .rst_n      (rst_n),
-    
-    .sclr       (sw_reset_start),                                                                   //input
-    
-    .data       ((state == S_IDENTIFY_FILL)? identify_q_final : sd_slave_writedata),                //input [31:0]
-    .wrreq      ((state == S_SD_READ_WAIT_FOR_DATA && sd_slave_write) || state == S_IDENTIFY_FILL), //input
-    
-    .rdreq      (read_data_io && { 1'b0, from_hdd_stored_index } < data_io_size),                   //input
-    .empty      (from_hdd_empty),                                                                   //output
-    .q          (from_hdd_q),                                                                       //output [31:0]
-
-    /* verilator lint_off PINNOCONNECT */
-    .full       (),                                                                                 //output
-    .usedw      ()                                                                                  //output [10:0]
-    /* verilator lint_on PINNOCONNECT */
-);
-
-
-//------------------------------------------------------------------------------ fifo to hdd
-
-reg [1:0] to_hdd_stored_index;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       to_hdd_stored_index <= 2'd0;
-    else if(write_data_io)  to_hdd_stored_index <= to_hdd_sum[1:0];
-end
-
-wire [55:0] to_hdd_result =
-    (to_hdd_stored_index == 2'd0)?        { 24'd0, io_writedata } :
-    (to_hdd_stored_index == 2'd1)?        { 16'd0, io_writedata, to_hdd_stored[7:0] } :
-    (to_hdd_stored_index == 2'd2)?        { 8'd0,  io_writedata, to_hdd_stored[15:0] } :
-                                          {        io_writedata, to_hdd_stored[23:0] };
-
-wire [2:0] to_hdd_sum = data_io_size + { 1'b0, to_hdd_stored_index };
-
-reg [23:0] to_hdd_stored;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               to_hdd_stored <= 24'd0;
-    else if(write_data_io && to_hdd_sum == 3'd1)    to_hdd_stored <= { 16'd0, to_hdd_result[7:0] };
-    else if(write_data_io && to_hdd_sum == 3'd2)    to_hdd_stored <= { 8'd0,  to_hdd_result[15:0] };
-    else if(write_data_io && to_hdd_sum == 3'd3)    to_hdd_stored <= {        to_hdd_result[23:0] };
-    else if(write_data_io && to_hdd_sum == 3'd5)    to_hdd_stored <= { 16'd0, to_hdd_result[39:32] };
-    else if(write_data_io && to_hdd_sum == 3'd6)    to_hdd_stored <= { 8'd0,  to_hdd_result[47:32] };
-    else if(write_data_io && to_hdd_sum == 3'd7)    to_hdd_stored <= {        to_hdd_result[55:32] };
-end
-
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   sd_slave_readdata <= 32'b0;
-    else                sd_slave_readdata <= to_hdd_q;
-end
-
-wire [11:0] to_hdd_count = { to_hdd_full, to_hdd_usedw };
-wire [10:0] to_hdd_usedw;
-wire        to_hdd_full;
-wire [31:0] to_hdd_q;
-
-simple_fifo #(
-    .width      (32),
-    .widthu     (11)
-)
-fifo_to_hdd_inst(
-    .clk        (clk),
-    .rst_n      (rst_n),
-    
-    .sclr       (sw_reset_start),                                               //input
-    
-    .data       (to_hdd_result[31:0]),                                          //input [31:0]
-    .wrreq      (write_data_io && to_hdd_sum >= 3'd4 && ~(write_data_ready)),   //input
-    .full       (to_hdd_full),                                                  //output
-    
-    .rdreq      (state == S_SD_WRITE_WAIT_FOR_DATA && sd_slave_read_valid),     //input
-    .q          (to_hdd_q),                                                     //output [31:0]
-
-    .usedw      (to_hdd_usedw),                                                 //output [10:0]
-    
-    /* verilator lint_off PINNOCONNECT */
-    .empty      ()                                                             //output
-    /* verilator lint_on PINNOCONNECT */
-);
-
-//------------------------------------------------------------------------------
-
-// synthesis translate_off
-wire _unused_ok = &{ 1'b0, ide_3f6_writedata[7:3], ide_3f6_writedata[0],
-                           sd_master_readdata[31:3], sd_slave_address[8:0],
-                           media_cylinders_minus_1[16], from_hdd_stored_index_next[2], 1'b0 };
-// synthesis translate_on
-
-//------------------------------------------------------------------------------
+   //------------------------------------------------------------------------------
 
 endmodule
diff --git a/rtl/soc/pc_bus/pc_bus.v b/rtl/soc/pc_bus/pc_bus.v
index 8895ff1..77f7544 100644
--- a/rtl/soc/pc_bus/pc_bus.v
+++ b/rtl/soc/pc_bus/pc_bus.v
@@ -1,17 +1,17 @@
 /*
  * Copyright (c) 2014, Aleksander Osman
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
- * 
+ *
  * * Redistributions of source code must retain the above copyright notice, this
  *   list of conditions and the following disclaimer.
- * 
+ *
  * * Redistributions in binary form must reproduce the above copyright notice,
  *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
@@ -23,302 +23,311 @@
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-module pc_bus(
-    input               clk,
-    input               rst_n,
-    
-    //control slave
-    input        [1:0]  ctrl_address,
-    input               ctrl_write,
-    input       [31:0]  ctrl_writedata,
-    
-    //memory slave
-    input       [29:0]  mem_address,
-    input       [3:0]   mem_byteenable,
-    input               mem_read,
-    output      [31:0]  mem_readdata,
-    input               mem_write,
-    input       [31:0]  mem_writedata,
-    output              mem_waitrequest,
-    output              mem_readdatavalid,
-    input       [2:0]   mem_burstcount,
-    
-    //memory master
-    output      [31:0]  sdram_address,
-    output      [3:0]   sdram_byteenable,
-    output              sdram_read,
-    input       [31:0]  sdram_readdata,
-    output              sdram_write,
-    output      [31:0]  sdram_writedata,
-    input               sdram_waitrequest,
-    input               sdram_readdatavalid,
-    output      [2:0]   sdram_burstcount,
-    
-    //vga master
-    output      [31:0]  vga_address,
-    output      [3:0]   vga_byteenable,
-    output              vga_read,
-    input       [31:0]  vga_readdata,
-    output              vga_write,
-    output      [31:0]  vga_writedata,
-    input               vga_waitrequest,
-    input               vga_readdatavalid,
-    output      [2:0]   vga_burstcount
-);
-
-//------------------------------------------------------------------------------ ctrl
-
-reg [127:0] data_at_0xffffffff;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           data_at_0xffffffff <= 128'h0000000000000000000000F000FFF0EA;
-    else if(ctrl_write && ctrl_address == 2'd0) data_at_0xffffffff <= { data_at_0xffffffff[127:32], ctrl_writedata };
-    else if(ctrl_write && ctrl_address == 2'd1) data_at_0xffffffff <= { data_at_0xffffffff[127:64], ctrl_writedata, data_at_0xffffffff[31:0] };
-    else if(ctrl_write && ctrl_address == 2'd2) data_at_0xffffffff <= { data_at_0xffffffff[127:96], ctrl_writedata, data_at_0xffffffff[63:0] };
-    else if(ctrl_write && ctrl_address == 2'd3) data_at_0xffffffff <= {                             ctrl_writedata, data_at_0xffffffff[95:0] };
-end
-
-//------------------------------------------------------------------------------ transaction
-
-wire select_vga        = ~(slow_start) && ~(slow_in_progress) && ~(transaction_in_progress) && (mem_read || mem_write) && ({ mem_address, 2'b00 } >= 32'h000A0000 && { mem_address, 2'b00 } < 32'h000C0000);
-wire select_sdram      = ~(slow_start) && ~(slow_in_progress) && ~(transaction_in_progress) && (mem_read || mem_write) && ~(select_vga);
-
-wire transaction_start = ~(slow_start) && ~(slow_in_progress) && ~(transaction_in_progress) && (mem_read || (mem_write && mem_burstcount > 3'd1));
-
-reg transaction_is_read;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           transaction_is_read <= 1'b0;
-    else if(transaction_start)  transaction_is_read <= mem_read;
-end
-
-reg transaction_select_vga;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           transaction_select_vga <= 1'b0;
-    else if(transaction_start)  transaction_select_vga <= select_vga;
-end
-
-reg transaction_was_read_accepted;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                               transaction_was_read_accepted <= 1'b1;
-    else if(transaction_start && mem_read && mem_waitrequest)                       transaction_was_read_accepted <= 1'b0;
-    else if(transaction_start && mem_read)                                          transaction_was_read_accepted <= 1'b1;
-    else if(transaction_in_progress && transaction_is_read && ~(mem_waitrequest))   transaction_was_read_accepted <= 1'b1;
-end
-
-reg [2:0] transaction_burstcount;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                               transaction_burstcount <= 3'd0;
-    else if(transaction_start && mem_write && ~(mem_waitrequest))                                                   transaction_burstcount <= mem_burstcount - 3'd1;
-    else if(transaction_start && (mem_read || mem_write))                                                           transaction_burstcount <= mem_burstcount;
-    else if(transaction_in_progress && mem_write         && transaction_burstcount > 3'd0 && ~(mem_waitrequest))    transaction_burstcount <= transaction_burstcount - 3'd1;
-    else if(transaction_in_progress && mem_readdatavalid && transaction_burstcount > 3'd0)                          transaction_burstcount <= transaction_burstcount - 3'd1;
-end
-
-reg [3:0] transaction_byteenable;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       transaction_byteenable <= 4'd0;
-    else if(transaction_start && mem_read)  transaction_byteenable <= mem_byteenable;
-end
-
-reg transaction_in_progress;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                               transaction_in_progress <= 1'b0;
-    else if(transaction_start)                                                                                      transaction_in_progress <= 1'b1;
-    else if(transaction_in_progress && mem_write         && transaction_burstcount <= 3'd1 && ~(mem_waitrequest))   transaction_in_progress <= 1'b0;
-    else if(transaction_in_progress && mem_readdatavalid && transaction_burstcount <= 3'd1)                         transaction_in_progress <= 1'b0;
-end
-
-//------------------------------------------------------------------------------ slow
-
-wire slow_start = ~(slow_in_progress) && ~(transaction_in_progress) && (mem_read || mem_write) && (
-    { mem_address, 2'b00 } == 32'h0009FFF4 ||
-    { mem_address, 2'b00 } == 32'h0009FFF8 ||
-    { mem_address, 2'b00 } == 32'h0009FFFC ||
-    
-    { mem_address, 2'b00 } == 32'h000BFFF4 ||
-    { mem_address, 2'b00 } == 32'h000BFFF8 ||
-    { mem_address, 2'b00 } == 32'h000BFFFC ||
-    
-    { mem_address, 2'b00 } == 32'hFFFFFFE4 ||
-    { mem_address, 2'b00 } == 32'hFFFFFFE8 ||
-    { mem_address, 2'b00 } == 32'hFFFFFFEC ||
-    { mem_address, 2'b00 } == 32'hFFFFFFF0 ||
-    { mem_address, 2'b00 } == 32'hFFFFFFF4 ||
-    { mem_address, 2'b00 } == 32'hFFFFFFF8 ||
-    { mem_address, 2'b00 } == 32'hFFFFFFFC
-);
-
-reg slow_in_progress;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                       slow_in_progress <= 1'b0;
-    else if(slow_start)                                                                                     slow_in_progress <= 1'b1;
-    
-    else if(slow_write_active && slow_is_vga   && vga_waitrequest == 1'b0   && slow_burstcount <= 3'd1)     slow_in_progress <= 1'b0;
-    else if(slow_write_active && slow_is_sdram && sdram_waitrequest == 1'b0 && slow_burstcount <= 3'd1)     slow_in_progress <= 1'b0;
-    else if(slow_write_active && slow_is_0xff  &&                              slow_burstcount <= 3'd1)     slow_in_progress <= 1'b0;
-    
-    else if(slow_read_active && slow_is_vga   && vga_readdatavalid   && slow_burstcount <= 3'd1)            slow_in_progress <= 1'b0;
-    else if(slow_read_active && slow_is_sdram && sdram_readdatavalid && slow_burstcount <= 3'd1)            slow_in_progress <= 1'b0;
-    else if(slow_read_active && slow_is_0xff  &&                        slow_burstcount <= 3'd1)            slow_in_progress <= 1'b0;
-end
-
-reg [31:0] slow_address;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           slow_address <= 32'b0;
-    else if(slow_start)                                                         slow_address <= { mem_address, 2'b0 };
-    
-    else if(slow_write_active && slow_is_vga   && vga_waitrequest   == 1'b0)    slow_address <= slow_address + 32'd4;
-    else if(slow_write_active && slow_is_sdram && sdram_waitrequest == 1'b0)    slow_address <= slow_address + 32'd4;
-    else if(slow_write_active && slow_is_0xff)                                  slow_address <= slow_address + 32'd4;
-    
-    else if(slow_read_active && slow_is_vga   && vga_readdatavalid)             slow_address <= slow_address + 32'd4;
-    else if(slow_read_active && slow_is_sdram && sdram_readdatavalid)           slow_address <= slow_address + 32'd4;
-    else if(slow_read_active && slow_is_0xff)                                   slow_address <= slow_address + 32'd4;
-end
-
-wire slow_is_vga   = { slow_address[31:2], 2'b0 } >= 32'h000A0000 && { slow_address[31:2], 2'b00 } < 32'h000C0000;
-wire slow_is_0xff  = { slow_address[31:2], 2'b0 } >= 32'hFFFFFFF0;
-wire slow_is_sdram = ~(slow_is_vga) && ~(slow_is_0xff);
-
-reg slow_write_active;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                       slow_write_active <= 1'b0;
-    else if(slow_start && mem_write)                                                                        slow_write_active <= 1'b1;
-    
-    else if(slow_write_active && slow_is_vga   && vga_waitrequest == 1'b0   && slow_burstcount <= 3'd1)     slow_write_active <= 1'b0;
-    else if(slow_write_active && slow_is_sdram && sdram_waitrequest == 1'b0 && slow_burstcount <= 3'd1)     slow_write_active <= 1'b0;
-    else if(slow_write_active && slow_is_0xff  &&                              slow_burstcount <= 3'd1)     slow_write_active <= 1'b0;
-end
-
-reg slow_was_read_accepted;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   slow_was_read_accepted <= 1'b0;
-    else if(slow_start && mem_read)                     slow_was_read_accepted <= 1'b0; //mem_waitrequest always 1'b1
-    else if(slow_read_active && ~(mem_waitrequest))     slow_was_read_accepted <= 1'b1;
-end
-
-reg slow_read_active;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                               slow_read_active <= 1'b0;
-    else if(slow_start && mem_read)                                                                 slow_read_active <= 1'b1;
-    
-    else if(slow_read_active && slow_is_vga   && vga_readdatavalid   && slow_burstcount <= 3'd1)    slow_read_active <= 1'b0;
-    else if(slow_read_active && slow_is_sdram && sdram_readdatavalid && slow_burstcount <= 3'd1)    slow_read_active <= 1'b0;
-    else if(slow_read_active && slow_is_0xff  &&                        slow_burstcount <= 3'd1)    slow_read_active <= 1'b0;
-end
-
-reg [2:0] slow_read_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                   slow_read_cnt <= 3'd0;
-    else if(slow_start && mem_read)                                                                     slow_read_cnt <= (mem_burstcount == 3'd0)? 3'd1 : mem_burstcount;
-    
-    else if(slow_read_active && slow_is_vga   && vga_waitrequest == 1'b0   && slow_read_cnt > 3'd0)     slow_read_cnt <= slow_read_cnt - 3'd1;
-    else if(slow_read_active && slow_is_sdram && sdram_waitrequest == 1'b0 && slow_read_cnt > 3'd0)     slow_read_cnt <= slow_read_cnt - 3'd1;
-    else if(slow_read_active && slow_is_0xff  &&                              slow_read_cnt > 3'd0)     slow_read_cnt <= slow_read_cnt - 3'd1;
-end
-
-reg [3:0] slow_byteenable;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   slow_byteenable <= 4'd0;
-    else if(slow_start && mem_read)     slow_byteenable <= mem_byteenable;
-end
-
-reg [2:0] slow_burstcount;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                       slow_burstcount <= 3'd0;
-    else if(slow_start)                                                                                     slow_burstcount <= mem_burstcount;
-    
-    else if(slow_write_active && slow_is_vga   && vga_waitrequest == 1'b0   && slow_burstcount > 3'd0)      slow_burstcount <= slow_burstcount - 3'd1;
-    else if(slow_write_active && slow_is_sdram && sdram_waitrequest == 1'b0 && slow_burstcount > 3'd0)      slow_burstcount <= slow_burstcount - 3'd1;
-    else if(slow_write_active && slow_is_0xff  &&                              slow_burstcount > 3'd0)      slow_burstcount <= slow_burstcount - 3'd1;
-    
-    else if(slow_read_active && slow_is_vga   && vga_readdatavalid   && slow_burstcount > 3'd0)             slow_burstcount <= slow_burstcount - 3'd1;
-    else if(slow_read_active && slow_is_sdram && sdram_readdatavalid && slow_burstcount > 3'd0)             slow_burstcount <= slow_burstcount - 3'd1;
-    else if(slow_read_active && slow_is_0xff  &&                        slow_burstcount > 3'd0)             slow_burstcount <= slow_burstcount - 3'd1;
-end
-
-//------------------------------------------------------------------------------ sdram
-
-assign sdram_address =
-    (slow_in_progress && slow_address[31:27] == 5'd0)?  { 4'd0, 1'b1, slow_address[26:0] } :
-    (slow_in_progress)?                                 32'hFFFFFFFC :
-    (mem_address[29:25] == 5'd0)?                       { 4'd0, 1'b1, mem_address[24:0], 2'b0 } :
-                                                        32'hFFFFFFFC;
-
-assign sdram_byteenable =
-    (slow_in_progress && slow_read_active)?             slow_byteenable :
-    (transaction_in_progress && transaction_is_read)?   transaction_byteenable :
-                                                        mem_byteenable;
-
-assign sdram_read =
-    (slow_in_progress)?                                                         slow_read_cnt > 3'd0 && slow_is_sdram :
-    (select_sdram || (transaction_in_progress && ~(transaction_select_vga)))?   mem_read && ~(transaction_in_progress && ~(transaction_is_read)) :
-                                                                                1'b0;
-
-assign sdram_write =
-    (slow_in_progress)?                                                         slow_write_active && slow_is_sdram :
-    (select_sdram || (transaction_in_progress && ~(transaction_select_vga)))?   mem_write && ~(transaction_in_progress && transaction_is_read) :
-                                                                                1'b0;
-
-assign sdram_writedata = mem_writedata;
-
-assign sdram_burstcount =
-    (slow_in_progress)?     3'd1 :
-                            mem_burstcount;
-
-//------------------------------------------------------------------------------ vga
-
-assign vga_address =
-    (slow_in_progress)?     slow_address :
-                            { mem_address, 2'b0 };
-
-assign vga_byteenable =
-    (slow_in_progress && slow_read_active)?             slow_byteenable :
-    (transaction_in_progress && transaction_is_read)?   transaction_byteenable :
-                                                        mem_byteenable;
-
-assign vga_read =
-    (slow_in_progress)?                                                     slow_read_cnt > 3'd0 && slow_is_vga :
-    (select_vga || (transaction_in_progress && transaction_select_vga))?    mem_read && ~(transaction_in_progress && ~(transaction_is_read)) :
-                                                                            1'b0;
-
-assign vga_write =
-    (slow_in_progress)?                                                     slow_write_active && slow_is_vga :
-    (select_vga || (transaction_in_progress && transaction_select_vga))?    mem_write && ~(transaction_in_progress && transaction_is_read) :
-                                                                            1'b0;
-
-assign vga_writedata = mem_writedata;
-
-assign vga_burstcount =
-    (slow_in_progress)?     3'd1 :
-                            mem_burstcount;
-
-//------------------------------------------------------------------------------ mem
-
-assign mem_readdata =
-    (slow_in_progress && slow_is_vga)?                                          vga_readdata :
-    (slow_in_progress && slow_is_0xff && slow_address[3:2] == 2'h0)?            data_at_0xffffffff[31:0] :
-    (slow_in_progress && slow_is_0xff && slow_address[3:2] == 2'h1)?            data_at_0xffffffff[63:32] :
-    (slow_in_progress && slow_is_0xff && slow_address[3:2] == 2'h2)?            data_at_0xffffffff[95:64] :
-    (slow_in_progress && slow_is_0xff && slow_address[3:2] == 2'h3)?            data_at_0xffffffff[127:96] :
-    (slow_in_progress)?                                                         sdram_readdata :
-    (select_vga || (transaction_in_progress && transaction_select_vga))?        vga_readdata :
-                                                                                sdram_readdata;
-
-assign mem_readdatavalid= 
-    (slow_in_progress && slow_is_vga)?                                          vga_readdatavalid :
-    (slow_in_progress && slow_is_0xff)?                                         1'b1 :
-    (slow_in_progress)?                                                         sdram_readdatavalid :
-    (select_vga || (transaction_in_progress && transaction_select_vga))?        vga_readdatavalid :
-                                                                                sdram_readdatavalid;
-
-assign mem_waitrequest =
-    (slow_in_progress && (slow_write_active || (slow_read_active && ~(slow_was_read_accepted))) && slow_is_vga)?            vga_waitrequest :
-    (slow_in_progress && (slow_write_active || (slow_read_active && ~(slow_was_read_accepted))) && slow_is_sdram)?          sdram_waitrequest :
-    (slow_in_progress && slow_read_active && slow_was_read_accepted)?                                                       1'b1 :
-    (transaction_in_progress && (~(transaction_is_read) || ~(transaction_was_read_accepted)) && transaction_select_vga)?    vga_waitrequest :
-    (transaction_in_progress && (~(transaction_is_read) || ~(transaction_was_read_accepted)))?                              sdram_waitrequest :
-    (transaction_in_progress && transaction_is_read && transaction_was_read_accepted)?                                      1'b1 :
-        (select_vga && vga_waitrequest) || (select_sdram && sdram_waitrequest) || slow_start;
+`default_nettype wire
+
+  module pc_bus(
+                input         clk,
+                input         rst,
+
+                //control slave
+                input [1:0]   ctrl_address,
+                input         ctrl_write,
+                input [31:0]  ctrl_writedata,
+
+                //memory slave
+                input [29:0]  mem_address,
+                input [3:0]   mem_byteenable,
+                input         mem_read,
+                output [31:0] mem_readdata,
+                input         mem_write,
+                input [31:0]  mem_writedata,
+                output        mem_waitrequest,
+                output        mem_readdatavalid,
+                input [2:0]   mem_burstcount,
+
+                //memory master
+                output [31:0] sdram_address,
+                output [3:0]  sdram_byteenable,
+                output        sdram_read,
+                input [31:0]  sdram_readdata,
+                output        sdram_write,
+                output [31:0] sdram_writedata,
+                input         sdram_waitrequest,
+                input         sdram_readdatavalid,
+                output [2:0]  sdram_burstcount,
+
+                //vga master
+                output [31:0] vga_address,
+                output [3:0]  vga_byteenable,
+                output        vga_read,
+                input [31:0]  vga_readdata,
+                output        vga_write,
+                output [31:0] vga_writedata,
+                input         vga_waitrequest,
+                input         vga_readdatavalid,
+                output [2:0]  vga_burstcount
+                );
+
+    //------------------------------------------------------------------------------ ctrl
+
+    reg [127:0]               data_at_0xffffffff;
+    reg                       transaction_is_read;
+    reg                       transaction_select_vga;
+    reg                       transaction_was_read_accepted;
+    reg [2:0]                 transaction_burstcount;
+    reg [3:0]                 transaction_byteenable;
+    reg                       transaction_in_progress;
+    reg                       slow_in_progress;
+    reg [31:0]                slow_address;
+    reg                       slow_write_active;
+    reg                       slow_was_read_accepted;
+    reg                       slow_read_active;
+    reg [2:0]                 slow_read_cnt;
+    reg [3:0]                 slow_byteenable;
+    reg [2:0]                 slow_burstcount;
+    wire                      select_vga;
+    wire                      select_sdram;
+    wire                      transaction_start;
+    wire                      slow_start;
+    wire                      slow_is_vga;
+    wire                      slow_is_0xff;
+    wire                      slow_is_sdram;
+
+    always @(posedge clk) begin
+        if(rst)                           data_at_0xffffffff <= 128'h0000000000000000000000F000FFF0EA;
+        else if(ctrl_write && ctrl_address == 2'd0) data_at_0xffffffff <= { data_at_0xffffffff[127:32], ctrl_writedata };
+        else if(ctrl_write && ctrl_address == 2'd1) data_at_0xffffffff <= { data_at_0xffffffff[127:64], ctrl_writedata, data_at_0xffffffff[31:0] };
+        else if(ctrl_write && ctrl_address == 2'd2) data_at_0xffffffff <= { data_at_0xffffffff[127:96], ctrl_writedata, data_at_0xffffffff[63:0] };
+        else if(ctrl_write && ctrl_address == 2'd3) data_at_0xffffffff <= {                             ctrl_writedata, data_at_0xffffffff[95:0] };
+    end
+
+    //------------------------------------------------------------------------------ transaction
+
+    assign select_vga = ~(slow_start) && ~(slow_in_progress) && ~(transaction_in_progress) && (mem_read || mem_write) && ({ mem_address, 2'b00 } >= 32'h000A0000 && { mem_address, 2'b00 } < 32'h000C0000);
+    assign select_sdram = ~(slow_start) && ~(slow_in_progress) && ~(transaction_in_progress) && (mem_read || mem_write) && ~(select_vga);
+
+    assign transaction_start = ~(slow_start) && ~(slow_in_progress) && ~(transaction_in_progress) && (mem_read || (mem_write && mem_burstcount > 3'd1));
+
+    always @(posedge clk) begin
+        if(rst)           transaction_is_read <= 1'b0;
+        else if(transaction_start)  transaction_is_read <= mem_read;
+    end
+
+    always @(posedge clk) begin
+        if(rst)           transaction_select_vga <= 1'b0;
+        else if(transaction_start)  transaction_select_vga <= select_vga;
+    end
+
+    always @(posedge clk) begin
+        if(rst)                                                               transaction_was_read_accepted <= 1'b1;
+        else if(transaction_start && mem_read && mem_waitrequest)                       transaction_was_read_accepted <= 1'b0;
+        else if(transaction_start && mem_read)                                          transaction_was_read_accepted <= 1'b1;
+        else if(transaction_in_progress && transaction_is_read && ~(mem_waitrequest))   transaction_was_read_accepted <= 1'b1;
+    end
+
+    always @(posedge clk) begin
+        if(rst)                                                                                               transaction_burstcount <= 3'd0;
+        else if(transaction_start && mem_write && ~(mem_waitrequest))                                                   transaction_burstcount <= mem_burstcount - 3'd1;
+        else if(transaction_start && (mem_read || mem_write))                                                           transaction_burstcount <= mem_burstcount;
+        else if(transaction_in_progress && mem_write         && transaction_burstcount > 3'd0 && ~(mem_waitrequest))    transaction_burstcount <= transaction_burstcount - 3'd1;
+        else if(transaction_in_progress && mem_readdatavalid && transaction_burstcount > 3'd0)                          transaction_burstcount <= transaction_burstcount - 3'd1;
+    end
+
+    always @(posedge clk) begin
+        if(rst)                       transaction_byteenable <= 4'd0;
+        else if(transaction_start && mem_read)  transaction_byteenable <= mem_byteenable;
+    end
+
+    always @(posedge clk) begin
+        if(rst)                                                                                               transaction_in_progress <= 1'b0;
+        else if(transaction_start)                                                                                      transaction_in_progress <= 1'b1;
+        else if(transaction_in_progress && mem_write         && transaction_burstcount <= 3'd1 && ~(mem_waitrequest))   transaction_in_progress <= 1'b0;
+        else if(transaction_in_progress && mem_readdatavalid && transaction_burstcount <= 3'd1)                         transaction_in_progress <= 1'b0;
+    end
+
+    //------------------------------------------------------------------------------ slow
+
+    assign slow_start = ~(slow_in_progress) && ~(transaction_in_progress) && (mem_read || mem_write) && (
+                                                                                                         { mem_address, 2'b00 } == 32'h0009FFF4 ||
+                                                                                                         { mem_address, 2'b00 } == 32'h0009FFF8 ||
+                                                                                                         { mem_address, 2'b00 } == 32'h0009FFFC ||
+
+                                                                                                         { mem_address, 2'b00 } == 32'h000BFFF4 ||
+                                                                                                         { mem_address, 2'b00 } == 32'h000BFFF8 ||
+                                                                                                         { mem_address, 2'b00 } == 32'h000BFFFC ||
+
+                                                                                                         { mem_address, 2'b00 } == 32'hFFFFFFE4 ||
+                                                                                                         { mem_address, 2'b00 } == 32'hFFFFFFE8 ||
+                                                                                                         { mem_address, 2'b00 } == 32'hFFFFFFEC ||
+                                                                                                         { mem_address, 2'b00 } == 32'hFFFFFFF0 ||
+                                                                                                         { mem_address, 2'b00 } == 32'hFFFFFFF4 ||
+                                                                                                         { mem_address, 2'b00 } == 32'hFFFFFFF8 ||
+                                                                                                         { mem_address, 2'b00 } == 32'hFFFFFFFC
+                                                                                                         );
+
+    always @(posedge clk) begin
+        if(rst)                                                                                       slow_in_progress <= 1'b0;
+        else if(slow_start)                                                                                     slow_in_progress <= 1'b1;
+
+        else if(slow_write_active && slow_is_vga   && vga_waitrequest == 1'b0   && slow_burstcount <= 3'd1)     slow_in_progress <= 1'b0;
+        else if(slow_write_active && slow_is_sdram && sdram_waitrequest == 1'b0 && slow_burstcount <= 3'd1)     slow_in_progress <= 1'b0;
+        else if(slow_write_active && slow_is_0xff  &&                              slow_burstcount <= 3'd1)     slow_in_progress <= 1'b0;
+
+        else if(slow_read_active && slow_is_vga   && vga_readdatavalid   && slow_burstcount <= 3'd1)            slow_in_progress <= 1'b0;
+        else if(slow_read_active && slow_is_sdram && sdram_readdatavalid && slow_burstcount <= 3'd1)            slow_in_progress <= 1'b0;
+        else if(slow_read_active && slow_is_0xff  &&                        slow_burstcount <= 3'd1)            slow_in_progress <= 1'b0;
+    end
+
+    always @(posedge clk) begin
+        if(rst)                                                           slow_address <= 32'b0;
+        else if(slow_start)                                                         slow_address <= { mem_address, 2'b0 };
+
+        else if(slow_write_active && slow_is_vga   && vga_waitrequest   == 1'b0)    slow_address <= slow_address + 32'd4;
+        else if(slow_write_active && slow_is_sdram && sdram_waitrequest == 1'b0)    slow_address <= slow_address + 32'd4;
+        else if(slow_write_active && slow_is_0xff)                                  slow_address <= slow_address + 32'd4;
+
+        else if(slow_read_active && slow_is_vga   && vga_readdatavalid)             slow_address <= slow_address + 32'd4;
+        else if(slow_read_active && slow_is_sdram && sdram_readdatavalid)           slow_address <= slow_address + 32'd4;
+        else if(slow_read_active && slow_is_0xff)                                   slow_address <= slow_address + 32'd4;
+    end
+
+    assign slow_is_vga = { slow_address[31:2], 2'b0 } >= 32'h000A0000 && { slow_address[31:2], 2'b00 } < 32'h000C0000;
+    assign slow_is_0xff = { slow_address[31:2], 2'b0 } >= 32'hFFFFFFF0;
+    assign slow_is_sdram = ~(slow_is_vga) && ~(slow_is_0xff);
+
+    always @(posedge clk) begin
+        if(rst)                                                                                       slow_write_active <= 1'b0;
+        else if(slow_start && mem_write)                                                                        slow_write_active <= 1'b1;
+
+        else if(slow_write_active && slow_is_vga   && vga_waitrequest == 1'b0   && slow_burstcount <= 3'd1)     slow_write_active <= 1'b0;
+        else if(slow_write_active && slow_is_sdram && sdram_waitrequest == 1'b0 && slow_burstcount <= 3'd1)     slow_write_active <= 1'b0;
+        else if(slow_write_active && slow_is_0xff  &&                              slow_burstcount <= 3'd1)     slow_write_active <= 1'b0;
+    end
+
+    always @(posedge clk) begin
+        if(rst)                                   slow_was_read_accepted <= 1'b0;
+        else if(slow_start && mem_read)                     slow_was_read_accepted <= 1'b0; //mem_waitrequest always 1'b1
+        else if(slow_read_active && ~(mem_waitrequest))     slow_was_read_accepted <= 1'b1;
+    end
+
+    always @(posedge clk) begin
+        if(rst)                                                                               slow_read_active <= 1'b0;
+        else if(slow_start && mem_read)                                                                 slow_read_active <= 1'b1;
+
+        else if(slow_read_active && slow_is_vga   && vga_readdatavalid   && slow_burstcount <= 3'd1)    slow_read_active <= 1'b0;
+        else if(slow_read_active && slow_is_sdram && sdram_readdatavalid && slow_burstcount <= 3'd1)    slow_read_active <= 1'b0;
+        else if(slow_read_active && slow_is_0xff  &&                        slow_burstcount <= 3'd1)    slow_read_active <= 1'b0;
+    end
+
+    always @(posedge clk) begin
+        if(rst)                                                                                   slow_read_cnt <= 3'd0;
+        else if(slow_start && mem_read)                                                                     slow_read_cnt <= (mem_burstcount == 3'd0)? 3'd1 : mem_burstcount;
+
+        else if(slow_read_active && slow_is_vga   && vga_waitrequest == 1'b0   && slow_read_cnt > 3'd0)     slow_read_cnt <= slow_read_cnt - 3'd1;
+        else if(slow_read_active && slow_is_sdram && sdram_waitrequest == 1'b0 && slow_read_cnt > 3'd0)     slow_read_cnt <= slow_read_cnt - 3'd1;
+        else if(slow_read_active && slow_is_0xff  &&                              slow_read_cnt > 3'd0)     slow_read_cnt <= slow_read_cnt - 3'd1;
+    end
+
+    always @(posedge clk) begin
+        if(rst)                   slow_byteenable <= 4'd0;
+        else if(slow_start && mem_read)     slow_byteenable <= mem_byteenable;
+    end
+
+    always @(posedge clk) begin
+        if(rst)                                                                                       slow_burstcount <= 3'd0;
+        else if(slow_start)                                                                                     slow_burstcount <= mem_burstcount;
+
+        else if(slow_write_active && slow_is_vga   && vga_waitrequest == 1'b0   && slow_burstcount > 3'd0)      slow_burstcount <= slow_burstcount - 3'd1;
+        else if(slow_write_active && slow_is_sdram && sdram_waitrequest == 1'b0 && slow_burstcount > 3'd0)      slow_burstcount <= slow_burstcount - 3'd1;
+        else if(slow_write_active && slow_is_0xff  &&                              slow_burstcount > 3'd0)      slow_burstcount <= slow_burstcount - 3'd1;
+
+        else if(slow_read_active && slow_is_vga   && vga_readdatavalid   && slow_burstcount > 3'd0)             slow_burstcount <= slow_burstcount - 3'd1;
+        else if(slow_read_active && slow_is_sdram && sdram_readdatavalid && slow_burstcount > 3'd0)             slow_burstcount <= slow_burstcount - 3'd1;
+        else if(slow_read_active && slow_is_0xff  &&                        slow_burstcount > 3'd0)             slow_burstcount <= slow_burstcount - 3'd1;
+    end
+
+    //------------------------------------------------------------------------------ sdram
+
+    assign sdram_address =
+                          (slow_in_progress && slow_address[31:27] == 5'd0)?  { 4'd0, 1'b1, slow_address[26:0] } :
+                          (slow_in_progress)?                                 32'hFFFFFFFC :
+                          (mem_address[29:25] == 5'd0)?                       { 4'd0, 1'b1, mem_address[24:0], 2'b0 } :
+                          32'hFFFFFFFC;
+
+    assign sdram_byteenable =
+                             (slow_in_progress && slow_read_active)?             slow_byteenable :
+                             (transaction_in_progress && transaction_is_read)?   transaction_byteenable :
+                             mem_byteenable;
+
+    assign sdram_read =
+                       (slow_in_progress)?                                                         slow_read_cnt > 3'd0 && slow_is_sdram :
+                       (select_sdram || (transaction_in_progress && ~(transaction_select_vga)))?   mem_read && ~(transaction_in_progress && ~(transaction_is_read)) :
+                       1'b0;
+
+    assign sdram_write =
+                        (slow_in_progress)?                                                         slow_write_active && slow_is_sdram :
+                        (select_sdram || (transaction_in_progress && ~(transaction_select_vga)))?   mem_write && ~(transaction_in_progress && transaction_is_read) :
+                        1'b0;
+
+    assign sdram_writedata = mem_writedata;
+
+    assign sdram_burstcount =
+                             (slow_in_progress)?     3'd1 :
+                             mem_burstcount;
+
+    //------------------------------------------------------------------------------ vga
+
+    assign vga_address =
+                        (slow_in_progress)?     slow_address :
+                        { mem_address, 2'b0 };
+
+    assign vga_byteenable =
+                           (slow_in_progress && slow_read_active)?             slow_byteenable :
+                           (transaction_in_progress && transaction_is_read)?   transaction_byteenable :
+                           mem_byteenable;
+
+    assign vga_read =
+                     (slow_in_progress)?                                                     slow_read_cnt > 3'd0 && slow_is_vga :
+                     (select_vga || (transaction_in_progress && transaction_select_vga))?    mem_read && ~(transaction_in_progress && ~(transaction_is_read)) :
+                     1'b0;
+
+    assign vga_write =
+                      (slow_in_progress)?                                                     slow_write_active && slow_is_vga :
+                      (select_vga || (transaction_in_progress && transaction_select_vga))?    mem_write && ~(transaction_in_progress && transaction_is_read) :
+                      1'b0;
+
+    assign vga_writedata = mem_writedata;
+
+    assign vga_burstcount =
+                           (slow_in_progress)?     3'd1 :
+                           mem_burstcount;
+
+    //------------------------------------------------------------------------------ mem
+
+    assign mem_readdata =
+                         (slow_in_progress && slow_is_vga)?                                          vga_readdata :
+                         (slow_in_progress && slow_is_0xff && slow_address[3:2] == 2'h0)?            data_at_0xffffffff[31:0] :
+                         (slow_in_progress && slow_is_0xff && slow_address[3:2] == 2'h1)?            data_at_0xffffffff[63:32] :
+                         (slow_in_progress && slow_is_0xff && slow_address[3:2] == 2'h2)?            data_at_0xffffffff[95:64] :
+                         (slow_in_progress && slow_is_0xff && slow_address[3:2] == 2'h3)?            data_at_0xffffffff[127:96] :
+                         (slow_in_progress)?                                                         sdram_readdata :
+                         (select_vga || (transaction_in_progress && transaction_select_vga))?        vga_readdata :
+                         sdram_readdata;
+
+    assign mem_readdatavalid=
+                              (slow_in_progress && slow_is_vga)?                                          vga_readdatavalid :
+                              (slow_in_progress && slow_is_0xff)?                                         1'b1 :
+                              (slow_in_progress)?                                                         sdram_readdatavalid :
+                              (select_vga || (transaction_in_progress && transaction_select_vga))?        vga_readdatavalid :
+                              sdram_readdatavalid;
+
+    assign mem_waitrequest =
+                            (slow_in_progress && (slow_write_active || (slow_read_active && ~(slow_was_read_accepted))) && slow_is_vga)?            vga_waitrequest :
+                            (slow_in_progress && (slow_write_active || (slow_read_active && ~(slow_was_read_accepted))) && slow_is_sdram)?          sdram_waitrequest :
+                            (slow_in_progress && slow_read_active && slow_was_read_accepted)?                                                       1'b1 :
+                            (transaction_in_progress && (~(transaction_is_read) || ~(transaction_was_read_accepted)) && transaction_select_vga)?    vga_waitrequest :
+                            (transaction_in_progress && (~(transaction_is_read) || ~(transaction_was_read_accepted)))?                              sdram_waitrequest :
+                            (transaction_in_progress && transaction_is_read && transaction_was_read_accepted)?                                      1'b1 :
+                            (select_vga && vga_waitrequest) || (select_sdram && sdram_waitrequest) || slow_start;
 
 endmodule
diff --git a/rtl/soc/pic/pic.v b/rtl/soc/pic/pic.v
index b32cec7..61c60a6 100644
--- a/rtl/soc/pic/pic.v
+++ b/rtl/soc/pic/pic.v
@@ -26,7 +26,7 @@
 
 module pic(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     //master pic
     input               master_address,
@@ -54,108 +54,188 @@ module pic(
 //------------------------------------------------------------------------------
 
 reg slave_read_last;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) slave_read_last <= 1'b0; else if(slave_read_last) slave_read_last <= 1'b0; else slave_read_last <= slave_read; end 
-wire slave_read_valid = slave_read && slave_read_last == 1'b0;
-
 reg master_read_last;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) master_read_last <= 1'b0; else if(master_read_last) master_read_last <= 1'b0; else master_read_last <= master_read; end 
-wire master_read_valid = master_read && master_read_last == 1'b0;
+reg [15:0] interrupt_last;
+reg sla_polled;
+reg sla_read_reg_select;
+reg sla_special_mask;
+reg sla_in_init;
+reg sla_init_requires_4;
+reg sla_ltim;
+reg [2:0] sla_init_byte_expected;
+reg [2:0] sla_lowest_priority;
+reg [7:0] sla_imr;
+reg [7:0] sla_irr;
+reg [7:0] sla_isr;
+reg [4:0] sla_interrupt_offset;
+reg sla_auto_eoi;
+reg sla_rotate_on_aeoi;
+reg sla_current_irq;    
+reg sla_current_irq_last;
+reg sla_spurious;
+reg mas_polled;
+reg mas_read_reg_select;
+reg mas_special_mask;
+reg mas_in_init;
+reg mas_init_requires_4;
+reg mas_ltim;
+reg [2:0] mas_init_byte_expected;
+reg [2:0] mas_lowest_priority;
+reg [7:0] mas_imr;
+reg [7:0] mas_irr;
+reg [7:0] mas_isr;
+reg [4:0] mas_interrupt_offset;
+reg mas_auto_eoi;
+reg mas_rotate_on_aeoi;
+reg mas_current_irq;    
+reg mas_spurious;
+reg mas_sla_active;
+wire slave_read_valid;
+wire master_read_valid;
+wire [7:0] sla_readdata_prepared ;
+wire [7:0] mas_readdata_prepared ;
+wire sla_init_icw1;
+wire sla_init_icw2;
+wire sla_init_icw3;
+wire sla_init_icw4;
+wire sla_ocw1;
+wire sla_ocw2;
+wire sla_ocw3;
+wire [7:0] sla_edge_detect ;
+wire [7:0] sla_writedata_mask ;
+wire sla_isr_clear;
+wire [7:0] sla_selected_prepare ;
+wire [7:0] sla_selected_shifted ;
+wire [7:0] sla_selected_shifted_isr ;
+wire [2:0] sla_selected_shifted_isr_first ;
+wire [2:0] sla_selected_shifted_isr_firstorm ;
+wire [7:0] sla_selected_shifted_isr_first_bits ;
+wire [2:0] sla_selected_index ;
+wire sla_irq;
+wire [2:0] sla_irq_value ;
+wire sla_acknowledge_not_spurious;
+wire sla_acknowledge;
+wire sla_spurious_start;
+wire mas_init_icw1;
+wire mas_init_icw2;
+wire mas_init_icw3;
+wire mas_init_icw4;
+wire mas_ocw1;
+wire mas_ocw2;
+wire mas_ocw3;
+wire [7:0] mas_interrupt_input ;
+wire [7:0] mas_edge_detect ;
+wire [7:0] mas_writedata_mask ;
+wire mas_isr_clear;
+wire [7:0] mas_selected_prepare ;
+wire [7:0] mas_selected_shifted ;
+wire [7:0] mas_selected_shifted_isr ;
+wire [2:0] mas_selected_shifted_isr_first ;
+wire [2:0] mas_selected_shifted_isr_firstorm ;
+wire [7:0] mas_selected_shifted_isr_first_bits ;
+wire [2:0] mas_selected_index ;
+wire mas_irq;
+wire [2:0] mas_irq_value ;
+wire mas_acknowledge_not_spurious;
+wire mas_acknowledge;
+wire mas_spurious_start;
+wire [7:0] mas_interrupt_vector_bits ;
+wire [7:0] interrupt_vector_bits ;
+wire _unused_ok;
+
+   
+always @(posedge clk) begin if(rst) slave_read_last <= 1'b0; else if(slave_read_last) slave_read_last <= 1'b0; else slave_read_last <= slave_read; end 
+ assign slave_read_valid = slave_read/* && slave_read_last == 1'b0*/;
+
+always @(posedge clk) begin if(rst) master_read_last <= 1'b0; else if(master_read_last) master_read_last <= 1'b0; else master_read_last <= master_read; end 
+ assign master_read_valid = master_read/* && master_read_last == 1'b0*/;
 
 //------------------------------------------------------------------------------
 
-reg [15:0] interrupt_last;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   interrupt_last <= 16'd0;
+always @(posedge clk) begin
+    if(rst)   interrupt_last <= 16'd0;
     else                interrupt_last <= interrupt_input;
 end
 
 //------------------------------------------------------------------------------
 
-wire [7:0] sla_readdata_prepared =
+ assign sla_readdata_prepared =
     (sla_polled)?                                               { sla_current_irq, 4'd0, sla_irq_value } :
     (slave_address == 1'b0 && sla_read_reg_select == 1'b0)?     sla_irr :
     (slave_address == 1'b0 && sla_read_reg_select == 1'b1)?     sla_isr :
                                                                 sla_imr;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   slave_readdata <= 8'd0;
+always @(posedge clk) begin
+    if(rst)   slave_readdata <= 8'd0;
     else                slave_readdata <= sla_readdata_prepared;
 end
 
-wire [7:0] mas_readdata_prepared =
+ assign mas_readdata_prepared =
     (mas_polled)?                                               { mas_current_irq, 4'd0, mas_irq_value } :
     (master_address == 1'b0 && mas_read_reg_select == 1'b0)?    mas_irr :
     (master_address == 1'b0 && mas_read_reg_select == 1'b1)?    mas_isr :
                                                                 mas_imr;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   master_readdata <= 8'd0;
+always @(posedge clk) begin
+    if(rst)   master_readdata <= 8'd0;
     else                master_readdata <= mas_readdata_prepared;
 end
 
 //------------------------------------------------------------------------------
 
-wire sla_init_icw1 = slave_write && slave_address == 1'b0 && slave_writedata[4] == 1'b1;
-wire sla_init_icw2 = slave_write && slave_address == 1'b1 && sla_in_init && sla_init_byte_expected == 3'd2;
-wire sla_init_icw3 = slave_write && slave_address == 1'b1 && sla_in_init && sla_init_byte_expected == 3'd3;
-wire sla_init_icw4 = slave_write && slave_address == 1'b1 && sla_in_init && sla_init_byte_expected == 3'd4;
+ assign sla_init_icw1 = slave_write && slave_address == 1'b0 && slave_writedata[4] == 1'b1;
+ assign sla_init_icw2 = slave_write && slave_address == 1'b1 && sla_in_init && sla_init_byte_expected == 3'd2;
+ assign sla_init_icw3 = slave_write && slave_address == 1'b1 && sla_in_init && sla_init_byte_expected == 3'd3;
+ assign sla_init_icw4 = slave_write && slave_address == 1'b1 && sla_in_init && sla_init_byte_expected == 3'd4;
 
-wire sla_ocw1 = sla_in_init == 1'b0 && slave_write && slave_address == 1'b1;
-wire sla_ocw2 = slave_write && slave_address == 1'b0 && slave_writedata[4:3] == 2'b00;
-wire sla_ocw3 = slave_write && slave_address == 1'b0 && slave_writedata[4:3] == 2'b01;
+ assign sla_ocw1 = sla_in_init == 1'b0 && slave_write && slave_address == 1'b1;
+ assign sla_ocw2 = slave_write && slave_address == 1'b0 && slave_writedata[4:3] == 2'b00;
+ assign sla_ocw3 = slave_write && slave_address == 1'b0 && slave_writedata[4:3] == 2'b01;
 
-reg sla_polled;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       sla_polled <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                       sla_polled <= 1'b0;
     else if(sla_polled && slave_read_valid) sla_polled <= 1'b0;
     else if(sla_ocw3)                       sla_polled <= slave_writedata[2];
 end
 
-reg sla_read_reg_select;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       sla_read_reg_select <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                       sla_read_reg_select <= 1'b0;
     else if(sla_init_icw1)                                                  sla_read_reg_select <= 1'b0;
     else if(sla_ocw3 && slave_writedata[2] == 1'b0 && slave_writedata[1])   sla_read_reg_select <= slave_writedata[0];
 end
 
-reg sla_special_mask;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       sla_special_mask <= 1'd0;
+always @(posedge clk) begin
+    if(rst)                                                       sla_special_mask <= 1'd0;
     else if(sla_init_icw1)                                                  sla_special_mask <= 1'd0;
     else if(sla_ocw3 && slave_writedata[2] == 1'b0 && slave_writedata[6])   sla_special_mask <= slave_writedata[5];
 end
 
-reg sla_in_init;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   sla_in_init <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                   sla_in_init <= 1'b0;
     else if(sla_init_icw1)                              sla_in_init <= 1'b1;
     else if(sla_init_icw3 && ~(sla_init_requires_4))    sla_in_init <= 1'b0;
     else if(sla_init_icw4)                              sla_in_init <= 1'b0;
 end
 
-reg sla_init_requires_4;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       sla_init_requires_4 <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       sla_init_requires_4 <= 1'b0;
     else if(sla_init_icw1)  sla_init_requires_4 <= slave_writedata[0];
 end
 
-reg sla_ltim;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       sla_ltim <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       sla_ltim <= 1'b0;
     else if(sla_init_icw1)  sla_ltim <= slave_writedata[3];
 end
 
-reg [2:0] sla_init_byte_expected;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               sla_init_byte_expected <= 3'd0;
+always @(posedge clk) begin
+    if(rst)                               sla_init_byte_expected <= 3'd0;
     else if(sla_init_icw1)                          sla_init_byte_expected <= 3'd2;
     else if(sla_init_icw2)                          sla_init_byte_expected <= 3'd3;
     else if(sla_init_icw3 && sla_init_requires_4)   sla_init_byte_expected <= 3'd4;
 end
 
-reg [2:0] sla_lowest_priority;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           sla_lowest_priority <= 3'd7;
+always @(posedge clk) begin
+    if(rst)                                                           sla_lowest_priority <= 3'd7;
     else if(sla_init_icw1)                                                      sla_lowest_priority <= 3'd7;
     else if(sla_ocw2 && slave_writedata == 8'hA0)                               sla_lowest_priority <= sla_lowest_priority + 3'd1;  //rotate on non-specific EOI
     else if(sla_ocw2 && { slave_writedata[7:3], 3'b000 } == 8'hC0)              sla_lowest_priority <= slave_writedata[2:0];        //set priority
@@ -163,14 +243,13 @@ always @(posedge clk or negedge rst_n) begin
     else if(sla_acknowledge_not_spurious && sla_auto_eoi && sla_rotate_on_aeoi) sla_lowest_priority <= sla_lowest_priority + 3'd1;  //rotate on AEOI
 end
 
-reg [7:0] sla_imr;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           sla_imr <= 8'hFF;
+always @(posedge clk) begin
+    if(rst)           sla_imr <= 8'hFF;
     else if(sla_init_icw1)      sla_imr <= 8'h00;
     else if(sla_ocw1)           sla_imr <= slave_writedata;
 end
 
-wire [7:0] sla_edge_detect = {
+ assign sla_edge_detect = {
     interrupt_input[15] == 1'b1 && interrupt_last[15] == 1'b0,
     interrupt_input[14] == 1'b1 && interrupt_last[14] == 1'b0,
     interrupt_input[13] == 1'b1 && interrupt_last[13] == 1'b0,
@@ -181,15 +260,14 @@ wire [7:0] sla_edge_detect = {
     interrupt_input[8]  == 1'b1 && interrupt_last[8] == 1'b0
 };
 
-reg [7:0] sla_irr;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       sla_irr <= 8'h00;
+always @(posedge clk) begin
+    if(rst)                       sla_irr <= 8'h00;
     else if(sla_init_icw1)                  sla_irr <= 8'h00;
     else if(sla_acknowledge_not_spurious)   sla_irr <= (sla_irr & interrupt_input[15:8] & ~(interrupt_vector_bits)) | ((~(sla_ltim))? sla_edge_detect : interrupt_input[15:8]);
     else                                    sla_irr <= (sla_irr & interrupt_input[15:8])                            | ((~(sla_ltim))? sla_edge_detect : interrupt_input[15:8]);
 end
 
-wire [7:0] sla_writedata_mask =
+ assign sla_writedata_mask =
     (slave_writedata[2:0] == 3'd0)?     8'b00000001 :
     (slave_writedata[2:0] == 3'd1)?     8'b00000010 :
     (slave_writedata[2:0] == 3'd2)?     8'b00000100 :
@@ -199,13 +277,12 @@ wire [7:0] sla_writedata_mask =
     (slave_writedata[2:0] == 3'd6)?     8'b01000000 :
                                         8'b10000000;
 
-wire sla_isr_clear = 
+ assign sla_isr_clear = 
     (sla_polled && slave_read_valid) || //polling
     (sla_ocw2 && (slave_writedata == 8'h20 || slave_writedata == 8'hA0)); //non-specific EOI or rotate on non-specific EOF
                                         
-reg [7:0] sla_isr;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               sla_isr <= 8'h00;
+always @(posedge clk) begin
+    if(rst)                                               sla_isr <= 8'h00;
     else if(sla_init_icw1)                                          sla_isr <= 8'h00;
     else if(sla_ocw2 && { slave_writedata[7:3], 3'b000 } == 8'h60)  sla_isr <= sla_isr & ~(sla_writedata_mask);                     //clear on specific EOI
     else if(sla_ocw2 && { slave_writedata[7:3], 3'b000 } == 8'hE0)  sla_isr <= sla_isr & ~(sla_writedata_mask);                     //clear on rotate on specific EOI
@@ -213,29 +290,26 @@ always @(posedge clk or negedge rst_n) begin
     else if(sla_acknowledge_not_spurious && ~(sla_auto_eoi))        sla_isr <= sla_isr | interrupt_vector_bits;                     //set
 end
 
-reg [4:0] sla_interrupt_offset;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       sla_interrupt_offset <= 5'h0E;
+always @(posedge clk) begin
+    if(rst)       sla_interrupt_offset <= 5'h0E;
     else if(sla_init_icw2)  sla_interrupt_offset <= slave_writedata[7:3];
 end
 
-reg sla_auto_eoi;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       sla_auto_eoi <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       sla_auto_eoi <= 1'b0;
     else if(sla_init_icw1)  sla_auto_eoi <= 1'b0;
     else if(sla_init_icw4)  sla_auto_eoi <= slave_writedata[1];
 end
 
-reg sla_rotate_on_aeoi;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   sla_rotate_on_aeoi <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                   sla_rotate_on_aeoi <= 1'b0;
     else if(sla_init_icw1)                              sla_rotate_on_aeoi <= 1'b0;
     else if(sla_ocw2 && slave_writedata[6:0] == 7'd0)   sla_rotate_on_aeoi <= slave_writedata[7];
 end
 
-wire [7:0] sla_selected_prepare = sla_irr & ~(sla_imr) & ~(sla_isr);
+ assign sla_selected_prepare = sla_irr & ~(sla_imr) & ~(sla_isr);
 
-wire [7:0] sla_selected_shifted =
+ assign sla_selected_shifted =
     (sla_lowest_priority == 3'd7)?      sla_selected_prepare :
     (sla_lowest_priority == 3'd0)?      { sla_selected_prepare[0],   sla_selected_prepare[7:1] } :
     (sla_lowest_priority == 3'd1)?      { sla_selected_prepare[1:0], sla_selected_prepare[7:2] } :
@@ -245,7 +319,7 @@ wire [7:0] sla_selected_shifted =
     (sla_lowest_priority == 3'd5)?      { sla_selected_prepare[5:0], sla_selected_prepare[7:6] } :
                                         { sla_selected_prepare[6:0], sla_selected_prepare[7] };
     
-wire [7:0] sla_selected_shifted_isr =
+ assign sla_selected_shifted_isr =
     (sla_lowest_priority == 3'd7)?      sla_isr :
     (sla_lowest_priority == 3'd0)?      { sla_isr[0],   sla_isr[7:1] } :
     (sla_lowest_priority == 3'd1)?      { sla_isr[1:0], sla_isr[7:2] } :
@@ -255,7 +329,7 @@ wire [7:0] sla_selected_shifted_isr =
     (sla_lowest_priority == 3'd5)?      { sla_isr[5:0], sla_isr[7:6] } :
                                         { sla_isr[6:0], sla_isr[7] };
 
-wire [2:0] sla_selected_shifted_isr_first =
+ assign sla_selected_shifted_isr_first =
     (sla_selected_shifted_isr[0])?  3'd0 :
     (sla_selected_shifted_isr[1])?  3'd1 :
     (sla_selected_shifted_isr[2])?  3'd2 :
@@ -265,19 +339,19 @@ wire [2:0] sla_selected_shifted_isr_first =
     (sla_selected_shifted_isr[6])?  3'd6 :
                                     3'd7;
     
-wire [2:0] sla_selected_shifted_isr_first_norm = sla_lowest_priority + sla_selected_shifted_isr_first + 3'd1;
-
-wire [7:0] sla_selected_shifted_isr_first_bits =
-    (sla_selected_shifted_isr_first_norm == 3'd0)?  8'b00000001 :
-    (sla_selected_shifted_isr_first_norm == 3'd1)?  8'b00000010 :
-    (sla_selected_shifted_isr_first_norm == 3'd2)?  8'b00000100 :
-    (sla_selected_shifted_isr_first_norm == 3'd3)?  8'b00001000 :
-    (sla_selected_shifted_isr_first_norm == 3'd4)?  8'b00010000 :
-    (sla_selected_shifted_isr_first_norm == 3'd5)?  8'b00100000 :
-    (sla_selected_shifted_isr_first_norm == 3'd6)?  8'b01000000 :
+ assign sla_selected_shifted_isr_firstorm = sla_lowest_priority + sla_selected_shifted_isr_first + 3'd1;
+
+ assign sla_selected_shifted_isr_first_bits =
+    (sla_selected_shifted_isr_firstorm == 3'd0)?  8'b00000001 :
+    (sla_selected_shifted_isr_firstorm == 3'd1)?  8'b00000010 :
+    (sla_selected_shifted_isr_firstorm == 3'd2)?  8'b00000100 :
+    (sla_selected_shifted_isr_firstorm == 3'd3)?  8'b00001000 :
+    (sla_selected_shifted_isr_firstorm == 3'd4)?  8'b00010000 :
+    (sla_selected_shifted_isr_firstorm == 3'd5)?  8'b00100000 :
+    (sla_selected_shifted_isr_firstorm == 3'd6)?  8'b01000000 :
                                                     8'b10000000;
                                     
-wire [2:0] sla_selected_index =
+ assign sla_selected_index =
     (sla_selected_shifted[0])?      3'd0 :
     (sla_selected_shifted[1])?      3'd1 :
     (sla_selected_shifted[2])?      3'd2 :
@@ -287,32 +361,29 @@ wire [2:0] sla_selected_index =
     (sla_selected_shifted[6])?      3'd6 :
                                     3'd7;
 
-wire sla_irq = sla_selected_prepare != 8'd0 && (sla_special_mask || sla_selected_index < sla_selected_shifted_isr_first);
+ assign sla_irq = sla_selected_prepare != 8'd0 && (sla_special_mask || sla_selected_index < sla_selected_shifted_isr_first);
 
-wire [2:0] sla_irq_value = (sla_irq)? sla_lowest_priority + sla_selected_index + 3'd1 : 3'd7;
+ assign sla_irq_value = (sla_irq)? sla_lowest_priority + sla_selected_index + 3'd1 : 3'd7;
 
-reg sla_current_irq;    
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           sla_current_irq <= 1'b0;
+always @(posedge clk) begin
+    if(rst)           sla_current_irq <= 1'b0;
     else if(sla_init_icw1)      sla_current_irq <= 1'b0;
     else if(sla_acknowledge)    sla_current_irq <= 1'b0;
     else if(sla_irq)            sla_current_irq <= 1'b1;
 end
 
-reg sla_current_irq_last;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   sla_current_irq_last <= 1'b0;
+always @(posedge clk) begin
+    if(rst)   sla_current_irq_last <= 1'b0;
     else                sla_current_irq_last <= sla_current_irq;
 end
 
-wire sla_acknowledge_not_spurious = (sla_polled && slave_read_valid) || (mas_sla_active && interrupt_done && ~(sla_spurious));
-wire sla_acknowledge              = (sla_polled && slave_read_valid) || (mas_sla_active && interrupt_done);
+ assign sla_acknowledge_not_spurious = (sla_polled && slave_read_valid) || (mas_sla_active && interrupt_done && ~(sla_spurious));
+ assign sla_acknowledge = (sla_polled && slave_read_valid) || (mas_sla_active && interrupt_done);
 
-wire sla_spurious_start = sla_current_irq && ~(interrupt_done) && ~(sla_irq);
+ assign sla_spurious_start = sla_current_irq && ~(interrupt_done) && ~(sla_irq);
 
-reg sla_spurious;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       sla_spurious <= 1'd0;
+always @(posedge clk) begin
+    if(rst)                       sla_spurious <= 1'd0;
     else if(sla_init_icw1)                  sla_spurious <= 1'b0;
     else if(sla_spurious_start)             sla_spurious <= 1'b1;
     else if(sla_acknowledge || sla_irq)     sla_spurious <= 1'b0;
@@ -320,67 +391,59 @@ end
 
 //------------------------------------------------------------------------------
 
-wire mas_init_icw1 = master_write && master_address == 1'b0 && master_writedata[4] == 1'b1;
-wire mas_init_icw2 = master_write && master_address == 1'b1 && mas_in_init && mas_init_byte_expected == 3'd2;
-wire mas_init_icw3 = master_write && master_address == 1'b1 && mas_in_init && mas_init_byte_expected == 3'd3;
-wire mas_init_icw4 = master_write && master_address == 1'b1 && mas_in_init && mas_init_byte_expected == 3'd4;
+ assign mas_init_icw1 = master_write && master_address == 1'b0 && master_writedata[4] == 1'b1;
+ assign mas_init_icw2 = master_write && master_address == 1'b1 && mas_in_init && mas_init_byte_expected == 3'd2;
+ assign mas_init_icw3 = master_write && master_address == 1'b1 && mas_in_init && mas_init_byte_expected == 3'd3;
+ assign mas_init_icw4 = master_write && master_address == 1'b1 && mas_in_init && mas_init_byte_expected == 3'd4;
 
-wire mas_ocw1 = mas_in_init == 1'b0 && master_write && master_address == 1'b1;
-wire mas_ocw2 = master_write && master_address == 1'b0 && master_writedata[4:3] == 2'b00;
-wire mas_ocw3 = master_write && master_address == 1'b0 && master_writedata[4:3] == 2'b01;
+ assign mas_ocw1 = mas_in_init == 1'b0 && master_write && master_address == 1'b1;
+ assign mas_ocw2 = master_write && master_address == 1'b0 && master_writedata[4:3] == 2'b00;
+ assign mas_ocw3 = master_write && master_address == 1'b0 && master_writedata[4:3] == 2'b01;
 
-reg mas_polled;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           mas_polled <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                           mas_polled <= 1'b0;
     else if(mas_polled && master_read_valid)    mas_polled <= 1'b0;
     else if(mas_ocw3)                           mas_polled <= master_writedata[2];
 end
 
-reg mas_read_reg_select;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       mas_read_reg_select <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                       mas_read_reg_select <= 1'b0;
     else if(mas_init_icw1)                                                  mas_read_reg_select <= 1'b0;
     else if(mas_ocw3 && master_writedata[2] == 1'b0 && master_writedata[1]) mas_read_reg_select <= master_writedata[0];
 end
 
-reg mas_special_mask;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       mas_special_mask <= 1'd0;
+always @(posedge clk) begin
+    if(rst)                                                       mas_special_mask <= 1'd0;
     else if(mas_init_icw1)                                                  mas_special_mask <= 1'd0;
     else if(mas_ocw3 && master_writedata[2] == 1'b0 && master_writedata[6]) mas_special_mask <= master_writedata[5];
 end
 
-reg mas_in_init;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   mas_in_init <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                   mas_in_init <= 1'b0;
     else if(mas_init_icw1)                              mas_in_init <= 1'b1;
     else if(mas_init_icw3 && ~(mas_init_requires_4))    mas_in_init <= 1'b0;
     else if(mas_init_icw4)                              mas_in_init <= 1'b0;
 end
 
-reg mas_init_requires_4;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       mas_init_requires_4 <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       mas_init_requires_4 <= 1'b0;
     else if(mas_init_icw1) mas_init_requires_4 <= master_writedata[0];
 end
 
-reg mas_ltim;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)      	mas_ltim <= 1'b0;
-    else if(mas_init_icw1) 	mas_ltim <= master_writedata[3];
+always @(posedge clk) begin
+    if(rst)       mas_ltim <= 1'b0;
+    else if(mas_init_icw1)  mas_ltim <= master_writedata[3];
 end
 
-reg [2:0] mas_init_byte_expected;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               mas_init_byte_expected <= 3'd0;
+always @(posedge clk) begin
+    if(rst)                               mas_init_byte_expected <= 3'd0;
     else if(mas_init_icw1)                          mas_init_byte_expected <= 3'd2;
     else if(mas_init_icw2)                          mas_init_byte_expected <= 3'd3;
     else if(mas_init_icw3 && mas_init_requires_4)   mas_init_byte_expected <= 3'd4;
 end
 
-reg [2:0] mas_lowest_priority;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                               mas_lowest_priority <= 3'd7;
+always @(posedge clk) begin
+    if(rst)                                                               mas_lowest_priority <= 3'd7;
     else if(mas_init_icw1)                                                          mas_lowest_priority <= 3'd7;
     else if(mas_ocw2 && master_writedata == 8'hA0)                                  mas_lowest_priority <= mas_lowest_priority + 3'd1;  //rotate on non-specific EOI
     else if(mas_ocw2 && { master_writedata[7:3], 3'b000 } == 8'hC0)                 mas_lowest_priority <= master_writedata[2:0];       //set priority
@@ -388,16 +451,15 @@ always @(posedge clk or negedge rst_n) begin
     else if(mas_acknowledge_not_spurious && mas_auto_eoi && mas_rotate_on_aeoi)     mas_lowest_priority <= mas_lowest_priority + 3'd1;  //rotate on AEOI
 end
 
-reg [7:0] mas_imr;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           mas_imr <= 8'hFF;
+always @(posedge clk) begin
+    if(rst)           mas_imr <= 8'hFF;
     else if(mas_init_icw1)      mas_imr <= 8'h00;
     else if(mas_ocw1)           mas_imr <= master_writedata;
 end
 
-wire [7:0] mas_interrupt_input = { interrupt_input[7:3], sla_current_irq, interrupt_input[1:0] };
+ assign mas_interrupt_input = { interrupt_input[7:3], sla_current_irq, interrupt_input[1:0] };
 
-wire [7:0] mas_edge_detect = {
+ assign mas_edge_detect = {
     interrupt_input[7] == 1'b1    && interrupt_last[7] == 1'b0,
     interrupt_input[6] == 1'b1    && interrupt_last[6] == 1'b0,
     interrupt_input[5] == 1'b1    && interrupt_last[5] == 1'b0,
@@ -408,15 +470,14 @@ wire [7:0] mas_edge_detect = {
     interrupt_input[0] == 1'b1    && interrupt_last[0] == 1'b0
 };
 
-reg [7:0] mas_irr;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       mas_irr <= 8'h00;
+always @(posedge clk) begin
+    if(rst)                       mas_irr <= 8'h00;
     else if(mas_init_icw1)                  mas_irr <= 8'h00;
     else if(mas_acknowledge_not_spurious)   mas_irr <= (mas_irr & mas_interrupt_input & ~(mas_interrupt_vector_bits)) | ((~(mas_ltim))? mas_edge_detect : mas_interrupt_input);
     else                                    mas_irr <= (mas_irr & mas_interrupt_input)                                | ((~(mas_ltim))? mas_edge_detect : mas_interrupt_input);
 end
 
-wire [7:0] mas_writedata_mask =
+ assign mas_writedata_mask =
     (master_writedata[2:0] == 3'd0)?    8'b00000001 :
     (master_writedata[2:0] == 3'd1)?    8'b00000010 :
     (master_writedata[2:0] == 3'd2)?    8'b00000100 :
@@ -426,13 +487,12 @@ wire [7:0] mas_writedata_mask =
     (master_writedata[2:0] == 3'd6)?    8'b01000000 :
                                         8'b10000000;
 
-wire mas_isr_clear = 
+ assign mas_isr_clear = 
     (mas_polled && master_read_valid) || //polling
     (mas_ocw2 && (master_writedata == 8'h20 || master_writedata == 8'hA0)); //non-specific EOI or rotate on non-specific EOF
                                         
-reg [7:0] mas_isr;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   mas_isr <= 8'h00;
+always @(posedge clk) begin
+    if(rst)                                                   mas_isr <= 8'h00;
     else if(mas_init_icw1)                                              mas_isr <= 8'h00;
     else if(mas_ocw2 && { master_writedata[7:3], 3'b000 } == 8'h60)     mas_isr <= mas_isr & ~(mas_writedata_mask);                     //clear on specific EOI
     else if(mas_ocw2 && { master_writedata[7:3], 3'b000 } == 8'hE0)     mas_isr <= mas_isr & ~(mas_writedata_mask);                     //clear on rotate on specific EOI
@@ -440,29 +500,26 @@ always @(posedge clk or negedge rst_n) begin
     else if(mas_acknowledge_not_spurious && ~(mas_auto_eoi))            mas_isr <= mas_isr | mas_interrupt_vector_bits;                 //set
 end
 
-reg [4:0] mas_interrupt_offset;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       mas_interrupt_offset <= 5'd1;
+always @(posedge clk) begin
+    if(rst)       mas_interrupt_offset <= 5'd1;
     else if(mas_init_icw2)  mas_interrupt_offset <= master_writedata[7:3];
 end
 
-reg mas_auto_eoi;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       mas_auto_eoi <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       mas_auto_eoi <= 1'b0;
     else if(mas_init_icw1)  mas_auto_eoi <= 1'b0;
     else if(mas_init_icw4)  mas_auto_eoi <= master_writedata[1];
 end
 
-reg mas_rotate_on_aeoi;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   mas_rotate_on_aeoi <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                   mas_rotate_on_aeoi <= 1'b0;
     else if(mas_init_icw1)                              mas_rotate_on_aeoi <= 1'b0;
     else if(mas_ocw2 && master_writedata[6:0] == 7'd0)  mas_rotate_on_aeoi <= master_writedata[7];
 end
 
-wire [7:0] mas_selected_prepare = mas_irr & ~(mas_imr) & ~(mas_isr);
+ assign mas_selected_prepare = mas_irr & ~(mas_imr) & ~(mas_isr);
 
-wire [7:0] mas_selected_shifted =
+ assign mas_selected_shifted =
     (mas_lowest_priority == 3'd7)?      mas_selected_prepare :
     (mas_lowest_priority == 3'd0)?      { mas_selected_prepare[0],   mas_selected_prepare[7:1] } :
     (mas_lowest_priority == 3'd1)?      { mas_selected_prepare[1:0], mas_selected_prepare[7:2] } :
@@ -472,7 +529,7 @@ wire [7:0] mas_selected_shifted =
     (mas_lowest_priority == 3'd5)?      { mas_selected_prepare[5:0], mas_selected_prepare[7:6] } :
                                         { mas_selected_prepare[6:0], mas_selected_prepare[7] };
     
-wire [7:0] mas_selected_shifted_isr =
+ assign mas_selected_shifted_isr =
     (mas_lowest_priority == 3'd7)?      mas_isr :
     (mas_lowest_priority == 3'd0)?      { mas_isr[0],   mas_isr[7:1] } :
     (mas_lowest_priority == 3'd1)?      { mas_isr[1:0], mas_isr[7:2] } :
@@ -482,7 +539,7 @@ wire [7:0] mas_selected_shifted_isr =
     (mas_lowest_priority == 3'd5)?      { mas_isr[5:0], mas_isr[7:6] } :
                                         { mas_isr[6:0], mas_isr[7] };
 
-wire [2:0] mas_selected_shifted_isr_first =
+ assign mas_selected_shifted_isr_first =
     (mas_selected_shifted_isr[0])?  3'd0 :
     (mas_selected_shifted_isr[1])?  3'd1 :
     (mas_selected_shifted_isr[2])?  3'd2 :
@@ -492,19 +549,19 @@ wire [2:0] mas_selected_shifted_isr_first =
     (mas_selected_shifted_isr[6])?  3'd6 :
                                     3'd7;
     
-wire [2:0] mas_selected_shifted_isr_first_norm = mas_lowest_priority + mas_selected_shifted_isr_first + 3'd1;
-
-wire [7:0] mas_selected_shifted_isr_first_bits =
-    (mas_selected_shifted_isr_first_norm == 3'd0)?  8'b00000001 :
-    (mas_selected_shifted_isr_first_norm == 3'd1)?  8'b00000010 :
-    (mas_selected_shifted_isr_first_norm == 3'd2)?  8'b00000100 :
-    (mas_selected_shifted_isr_first_norm == 3'd3)?  8'b00001000 :
-    (mas_selected_shifted_isr_first_norm == 3'd4)?  8'b00010000 :
-    (mas_selected_shifted_isr_first_norm == 3'd5)?  8'b00100000 :
-    (mas_selected_shifted_isr_first_norm == 3'd6)?  8'b01000000 :
+ assign mas_selected_shifted_isr_firstorm = mas_lowest_priority + mas_selected_shifted_isr_first + 3'd1;
+
+ assign mas_selected_shifted_isr_first_bits =
+    (mas_selected_shifted_isr_firstorm == 3'd0)?  8'b00000001 :
+    (mas_selected_shifted_isr_firstorm == 3'd1)?  8'b00000010 :
+    (mas_selected_shifted_isr_firstorm == 3'd2)?  8'b00000100 :
+    (mas_selected_shifted_isr_firstorm == 3'd3)?  8'b00001000 :
+    (mas_selected_shifted_isr_firstorm == 3'd4)?  8'b00010000 :
+    (mas_selected_shifted_isr_firstorm == 3'd5)?  8'b00100000 :
+    (mas_selected_shifted_isr_firstorm == 3'd6)?  8'b01000000 :
                                                     8'b10000000;
 
-wire [2:0] mas_selected_index =
+ assign mas_selected_index =
     (mas_selected_shifted[0])?      3'd0 :
     (mas_selected_shifted[1])?      3'd1 :
     (mas_selected_shifted[2])?      3'd2 :
@@ -514,34 +571,31 @@ wire [2:0] mas_selected_index =
     (mas_selected_shifted[6])?      3'd6 :
                                     3'd7;
 
-wire mas_irq = mas_selected_prepare != 8'd0 && (mas_special_mask || mas_selected_index < mas_selected_shifted_isr_first);
+ assign mas_irq = mas_selected_prepare != 8'd0 && (mas_special_mask || mas_selected_index < mas_selected_shifted_isr_first);
 
-wire [2:0] mas_irq_value = (mas_irq)? mas_lowest_priority + mas_selected_index + 3'd1 : 3'd7;
+ assign mas_irq_value = (mas_irq)? mas_lowest_priority + mas_selected_index + 3'd1 : 3'd7;
 
-reg mas_current_irq;    
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           mas_current_irq <= 1'b0;
+always @(posedge clk) begin
+    if(rst)           mas_current_irq <= 1'b0;
     else if(mas_init_icw1)      mas_current_irq <= 1'b0;
     else if(mas_acknowledge)    mas_current_irq <= 1'b0;
     else if(mas_irq)            mas_current_irq <= 1'b1;
 end
 
-wire mas_acknowledge_not_spurious = (mas_polled && master_read_valid) || (interrupt_done && ~(mas_spurious));
-wire mas_acknowledge              = (mas_polled && master_read_valid) || interrupt_done;
+ assign mas_acknowledge_not_spurious = (mas_polled && master_read_valid) || (interrupt_done && ~(mas_spurious));
+ assign mas_acknowledge = (mas_polled && master_read_valid) || interrupt_done;
 
-wire mas_spurious_start = mas_current_irq && ~(interrupt_done) && ~(mas_irq);
+ assign mas_spurious_start = mas_current_irq && ~(interrupt_done) && ~(mas_irq);
 
-reg mas_spurious;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       mas_spurious <= 1'd0;
+always @(posedge clk) begin
+    if(rst)                       mas_spurious <= 1'd0;
     else if(mas_init_icw1)                  mas_spurious <= 1'b0;
     else if(mas_spurious_start)             mas_spurious <= 1'b1;
     else if(mas_acknowledge || mas_irq)     mas_spurious <= 1'b0;
 end
 
-reg mas_sla_active;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               mas_sla_active <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                               mas_sla_active <= 1'b0;
     else if(mas_init_icw1)                                          mas_sla_active <= 1'b0;
     else if(mas_acknowledge)                                        mas_sla_active <= 1'b0;
     else if((mas_irq || mas_current_irq) && mas_irq_value != 3'd2)  mas_sla_active <= 1'b0;
@@ -550,23 +604,23 @@ end
 
 //------------------------------------------------------------------------------
 
-wire [7:0] mas_interrupt_vector_bits = (mas_sla_active)? 8'b00000100 : interrupt_vector_bits;
+ assign mas_interrupt_vector_bits = (mas_sla_active)? 8'b00000100 : interrupt_vector_bits;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           interrupt_do <= 1'b0;
+always @(posedge clk) begin
+    if(rst)           interrupt_do <= 1'b0;
     else if(mas_init_icw1)      interrupt_do <= 1'b0;
     else if(mas_acknowledge)    interrupt_do <= 1'b0;
     else if(mas_irq)            interrupt_do <= 1'b1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               interrupt_vector <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                               interrupt_vector <= 8'd0;
     else if(mas_init_icw1)                                          interrupt_vector <= 8'd0;
     else if((mas_irq || mas_current_irq) && mas_irq_value != 3'd2)  interrupt_vector <= { mas_interrupt_offset, mas_irq_value };
     else if((mas_irq || mas_current_irq) && mas_irq_value == 3'd2)  interrupt_vector <= { sla_interrupt_offset, sla_irq_value };
 end
 
-wire [7:0] interrupt_vector_bits =
+ assign interrupt_vector_bits =
     (interrupt_vector[2:0] == 3'd0)?    8'b00000001 :
     (interrupt_vector[2:0] == 3'd1)?    8'b00000010 :
     (interrupt_vector[2:0] == 3'd2)?    8'b00000100 :
@@ -579,7 +633,7 @@ wire [7:0] interrupt_vector_bits =
 //------------------------------------------------------------------------------
     
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, interrupt_last[15:1], sla_selected_shifted[7],
+ assign _unused_ok = &{ 1'b0, interrupt_last[15:1], sla_selected_shifted[7],
                            sla_selected_shifted_isr[7], mas_interrupt_input[0],
                            mas_selected_shifted[7], mas_selected_shifted_isr[7], 1'b0 };
 // synthesis translate_on
diff --git a/rtl/soc/pit/pit.v b/rtl/soc/pit/pit.v
index 0bb43fa..96d1b2a 100644
--- a/rtl/soc/pit/pit.v
+++ b/rtl/soc/pit/pit.v
@@ -1,17 +1,17 @@
 /*
  * Copyright (c) 2014, Aleksander Osman
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
- * 
+ *
  * * Redistributions of source code must retain the above copyright notice, this
  *   list of conditions and the following disclaimer.
- * 
+ *
  * * Redistributions in binary form must reproduce the above copyright notice,
  *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
@@ -24,29 +24,31 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+`include "../rtl/params.v"
+
 module pit(
     input               clk,
-    input               rst_n,
-    
+    input               rst,
+
     output              irq,
-    
+
     //io slave 040h-043h
     input       [1:0]   io_address,
     input               io_read,
     output reg  [7:0]   io_readdata,
     input               io_write,
     input       [7:0]   io_writedata,
-    
+
     //speaker port 61h
     input               speaker_61h_read,
     output      [7:0]   speaker_61h_readdata,
     input               speaker_61h_write,
     input       [7:0]   speaker_61h_writedata,
-    
+
     //speaker output
     output reg          speaker_enable,
     output              speaker_out,
-    
+
     //mgmt slave
     /*
     0.[7:0]: cycles in sysclock 1193181 Hz
@@ -59,40 +61,51 @@ module pit(
 //------------------------------------------------------------------------------
 
 reg io_read_last;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) io_read_last <= 1'b0; else if(io_read_last) io_read_last <= 1'b0; else io_read_last <= io_read; end 
-wire io_read_valid = io_read && io_read_last == 1'b0;
+reg [7:0] cycles_in_1193181hz; //838.096ns
+reg [7:0] system_counter;
+reg system_clock;
+reg [5:0] counter_1_cnt;
+reg counter_1_toggle;
+reg speaker_gate;
+wire io_read_valid;
+wire [7:0] io_readdata_next ;
+wire [7:0] counter_0_readdata;
+wire [7:0] counter_1_readdata;
+wire [7:0] counter_2_readdata;
+wire _unused_ok;
+
+
+always @(posedge clk) begin if(rst) io_read_last <= 1'b0; else if(io_read_last) io_read_last <= 1'b0; else io_read_last <= io_read; end
+ assign io_read_valid = io_read/* && io_read_last == 1'b0*/;
 
 //------------------------------------------------------------------------------ system clock
 
-reg [7:0] cycles_in_1193181hz; //838.096ns
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               cycles_in_1193181hz <= 8'd25;
+always @(posedge clk) begin
+    if(rst)                               cycles_in_1193181hz <= `PIT_CYCLES_IN_1193181HZ;
     else if(mgmt_write && mgmt_address == 1'b0)     cycles_in_1193181hz <= mgmt_writedata[7:0];
 end
 
-reg [7:0] system_counter;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               system_counter <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                               system_counter <= 8'd0;
     else if(system_counter >= cycles_in_1193181hz)  system_counter <= 8'd0;
     else                                            system_counter <= system_counter + 8'd2;
 end
 
-reg system_clock;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               system_clock <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                               system_clock <= 1'b0;
     else if(system_counter >= cycles_in_1193181hz)  system_clock <= ~(system_clock);
 end
 
 //------------------------------------------------------------------------------ read io
 
-wire [7:0] io_readdata_next =
+ assign io_readdata_next =
     (io_read_valid && io_address == 2'd0)?    counter_0_readdata :
     (io_read_valid && io_address == 2'd1)?    counter_1_readdata :
     (io_read_valid && io_address == 2'd2)?    counter_2_readdata :
                                               8'd0; //control address
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   io_readdata <= 8'd0;
+always @(posedge clk) begin
+    if(rst)   io_readdata <= 8'd0;
     else                io_readdata <= io_readdata_next;
 end
 
@@ -100,28 +113,25 @@ end
 
 assign speaker_61h_readdata = { 2'b0, speaker_out, counter_1_toggle, 2'b0, speaker_enable, speaker_gate };
 
-reg [5:0] counter_1_cnt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           counter_1_cnt <= 6'd0;
+always @(posedge clk) begin
+    if(rst)                                                           counter_1_cnt <= 6'd0;
     else if(system_counter >= cycles_in_1193181hz && counter_1_cnt == 6'd35)    counter_1_cnt <= 6'd0;
     else if(system_counter >= cycles_in_1193181hz)                              counter_1_cnt <= counter_1_cnt + 6'd1;
 end
 
-reg counter_1_toggle;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           counter_1_toggle <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                           counter_1_toggle <= 1'b0;
     else if(system_counter >= cycles_in_1193181hz && counter_1_cnt == 6'd35)    counter_1_toggle <= ~(counter_1_toggle);
 end
 
 
-reg speaker_gate;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           speaker_gate <= 1'b0;
+always @(posedge clk) begin
+    if(rst)           speaker_gate <= 1'b0;
     else if(speaker_61h_write)  speaker_gate <= speaker_61h_writedata[0];
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           speaker_enable <= 1'b0;
+always @(posedge clk) begin
+    if(rst)           speaker_enable <= 1'b0;
     else if(speaker_61h_write)  speaker_enable <= speaker_61h_writedata[1];
 end
 
@@ -129,70 +139,67 @@ end
 
 //------------------------------------------------------------------------------
 
-wire [7:0] counter_0_readdata;
-wire [7:0] counter_1_readdata;
-wire [7:0] counter_2_readdata;
 
 pit_counter pit_counter_0(
     .clk                (clk),
-    .rst_n              (rst_n),
-    
+    .rst              (rst),
+
     .clock              (system_clock),     //input
     .gate               (1'b1),             //input
     .out                (irq),              //output
-    
+
     .data_in            (io_writedata),                                                                                                                                         //input [7:0]
     .set_control_mode   (io_write && io_address == 2'd3 && io_writedata[7:6] == 2'b00 && io_writedata[5:4] != 2'b00),                                                           //input
     .latch_count        (io_write && io_address == 2'd3 && ((io_writedata[7:6] == 2'b00 && io_writedata[5:4] == 2'b00) || (io_writedata[7:5] == 3'b110 && io_writedata[1]))),   //input
     .latch_status       (io_write && io_address == 2'd3 && io_writedata[7:6] == 2'b11 && io_writedata[4] == 1'b0 && io_writedata[1]),                                           //input
     .write              (io_write && io_address == 2'd0),                                                                                                                       //input
     .read               (io_read_valid && io_address == 2'd0),                                                                                                                  //input
-    
+
     .data_out           (counter_0_readdata)    //output [7:0]
 );
 
 pit_counter pit_counter_1(
     .clk                (clk),
-    .rst_n              (rst_n),
-    
+    .rst              (rst),
+
     .clock              (system_clock),     //input
     .gate               (1'b1),             //input
     /* verilator lint_off PINNOCONNECT */
     .out                (),                 //output
     /* verilator lint_on PINNOCONNECT */
-    
+
     .data_in            (io_writedata),                                                                                                                                         //input [7:0]
     .set_control_mode   (io_write && io_address == 2'd3 && io_writedata[7:6] == 2'b01 && io_writedata[5:4] != 2'b00),                                                           //input
     .latch_count        (io_write && io_address == 2'd3 && ((io_writedata[7:6] == 2'b01 && io_writedata[5:4] == 2'b00) || (io_writedata[7:5] == 3'b110 && io_writedata[2]))),   //input
     .latch_status       (io_write && io_address == 2'd3 && io_writedata[7:6] == 2'b11 && io_writedata[4] == 1'b0 && io_writedata[2]),                                           //input
     .write              (io_write && io_address == 2'd1),                                                                                                                       //input
     .read               (io_read_valid && io_address == 2'd1),                                                                                                                  //input
-    
+
     .data_out           (counter_1_readdata)    //output [7:0]
 );
 
 pit_counter pit_counter_2(
     .clk                (clk),
-    .rst_n              (rst_n),
-    
+    .rst              (rst),
+
     .clock              (system_clock),     //input
     .gate               (speaker_gate),     //input
     .out                (speaker_out),      //output
-    
+
     .data_in            (io_writedata),                                                                                                                                         //input [7:0]
     .set_control_mode   (io_write && io_address == 2'd3 && io_writedata[7:6] == 2'b10 && io_writedata[5:4] != 2'b00),                                                           //input
     .latch_count        (io_write && io_address == 2'd3 && ((io_writedata[7:6] == 2'b10 && io_writedata[5:4] == 2'b00) || (io_writedata[7:5] == 3'b110 && io_writedata[3]))),   //input
     .latch_status       (io_write && io_address == 2'd3 && io_writedata[7:6] == 2'b11 && io_writedata[4] == 1'b0 && io_writedata[3]),                                           //input
     .write              (io_write && io_address == 2'd2),                                                                                                                       //input
     .read               (io_read_valid && io_address == 2'd2),                                                                                                                  //input
-    
+
     .data_out           (counter_2_readdata)    //output [7:0]
 );
 
 //------------------------------------------------------------------------------
 
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, speaker_61h_read, speaker_61h_writedata[7:2], mgmt_writedata[31:8], 1'b0 };
+ assign _unused_ok = &{ 1'b0, speaker_61h_read, speaker_61h_writedata[7:2], mgmt_writedata[31:8], 1'b0 };
 // synthesis translate_on
 
 //------------------------------------------------------------------------------
diff --git a/rtl/soc/pit/pit_counter.v b/rtl/soc/pit/pit_counter.v
index 3981621..8811576 100644
--- a/rtl/soc/pit/pit_counter.v
+++ b/rtl/soc/pit/pit_counter.v
@@ -26,7 +26,7 @@
 
 module pit_counter(
     input               clk,
-    input               rst_n,
+    input               rst,
     
     input               clock,
     input               gate,
@@ -45,94 +45,113 @@ module pit_counter(
 //------------------------------------------------------------------------------
 
 reg [2:0] mode;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           mode <= 3'd2;
+reg bcd;
+reg [1:0] rw_mode;
+reg [7:0] counter_l;
+reg [7:0] counter_m;
+reg [7:0] output_l;
+reg [7:0] output_m;
+reg output_latched;
+reg null_counter;
+reg msb_write;
+reg msb_read;
+reg [7:0] status;
+reg status_latched;
+reg clock_last;
+reg clock_pulse;
+reg gate_last;
+reg gate_sampled;
+reg trigger;
+reg trigger_sampled;
+reg written;
+reg loaded;
+reg [15:0] counter;
+wire load;
+wire load_even;
+wire enable;
+wire enable_double;
+wire [3:0] bcd_3 ;
+wire [3:0] bcd_2 ;
+wire [3:0] bcd_1 ;
+wire [15:0] counter_minus_1 ;
+wire [15:0] counter_minus_2 ;
+   
+always @(posedge clk) begin
+    if(rst)           mode <= 3'd2;
     else if(set_control_mode)   mode <= data_in[3:1];
 end
 
-reg bcd;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           bcd <= 1'd0;
+always @(posedge clk) begin
+    if(rst)           bcd <= 1'd0;
     else if(set_control_mode)   bcd <= data_in[0];
 end
 
-reg [1:0] rw_mode;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           rw_mode <= 2'd1;
+always @(posedge clk) begin
+    if(rst)           rw_mode <= 2'd1;
     else if(set_control_mode)   rw_mode <= data_in[5:4];
 end
 
 //------------------------------------------------------------------------------
 
-reg [7:0] counter_l;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                         counter_l <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                         counter_l <= 8'd0;
     else if(set_control_mode)                                 counter_l <= 8'd0;
     else if(write && rw_mode == 2'd3 && msb_write == 1'b0)    counter_l <= data_in;
     else if(write && rw_mode == 2'd1)                         counter_l <= data_in;
 end
 
-reg [7:0] counter_m;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                         counter_m <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                         counter_m <= 8'd0;
     else if(set_control_mode)                                 counter_m <= 8'd0;
     else if(write && rw_mode == 2'd3 && msb_write == 1'b1)    counter_m <= data_in;
     else if(write && rw_mode == 2'd2)                         counter_m <= data_in;
 end
 
-reg [7:0] output_l;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           output_l <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                           output_l <= 8'd0;
     else if(latch_count && ~(output_latched))   output_l <= counter[7:0];
     else if(~(output_latched))                  output_l <= counter[7:0];
 end
 
-reg [7:0] output_m;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           output_m <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                           output_m <= 8'd0;
     else if(latch_count && ~(output_latched))   output_m <= counter[15:8];
     else if(~(output_latched))                  output_m <= counter[15:8];
 end
 
-reg output_latched;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               output_latched <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                               output_latched <= 1'b0;
     else if(set_control_mode)                       output_latched <= 1'b0;
     else if(latch_count)                            output_latched <= 1'b1;
     else if(read && (rw_mode != 2'd3 || msb_read))  output_latched <= 1'b0;
 end
 
-reg null_counter;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   null_counter <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                   null_counter <= 1'b0;
     else if(set_control_mode)                           null_counter <= 1'b1;
     else if(write && (rw_mode != 2'd3 || msb_write))    null_counter <= 1'b1;
     else if(load)                                       null_counter <= 1'b0;
 end
 
-reg msb_write;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   msb_write <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   msb_write <= 1'b0;
     else if(set_control_mode)           msb_write <= 1'b0;
     else if(write && rw_mode == 2'd3)   msb_write <= ~(msb_write);
 end
 
-reg msb_read;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   msb_read <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   msb_read <= 1'b0;
     else if(set_control_mode)           msb_read <= 1'b0;
     else if(read && rw_mode == 2'd3)    msb_read <= ~(msb_read);
 end
 
-reg [7:0] status;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           status <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                           status <= 8'd0;
     else if(latch_status && ~(status_latched))  status <= { out, null_counter, rw_mode, mode, bcd };
 end
 
-reg status_latched;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           status_latched <= 1'b0;
+always @(posedge clk) begin
+    if(rst)           status_latched <= 1'b0;
     else if(set_control_mode)   status_latched <= 1'b0;
     else if(latch_status)       status_latched <= 1'b1;
     else if(read)               status_latched <= 1'b0;
@@ -147,48 +166,42 @@ assign data_out =
 
 //------------------------------------------------------------------------------
 
-reg clock_last;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   clock_last <= 1'b0;
+always @(posedge clk) begin
+    if(rst)   clock_last <= 1'b0;
     else                clock_last <= clock;
 end
 
-reg clock_pulse;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               clock_pulse <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                               clock_pulse <= 1'b0;
     else if(clock_last == 1'b1 && clock == 1'b0)    clock_pulse <= 1'b1;
     else                                            clock_pulse <= 1'b0;
 end
 
-reg gate_last;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   gate_last <= 1'b1;
+always @(posedge clk) begin
+    if(rst)   gate_last <= 1'b1;
     else                gate_last <= gate;
 end
 
-reg gate_sampled;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               gate_sampled <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                               gate_sampled <= 1'b0;
     else if(clock_last == 1'b0 && clock == 1'b1)    gate_sampled <= gate;
 end
 
-reg trigger;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               trigger <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                               trigger <= 1'b0;
     else if(gate_last == 1'b0 && gate == 1'b1)      trigger <= 1'b1;
     else if(clock_last == 1'b0 && clock == 1'b1)    trigger <= 1'b0;
 end
 
-reg trigger_sampled;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               trigger_sampled <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                               trigger_sampled <= 1'b0;
     else if(clock_last == 1'b0 && clock == 1'b1)    trigger_sampled <= trigger;
 end
 
 //------------------------------------------------------------------------------
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           out <= 1'b1;
+always @(posedge clk) begin
+    if(rst)                                                           out <= 1'b1;
     
     else if(set_control_mode && data_in[3:1] == 3'd0)                           out <= 1'b0;
     else if(set_control_mode && data_in[3:1] == 3'd1)                           out <= 1'b1;
@@ -223,23 +236,21 @@ end
 
 //------------------------------------------------------------------------------
 
-reg written;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       written <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                       written <= 1'b0;
     else if(set_control_mode)                               written <= 1'b0;
     else if(write && rw_mode != 2'd3)                       written <= 1'b1;
     else if(write && rw_mode == 2'd3 && msb_write == 1'b1)  written <= 1'b1;
     else if(load)                                           written <= 1'b0;
 end
 
-reg loaded;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           loaded <= 1'b0;
+always @(posedge clk) begin
+    if(rst)           loaded <= 1'b0;
     else if(set_control_mode)   loaded <= 1'b0;
     else if(load)               loaded <= 1'b1;
 end
 
-wire load = clock_pulse && (
+ assign load = clock_pulse && (
     (mode == 3'd0 && written) ||
     (mode == 3'd1 && written && trigger_sampled) ||
     (mode[1:0] == 2'd2 && (written || trigger_sampled || (loaded && gate_sampled && counter == 16'd1))) ||
@@ -248,9 +259,9 @@ wire load = clock_pulse && (
     (mode == 3'd5 && (written || loaded) && trigger_sampled)
 );
 
-wire load_even = load && mode[1:0] == 2'd3;
+ assign load_even = load && mode[1:0] == 2'd3;
     
-wire enable = ~(load) && loaded && clock_pulse && ( 
+ assign enable = ~(load) && loaded && clock_pulse && ( 
     (mode == 3'd0 && gate_sampled && msb_write == 1'b0) ||
     (mode == 3'd1) ||
     (mode[1:0] == 2'd2 && gate_sampled) ||
@@ -258,31 +269,30 @@ wire enable = ~(load) && loaded && clock_pulse && (
     (mode == 3'd5)
 );
 
-wire enable_double = ~(load) && loaded && clock_pulse && mode[1:0] == 2'd3 && gate_sampled;
+ assign enable_double = ~(load) && loaded && clock_pulse && mode[1:0] == 2'd3 && gate_sampled;
 
 //------------------------------------------------------------------------------
 
-wire [3:0] bcd_3 = counter[15:12] - 4'd1;
-wire [3:0] bcd_2 = counter[11:8] - 4'd1;
-wire [3:0] bcd_1 = counter[7:4] - 4'd1;
+ assign bcd_3 = counter[15:12] - 4'd1;
+ assign bcd_2 = counter[11:8] - 4'd1;
+ assign bcd_1 = counter[7:4] - 4'd1;
 
-wire [15:0] counter_minus_1 =
+ assign counter_minus_1 =
     (bcd && counter[15:0] == 16'd0)?    16'h9999 :
     (bcd && counter[11:0] == 12'd0)?    { bcd_3, 12'h999 } :
     (bcd && counter[7:0] == 8'd0)?      { counter[15:12], bcd_2, 8'h99 } :
     (bcd && counter[3:0] == 4'd0)?      { counter[15:8], bcd_1, 4'h9 } :
                                         counter - 16'd1;
 
-wire [15:0] counter_minus_2 =
+ assign counter_minus_2 =
     (bcd && counter[15:0] == 16'd0)?    16'h9998 :
     (bcd && counter[11:0] == 12'd0)?    { bcd_3, 12'h998 } :
     (bcd && counter[7:0] == 8'd0)?      { counter[15:12], bcd_2, 8'h98 } :
     (bcd && counter[3:0] == 4'd0)?      { counter[15:8], bcd_1, 4'h8 } :
                                         counter - 16'd2;
 
-reg [15:0] counter;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       counter <= 16'd0;
+always @(posedge clk) begin
+    if(rst)       counter <= 16'd0;
     else if(load_even)      counter <= { counter_m, counter_l[7:1], 1'b0 };
     else if(load)           counter <= { counter_m, counter_l };
     else if(enable_double)  counter <= counter_minus_2;
diff --git a/rtl/soc/ps2/ps2.v b/rtl/soc/ps2/ps2.v
index 38dacfd..89d9848 100644
--- a/rtl/soc/ps2/ps2.v
+++ b/rtl/soc/ps2/ps2.v
@@ -1,3 +1,4 @@
+
 /*
  * Copyright (c) 2014, Aleksander Osman
  * All rights reserved.
@@ -26,7 +27,7 @@
 
 module ps2(
     input                   clk,
-    input                   rst_n,
+    input                   rst,
     
     output reg              irq_keyb,
     output reg              irq_mouse,
@@ -66,9 +67,145 @@ module ps2(
 
 //------------------------------------------------------------------------------
 
+localparam [3:0] PS2_IDLE                   = 4'd0;
+localparam [3:0] PS2_SEND_INHIBIT           = 4'd1;
+localparam [3:0] PS2_SEND_INHIBIT_WAIT      = 4'd2;
+localparam [3:0] PS2_SEND_DATA_LOW          = 4'd3;
+localparam [3:0] PS2_SEND_CLOCK_RELEASE     = 4'd4;
+localparam [3:0] PS2_SEND_BITS              = 4'd5;
+localparam [3:0] PS2_SEND_WAIT_FOR_ACK      = 4'd6;
+localparam [3:0] PS2_SEND_WAIT_FOR_IDLE     = 4'd7;
+localparam [3:0] PS2_SEND_FINISHED          = 4'd8;
+localparam [3:0] PS2_RECV_START             = 4'd9;
+localparam [3:0] PS2_RECV_BITS              = 4'd10;
+localparam [3:0] PS2_RECV_WAIT_FOR_STOP     = 4'd11;
+localparam [3:0] PS2_RECV_WAIT_FOR_IDLE     = 4'd12;
+localparam [3:0] PS2_WAIT_START             = 4'd13;
+localparam [3:0] PS2_WAIT                   = 4'd14;
+localparam [3:0] PS2_WAIT_FINISH            = 4'd15;
 reg io_read_last;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) io_read_last <= 1'b0; else if(io_read_last) io_read_last <= 1'b0; else io_read_last <= io_read; end 
-wire io_read_valid = io_read && io_read_last == 1'b0;
+reg status_keyboardparityerror;
+reg status_timeout;
+reg status_lastcommand;
+reg translate;
+reg disable_mouse;
+reg disable_mouse_visible;
+reg disable_keyboard;
+reg status_system;
+reg allow_irq_mouse;
+reg allow_irq_keyb;
+reg status_mousebufferfull;
+reg status_outputbufferfull;
+reg expecting_port_60h;
+reg [7:0] last_command;
+reg [7:0] keyb_reply;
+reg keyb_reply_valid;
+reg [7:0] mouse_reply;
+reg mouse_reply_valid;
+reg status_inputbufferfull;
+reg input_write_done;
+reg input_for_mouse;
+reg [7:0] inputbuffer;
+reg ps2_kbclk_ena;
+reg ps2_kbclk_out;
+reg ps2_kbdat_ena;
+reg ps2_kbdat_out;
+reg [15:0] keyb_clk_mv;
+reg keyb_clk_mv_wait;
+reg was_ps2_kbclk;
+reg keyb_kbclk;
+reg keyb_kbdat;
+reg [25:0] keyb_timeout;
+reg [12:0] keyb_timer;
+reg [3:0] keyb_bit_counter;
+reg keyb_parity;
+reg [7:0] keyb_recv_buffer;
+reg keyb_recv_result;
+reg keyb_translate_escape;
+reg [7:0] trans;
+reg [3:0] keyb_state;
+reg [7:0] keyb_fifo_q_last;
+reg ps2_mouseclk_ena;
+reg ps2_mouseclk_out;
+reg ps2_mousedat_ena;
+reg ps2_mousedat_out;
+reg [15:0] mouse_clk_mv;
+reg mouse_clk_mv_wait;
+reg was_ps2_mouseclk;
+reg mouse_mouseclk;
+reg mouse_mousedat;
+reg [25:0] mouse_timeout;
+reg [12:0] mouse_timer;
+reg [3:0] mouse_bit_counter;
+reg mouse_parity;
+reg [7:0] mouse_recv_buffer;
+reg mouse_recv_result;
+reg [3:0] mouse_state;
+wire io_read_valid;
+wire [7:0] io_readdata_next ;
+wire [7:0] sysctl_readdata_next ;
+wire outputbuffer_idle;
+wire cmd_with_param_first_byte;
+wire cmd_with_param;
+wire cmd_without_param;
+wire cmd_write_command_byte;
+wire cmd_write_output_port;
+wire cmd_write_to_keyb_output;
+wire cmd_write_to_mouse_output;
+wire cmd_write_to_mouse;
+wire cmd_read_command_byte;
+wire cmd_disable_mouse;
+wire cmd_enable_mouse;
+wire cmd_test_mouse_port;
+wire cmd_self_test;
+wire cmd_interface_test;
+wire cmd_disable_keyb;
+wire cmd_enable_keyb;
+wire cmd_read_input_port;
+wire cmd_read_controller_mode;
+wire cmd_read_output_port;
+wire cmd_disable_a20;
+wire cmd_enable_a20;
+wire cmd_reset;
+wire [7:0] command_byte ;
+wire [7:0] output_port ;
+wire write_to_keyb;
+wire write_to_mouse;
+wire keyb_timeout_reset;
+wire keyb_recv;
+wire keyb_recv_ok;
+wire keyb_recv_parity_err;
+wire keyb_recv_final;
+wire [6:0] keyb_fifo_counter ;
+wire        keyb_fifo_full;
+wire [5:0]  keyb_fifo_usedw;
+wire [7:0]  keyb_fifo_q;
+wire [7:0]  keyb_fifo_qq;
+wire        keyb_fifo_empty;
+wire [7:0] keyb_fifo_q_final ;
+wire ps2_kb_write_shift;
+wire ps2_kb_write_done;
+wire ps2_kb_reply_done;
+wire mouse_timeout_reset;
+wire mouse_recv;
+wire mouse_recv_ok;
+wire mouse_recv_parity_err;
+wire mouse_recv_final;
+wire [6:0] mouse_fifo_counter ;
+wire        mouse_fifo_full;
+wire [5:0]  mouse_fifo_usedw;
+wire [7:0]  mouse_fifo_q;
+wire        mouse_fifo_empty;
+wire ps2_mouse_write_shift;
+wire ps2_mouse_write_done;
+wire ps2_mouse_reply_done;
+wire _unused_ok;
+
+wire [7:0] readdata_64h = {status_keyboardparityerror, status_timeout, status_mousebufferfull, 1'b1, 
+			  status_lastcommand, status_system, status_inputbufferfull, status_outputbufferfull};
+   
+always @(posedge clk) begin if(rst) io_read_last <= 1'b0; else if(io_read_last) io_read_last <= 1'b0; else io_read_last <= io_read; end 
+ assign io_read_valid = io_read/* && io_read_last == 1'b0*/;
 
 //------------------------------------------------------------------------------
 
@@ -78,7 +215,7 @@ assign speaker_61h_writedata    = io_writedata;
 
 //------------------------------------------------------------------------------ io read
 
-wire [7:0] io_readdata_next =
+ assign io_readdata_next =
     (io_read_valid && io_address == 3'd1)?        speaker_61h_readdata :
     (io_read_valid && io_address == 3'd4)? {
         status_keyboardparityerror,
@@ -93,34 +230,34 @@ wire [7:0] io_readdata_next =
     (status_mousebufferfull)?               mouse_fifo_q :
                                             keyb_fifo_q_final;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   io_readdata <= 8'd0;
+always @(posedge clk) begin
+    if(rst)   io_readdata <= 8'd0;
     else                io_readdata <= io_readdata_next;
 end
 
 //------------------------------------------------------------------------------ sysctl read
 
-wire [7:0] sysctl_readdata_next =
+ assign sysctl_readdata_next =
     (sysctl_address == 4'h2)?       { 6'd0, output_a20_enable, 1'b0 } :
                                     8'hFF;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   sysctl_readdata <= 8'd0;
+always @(posedge clk) begin
+    if(rst)   sysctl_readdata <= 8'd0;
     else                sysctl_readdata <= sysctl_readdata_next;
 end
 
 //------------------------------------------------------------------------------ output
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   output_a20_enable <= 1'b1;
+always @(posedge clk) begin
+    if(rst)                                   output_a20_enable <= 1'b1;
     else if(cmd_write_output_port)                      output_a20_enable <= io_writedata[1];
     else if(cmd_disable_a20)                            output_a20_enable <= 1'b0;
     else if(cmd_enable_a20)                             output_a20_enable <= 1'b1;
     else if(sysctl_write && sysctl_address == 4'h2)     output_a20_enable <= sysctl_writedata[1];
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       output_reset_n <= 1'b1;
+always @(posedge clk) begin
+    if(rst)                                                       output_reset_n <= 1'b1;
     else if(cmd_write_output_port)                                          output_reset_n <= io_writedata[0];
     else if(cmd_reset)                                                      output_reset_n <= 1'b0;
     else if(sysctl_write && sysctl_address == 4'h2 && sysctl_writedata[0])  output_reset_n <= 1'b0;
@@ -129,125 +266,111 @@ end
 
 //------------------------------------------------------------------------------
 
-reg status_keyboardparityerror;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       status_keyboardparityerror <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                       status_keyboardparityerror <= 1'b0;
     else if(keyb_recv_parity_err || mouse_recv_parity_err)  status_keyboardparityerror <= 1'b1;
     else if(io_read_valid && io_address == 3'd4)            status_keyboardparityerror <= 1'b0;
 end
 
-reg status_timeout;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   status_timeout <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                   status_timeout <= 1'b0;
     else if(keyb_timeout_reset || mouse_timeout_reset)  status_timeout <= 1'b1;
     else if(io_read_valid && io_address == 3'd4)        status_timeout <= 1'b0;
 end
 
-reg status_lastcommand;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           status_lastcommand <= 1'b1;
+always @(posedge clk) begin
+    if(rst)                           status_lastcommand <= 1'b1;
     else if(io_write && io_address == 3'd0)     status_lastcommand <= 1'b0;
     else if(io_write && io_address == 3'd4)     status_lastcommand <= 1'b1;
 end
 
-reg translate;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   translate <= 1'b1;
+always @(posedge clk) begin
+    if(rst)                   translate <= 1'b1;
     else if(cmd_write_command_byte)     translate <= io_writedata[6];
 end
 
-reg disable_mouse;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   disable_mouse <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   disable_mouse <= 1'b0;
     else if(cmd_write_command_byte)     disable_mouse <= io_writedata[5];
     else if(cmd_disable_mouse)          disable_mouse <= 1'b1;
     else if(cmd_enable_mouse)           disable_mouse <= 1'b0;
     else if(write_to_mouse)             disable_mouse <= 1'b0;
 end
 
-reg disable_mouse_visible;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   disable_mouse_visible <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   disable_mouse_visible <= 1'b0;
     else if(cmd_write_command_byte)     disable_mouse_visible <= io_writedata[5];
     else if(cmd_disable_mouse)          disable_mouse_visible <= 1'b1;
     else if(cmd_enable_mouse)           disable_mouse_visible <= 1'b0;
 end
 
-reg disable_keyboard;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   disable_keyboard <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   disable_keyboard <= 1'b0;
     else if(cmd_write_command_byte)     disable_keyboard <= io_writedata[4];
     else if(cmd_disable_keyb)           disable_keyboard <= 1'b1;
     else if(cmd_enable_keyb)            disable_keyboard <= 1'b0;
     else if(write_to_keyb)              disable_keyboard <= 1'b0;
 end
 
-reg status_system;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   status_system <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   status_system <= 1'b0;
     else if(cmd_write_command_byte)     status_system <= io_writedata[2];
     else if(cmd_self_test)              status_system <= 1'b1;
 end
 
-reg allow_irq_mouse;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   allow_irq_mouse <= 1'b1;
+always @(posedge clk) begin
+    if(rst)                   allow_irq_mouse <= 1'b1;
     else if(cmd_write_command_byte)     allow_irq_mouse <= io_writedata[1];
 end
 
-reg allow_irq_keyb;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   allow_irq_keyb <= 1'b1;
+always @(posedge clk) begin
+    if(rst)                   allow_irq_keyb <= 1'b1;
     else if(cmd_write_command_byte)     allow_irq_keyb <= io_writedata[0];
 end
 
 //------------------------------------------------------------------------------ interrupts
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                       irq_keyb <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                                                       irq_keyb <= 1'b0;
     else if(io_read_valid && io_address == 3'd0 && status_outputbufferfull && ~(status_mousebufferfull))    irq_keyb <= 1'b0;
     else if(allow_irq_keyb && status_outputbufferfull && ~(status_mousebufferfull))                         irq_keyb <= 1'b1;
 end
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       irq_mouse <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                       irq_mouse <= 1'b0;
     else if(io_read_valid && io_address == 3'd0 && status_mousebufferfull)  irq_mouse <= 1'b0;
     else if(allow_irq_mouse && status_mousebufferfull)                      irq_mouse <= 1'b1;
 end
 
-wire outputbuffer_idle = ~(status_mousebufferfull) && ~(status_outputbufferfull);
+ assign outputbuffer_idle = ~(status_mousebufferfull) && ~(status_outputbufferfull);
 
-reg status_mousebufferfull;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   status_mousebufferfull <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                   status_mousebufferfull <= 1'b0;
     else if(io_read_valid && io_address == 3'd0)        status_mousebufferfull <= 1'b0;
     else if(outputbuffer_idle && ~(mouse_fifo_empty))   status_mousebufferfull <= 1'b1;
 end
 
-reg status_outputbufferfull;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           status_outputbufferfull <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                           status_outputbufferfull <= 1'b0;
     else if(io_read_valid && io_address == 3'd0)                                status_outputbufferfull <= 1'b0;
     else if(outputbuffer_idle && (~(mouse_fifo_empty) || ~(keyb_fifo_empty)))   status_outputbufferfull <= 1'b1;
 end
 
 //------------------------------------------------------------------------------ io write / controller commands
 
-reg expecting_port_60h;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           expecting_port_60h <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                           expecting_port_60h <= 1'b0;
     else if(io_write && io_address == 3'd0)     expecting_port_60h <= 1'b0;
     else if(cmd_with_param_first_byte)          expecting_port_60h <= 1'b1;
     else if(io_write && io_address == 3'd4)     expecting_port_60h <= 1'b0;
 end
 
-reg [7:0] last_command;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           last_command <= 8'h00;
+always @(posedge clk) begin
+    if(rst)                           last_command <= 8'h00;
     else if(io_write && io_address == 3'd4)     last_command <= io_writedata;
 end
 
-wire cmd_with_param_first_byte  = io_write && io_address == 3'd4 && (
+ assign cmd_with_param_first_byte = io_write && io_address == 3'd4 && (
     io_writedata == 8'h60 || //write command byte
     io_writedata == 8'hCB || //write keyboard controller mode
     io_writedata == 8'hD1 || //write output port
@@ -256,33 +379,33 @@ wire cmd_with_param_first_byte  = io_write && io_address == 3'd4 && (
     io_writedata == 8'hD2    //write keyboard output buffer
 );
 
-wire cmd_with_param             = io_write && io_address == 3'd0 && expecting_port_60h && ~(status_inputbufferfull);
-wire cmd_without_param          = io_write && io_address == 3'd4 && ~(cmd_with_param_first_byte);
-
-wire cmd_write_command_byte     = cmd_with_param && last_command == 8'h60;
-wire cmd_write_output_port      = cmd_with_param && last_command == 8'hD1;
-wire cmd_write_to_keyb_output   = cmd_with_param && last_command == 8'hD2;
-wire cmd_write_to_mouse_output  = cmd_with_param && last_command == 8'hD3;
-wire cmd_write_to_mouse         = cmd_with_param && last_command == 8'hD4;
-
-wire cmd_read_command_byte      = cmd_without_param && io_writedata == 8'h20;
-wire cmd_disable_mouse          = cmd_without_param && io_writedata == 8'hA7;
-wire cmd_enable_mouse           = cmd_without_param && io_writedata == 8'hA8;
-wire cmd_test_mouse_port        = cmd_without_param && io_writedata == 8'hA9;
-wire cmd_self_test              = cmd_without_param && io_writedata == 8'hAA;
-wire cmd_interface_test         = cmd_without_param && io_writedata == 8'hAB;
-wire cmd_disable_keyb           = cmd_without_param && io_writedata == 8'hAD;
-wire cmd_enable_keyb            = cmd_without_param && io_writedata == 8'hAE;
-wire cmd_read_input_port        = cmd_without_param && io_writedata == 8'hC0;
-wire cmd_read_controller_mode   = cmd_without_param && io_writedata == 8'hCA;
-wire cmd_read_output_port       = cmd_without_param && io_writedata == 8'hD0;
-wire cmd_disable_a20            = cmd_without_param && io_writedata == 8'hDD;
-wire cmd_enable_a20             = cmd_without_param && io_writedata == 8'hDF;
-wire cmd_reset                  = cmd_without_param && io_writedata == 8'hFE;
+ assign cmd_with_param = io_write && io_address == 3'd0 && expecting_port_60h && ~(status_inputbufferfull);
+ assign cmd_without_param = io_write && io_address == 3'd4 && ~(cmd_with_param_first_byte);
+
+ assign cmd_write_command_byte = cmd_with_param && last_command == 8'h60;
+ assign cmd_write_output_port = cmd_with_param && last_command == 8'hD1;
+ assign cmd_write_to_keyb_output = cmd_with_param && last_command == 8'hD2;
+ assign cmd_write_to_mouse_output = cmd_with_param && last_command == 8'hD3;
+ assign cmd_write_to_mouse = cmd_with_param && last_command == 8'hD4;
+
+ assign cmd_read_command_byte = cmd_without_param && io_writedata == 8'h20;
+ assign cmd_disable_mouse = cmd_without_param && io_writedata == 8'hA7;
+ assign cmd_enable_mouse = cmd_without_param && io_writedata == 8'hA8;
+ assign cmd_test_mouse_port = cmd_without_param && io_writedata == 8'hA9;
+ assign cmd_self_test = cmd_without_param && io_writedata == 8'hAA;
+ assign cmd_interface_test = cmd_without_param && io_writedata == 8'hAB;
+ assign cmd_disable_keyb = cmd_without_param && io_writedata == 8'hAD;
+ assign cmd_enable_keyb = cmd_without_param && io_writedata == 8'hAE;
+ assign cmd_read_input_port = cmd_without_param && io_writedata == 8'hC0;
+ assign cmd_read_controller_mode = cmd_without_param && io_writedata == 8'hCA;
+ assign cmd_read_output_port = cmd_without_param && io_writedata == 8'hD0;
+ assign cmd_disable_a20 = cmd_without_param && io_writedata == 8'hDD;
+ assign cmd_enable_a20 = cmd_without_param && io_writedata == 8'hDF;
+ assign cmd_reset = cmd_without_param && io_writedata == 8'hFE;
 
 //------------------------------------------------------------------------------ controller reply - not device
 
-wire [7:0] command_byte = {
+ assign command_byte = {
     1'b0,
     translate,
     disable_mouse_visible,
@@ -293,7 +416,7 @@ wire [7:0] command_byte = {
     allow_irq_keyb
 };
 
-wire [7:0] output_port = {
+ assign output_port = {
     1'b0,
     1'b0,
     irq_mouse,
@@ -304,9 +427,8 @@ wire [7:0] output_port = {
     1'b1
 };
 
-reg [7:0] keyb_reply;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   keyb_reply <= 8'h00;
+always @(posedge clk) begin
+    if(rst)                   keyb_reply <= 8'h00;
     else if(cmd_write_to_keyb_output)   keyb_reply <= io_writedata;
     else if(cmd_read_command_byte)      keyb_reply <= command_byte;
     else if(cmd_test_mouse_port)        keyb_reply <= 8'h00;
@@ -317,9 +439,8 @@ always @(posedge clk or negedge rst_n) begin
     else if(cmd_read_output_port)       keyb_reply <= output_port;
 end
 
-reg keyb_reply_valid;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   keyb_reply_valid <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   keyb_reply_valid <= 1'b0;
     else if(cmd_write_to_keyb_output)   keyb_reply_valid <= 1'b1;
     else if(cmd_read_command_byte)      keyb_reply_valid <= 1'b1;
     else if(cmd_test_mouse_port)        keyb_reply_valid <= 1'b1;
@@ -331,48 +452,42 @@ always @(posedge clk or negedge rst_n) begin
     else if(ps2_kb_reply_done)          keyb_reply_valid <= 1'b0;
 end
 
-reg [7:0] mouse_reply;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   mouse_reply <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                   mouse_reply <= 8'd0;
     else if(cmd_write_to_mouse_output)  mouse_reply <= io_writedata;
 end
 
-reg mouse_reply_valid;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                   mouse_reply_valid <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                   mouse_reply_valid <= 1'b0;
     else if(cmd_write_to_mouse_output)  mouse_reply_valid <= 1'b1;
     else if(ps2_mouse_reply_done)       mouse_reply_valid <= 1'b0;
 end
 
 //------------------------------------------------------------------------------ write to device
 
-wire write_to_keyb  = io_write && io_address == 3'd0 && ~(expecting_port_60h) && ~(status_inputbufferfull);
-wire write_to_mouse = cmd_write_to_mouse;
+ assign write_to_keyb = io_write && io_address == 3'd0 && ~(expecting_port_60h) && ~(status_inputbufferfull);
+ assign write_to_mouse = cmd_write_to_mouse;
 
-reg status_inputbufferfull;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       status_inputbufferfull <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                       status_inputbufferfull <= 1'b0;
     else if(write_to_keyb || write_to_mouse)                status_inputbufferfull <= 1'b1;
     else if(input_write_done && status_outputbufferfull)    status_inputbufferfull <= 1'b0;
 end
 
-reg input_write_done;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   input_write_done <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                   input_write_done <= 1'b0;
     else if(write_to_keyb || write_to_mouse)            input_write_done <= 1'b0;
     else if(ps2_kb_write_done || ps2_mouse_write_done)  input_write_done <= 1'b1;
 end
 
-reg input_for_mouse;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)       input_for_mouse <= 1'b0;
+always @(posedge clk) begin
+    if(rst)       input_for_mouse <= 1'b0;
     else if(write_to_keyb)  input_for_mouse <= 1'b0;
     else if(write_to_mouse) input_for_mouse <= 1'b1;
 end
 
-reg [7:0] inputbuffer;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       inputbuffer <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                       inputbuffer <= 8'd0;
     else if(write_to_keyb || write_to_mouse)                inputbuffer <= io_writedata;
     else if(ps2_kb_write_shift || ps2_mouse_write_shift)    inputbuffer <= { 1'b0, inputbuffer[7:1] };
 end
@@ -382,41 +497,34 @@ end
 assign ps2_kbclk    = (ps2_kbclk_ena)?      ps2_kbclk_out       : 1'bZ;
 assign ps2_kbdat    = (ps2_kbdat_ena)?      ps2_kbdat_out       : 1'bZ;
 
-reg ps2_kbclk_ena;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                               ps2_kbclk_ena <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                               ps2_kbclk_ena <= 1'b0;
     else if(keyb_timeout_reset)                                                     ps2_kbclk_ena <= 1'b0;
     else if(keyb_state == PS2_SEND_INHIBIT || keyb_state == PS2_WAIT_START)         ps2_kbclk_ena <= 1'b1;
     else if(keyb_state == PS2_SEND_CLOCK_RELEASE || keyb_state == PS2_WAIT_FINISH)  ps2_kbclk_ena <= 1'b0;
 end
 
-reg ps2_kbclk_out;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           ps2_kbclk_out <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                           ps2_kbclk_out <= 1'b0;
     else if(keyb_state == PS2_SEND_INHIBIT || keyb_state == PS2_WAIT_START)     ps2_kbclk_out <= 1'b0;
 end
 
-reg ps2_kbdat_ena;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                           ps2_kbdat_ena <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                           ps2_kbdat_ena <= 1'b0;
     else if(keyb_timeout_reset)                                 ps2_kbdat_ena <= 1'b0;
     else if(keyb_state == PS2_SEND_DATA_LOW)                    ps2_kbdat_ena <= 1'b1;
     else if(ps2_kb_write_shift && keyb_bit_counter == 4'd9)     ps2_kbdat_ena <= 1'b0;  //stop bit
 end
 
-reg ps2_kbdat_out;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       ps2_kbdat_out <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                       ps2_kbdat_out <= 1'b0;
     else if(keyb_state == PS2_SEND_DATA_LOW)                ps2_kbdat_out <= 1'b0;              //start bit
     else if(ps2_kb_write_shift && keyb_bit_counter < 4'd8)  ps2_kbdat_out <= inputbuffer[0];    //data bits
     else if(ps2_kb_write_shift && keyb_bit_counter == 4'd8) ps2_kbdat_out <= ~(keyb_parity);    //parity bit
 end
 
-reg [15:0] keyb_clk_mv;
-reg keyb_clk_mv_wait;
-reg was_ps2_kbclk;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) begin
+always @(posedge clk) begin
+    if(rst) begin
         keyb_clk_mv         <= 16'd0;
         keyb_clk_mv_wait    <= 1'b0;
         was_ps2_kbclk       <= 1'b0;
@@ -438,31 +546,27 @@ always @(posedge clk or negedge rst_n) begin
     end
 end
 
-reg keyb_kbclk;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   keyb_kbclk <= 1'b1;
+always @(posedge clk) begin
+    if(rst)   keyb_kbclk <= 1'b1;
     else                keyb_kbclk <= ps2_kbclk;
 end    
 
-reg keyb_kbdat;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   keyb_kbdat <= 1'b1;
+always @(posedge clk) begin
+    if(rst)   keyb_kbdat <= 1'b1;
     else                keyb_kbdat <= ps2_kbdat;
 end    
 
-reg [25:0] keyb_timeout;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       keyb_timeout <= 26'h0;
+always @(posedge clk) begin
+    if(rst)                                                       keyb_timeout <= 26'h0;
     else if(keyb_state == PS2_SEND_INHIBIT || keyb_state == PS2_RECV_START) keyb_timeout <= 26'h3FFFFFF;
     else if(keyb_state == PS2_IDLE)                                         keyb_timeout <= 26'h0;
     else if(keyb_timeout > 26'd0)                                           keyb_timeout <= keyb_timeout - 26'd1;
 end
 
-wire keyb_timeout_reset = keyb_timeout == 26'd1;
+ assign keyb_timeout_reset = keyb_timeout == 26'd1;
 
-reg [12:0] keyb_timer;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           keyb_timer <= 13'd0;
+always @(posedge clk) begin
+    if(rst)                           keyb_timer <= 13'd0;
     else if(keyb_timeout_reset)                 keyb_timer <= 13'd0;                  
     
     else if(keyb_state == PS2_SEND_INHIBIT)     keyb_timer <= 13'd8191;
@@ -471,9 +575,8 @@ always @(posedge clk or negedge rst_n) begin
     else if(keyb_timer > 13'd0)                 keyb_timer <= keyb_timer - 13'd1;
 end
 
-reg [3:0] keyb_bit_counter;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               keyb_bit_counter <= 4'd0;
+always @(posedge clk) begin
+    if(rst)                               keyb_bit_counter <= 4'd0;
     else if(keyb_timeout_reset)                     keyb_bit_counter <= 4'd0;
     
     else if(keyb_state == PS2_SEND_CLOCK_RELEASE)   keyb_bit_counter <= 4'd0;
@@ -483,9 +586,8 @@ always @(posedge clk or negedge rst_n) begin
     else if(keyb_recv)                              keyb_bit_counter <= keyb_bit_counter + 4'd1;
 end
 
-reg keyb_parity;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               keyb_parity <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                               keyb_parity <= 1'b0;
     
     else if(keyb_state == PS2_SEND_CLOCK_RELEASE)   keyb_parity <= 1'b0;
     else if(ps2_kb_write_shift)                     keyb_parity <= keyb_parity ^ inputbuffer[0];
@@ -494,34 +596,30 @@ always @(posedge clk or negedge rst_n) begin
     else if(keyb_recv)                              keyb_parity <= keyb_parity ^ keyb_kbdat;
 end
 
-reg [7:0] keyb_recv_buffer;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               keyb_recv_buffer <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                               keyb_recv_buffer <= 8'd0;
     else if(keyb_recv && keyb_bit_counter < 4'd8)   keyb_recv_buffer <= { keyb_kbdat, keyb_recv_buffer[7:1] };
 end
 
-wire keyb_recv              = keyb_state == PS2_RECV_BITS && was_ps2_kbclk;
-wire keyb_recv_ok           = keyb_recv && keyb_bit_counter == 4'd8 && ~(keyb_parity) == keyb_kbdat;
-wire keyb_recv_parity_err   = keyb_recv && keyb_bit_counter == 4'd8 && ~(keyb_parity) != keyb_kbdat;
+ assign keyb_recv = keyb_state == PS2_RECV_BITS && was_ps2_kbclk;
+ assign keyb_recv_ok = keyb_recv && keyb_bit_counter == 4'd8 && ~(keyb_parity) == keyb_kbdat;
+ assign keyb_recv_parity_err = keyb_recv && keyb_bit_counter == 4'd8 && ~(keyb_parity) != keyb_kbdat;
 
-reg keyb_recv_result;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                      keyb_recv_result <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                      keyb_recv_result <= 1'b0;
     else if(keyb_state == PS2_RECV_BITS)   keyb_recv_result <= keyb_recv_ok;
 end
-wire keyb_recv_final = keyb_state == PS2_RECV_WAIT_FOR_IDLE && keyb_kbclk == 1'b1 && keyb_kbdat == 1'b1 && keyb_recv_result;
+ assign keyb_recv_final = keyb_state == PS2_RECV_WAIT_FOR_IDLE && keyb_kbclk == 1'b1 && keyb_kbdat == 1'b1 && keyb_recv_result;
 
-reg keyb_translate_escape;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       keyb_translate_escape <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                       keyb_translate_escape <= 1'b0;
     else if(keyb_timeout_reset)                             keyb_translate_escape <= 1'b0;
     else if(keyb_recv_ok && keyb_translate_escape == 1'b0)  keyb_translate_escape <= translate && keyb_recv_buffer == 8'hF0;
     else if(keyb_recv_final && keyb_recv_buffer != 8'hF0)   keyb_translate_escape <= 1'b0;
 end
 
-reg [7:0] trans;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   trans <= 8'd0;
+always @(posedge clk) begin
+    if(rst)   trans <= 8'd0;
     else begin
         case(keyb_recv_buffer)
             8'h00: trans <= 8'hff; 8'h01: trans <= 8'h43; 8'h02: trans <= 8'h41; 8'h03: trans <= 8'h3f; 8'h04: trans <= 8'h3d; 8'h05: trans <= 8'h3b; 8'h06: trans <= 8'h3c; 8'h07: trans <= 8'h58;
@@ -547,30 +645,13 @@ always @(posedge clk or negedge rst_n) begin
     end
 end
   
-localparam [3:0] PS2_IDLE                   = 4'd0;
 
-localparam [3:0] PS2_SEND_INHIBIT           = 4'd1;
-localparam [3:0] PS2_SEND_INHIBIT_WAIT      = 4'd2;
-localparam [3:0] PS2_SEND_DATA_LOW          = 4'd3;
-localparam [3:0] PS2_SEND_CLOCK_RELEASE     = 4'd4;
-localparam [3:0] PS2_SEND_BITS              = 4'd5;
-localparam [3:0] PS2_SEND_WAIT_FOR_ACK      = 4'd6;
-localparam [3:0] PS2_SEND_WAIT_FOR_IDLE     = 4'd7;
-localparam [3:0] PS2_SEND_FINISHED          = 4'd8;
 
-localparam [3:0] PS2_RECV_START             = 4'd9;
-localparam [3:0] PS2_RECV_BITS              = 4'd10;
-localparam [3:0] PS2_RECV_WAIT_FOR_STOP     = 4'd11;
-localparam [3:0] PS2_RECV_WAIT_FOR_IDLE     = 4'd12;
 
-localparam [3:0] PS2_WAIT_START             = 4'd13;
-localparam [3:0] PS2_WAIT                   = 4'd14;
-localparam [3:0] PS2_WAIT_FINISH            = 4'd15;
 
-reg [3:0] keyb_state;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                               keyb_state <= PS2_IDLE;
+always @(posedge clk) begin
+    if(rst)                                                                                               keyb_state <= PS2_IDLE;
     else if(keyb_timeout_reset)                                                                                     keyb_state <= PS2_IDLE;
     
     //buffer full
@@ -601,26 +682,23 @@ always @(posedge clk or negedge rst_n) begin
     else if(keyb_state == PS2_RECV_WAIT_FOR_IDLE && keyb_kbclk == 1'b1 && keyb_kbdat == 1'b1)       keyb_state <= PS2_IDLE;
 end
 
-wire [6:0]  keyb_fifo_counter = { keyb_fifo_full, keyb_fifo_usedw };
-wire        keyb_fifo_full;
-wire [5:0]  keyb_fifo_usedw;
+ assign keyb_fifo_counter = { keyb_fifo_full, keyb_fifo_usedw };
 
-wire [7:0]  keyb_fifo_q;
-wire        keyb_fifo_empty;
 
-wire [7:0] keyb_fifo_q_final = (keyb_fifo_empty)? keyb_fifo_q_last : keyb_fifo_q;
+ assign keyb_fifo_q_final = (keyb_fifo_empty)? keyb_fifo_q_last : keyb_fifo_q;
 
-reg [7:0] keyb_fifo_q_last;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)           keyb_fifo_q_last <= 8'd0;
+always @(posedge clk) begin
+    if(rst)           keyb_fifo_q_last <= 8'd0;
     else if(~(keyb_fifo_empty)) keyb_fifo_q_last <= keyb_fifo_q;
 end
 
-wire ps2_kb_write_shift = keyb_state == PS2_SEND_BITS && was_ps2_kbclk;
+ assign ps2_kb_write_shift = keyb_state == PS2_SEND_BITS && was_ps2_kbclk;
 
-wire ps2_kb_write_done = keyb_state == PS2_SEND_FINISHED;
+ assign ps2_kb_write_done = keyb_state == PS2_SEND_FINISHED;
 
-wire ps2_kb_reply_done = keyb_reply_valid && keyb_fifo_counter < 7'd60 && ~(keyb_recv_final);
+ assign ps2_kb_reply_done = keyb_reply_valid && keyb_fifo_counter < 7'd60 && ~(keyb_recv_final);
+
+ assign keyb_fifo_q = (keyb_fifo_qq[6:0] == 7'h3A) ? {keyb_fifo_qq[7], 7'h1D} : (keyb_fifo_qq[6:0] == 7'h1D) ? {keyb_fifo_qq[7], 7'h3A}  : keyb_fifo_qq;
 
 simple_fifo #(
     .width      (8),
@@ -628,7 +706,7 @@ simple_fifo #(
 )
 keyb_fifo(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
     
     .sclr       (cmd_self_test),                                                                                                //input
     
@@ -638,7 +716,7 @@ keyb_fifo(
     .usedw      (keyb_fifo_usedw),                                                                                              //output [5:0]
     
     .rdreq      (io_read_valid && io_address == 3'd0 && status_outputbufferfull && ~(status_mousebufferfull)),                  //input
-    .q          (keyb_fifo_q),                                                                                                  //output [7:0]
+    .q          (keyb_fifo_qq),                                                                                                  //output [7:0]
     .empty      (keyb_fifo_empty)                                                                                               //output
 );
 
@@ -647,41 +725,34 @@ keyb_fifo(
 assign ps2_mouseclk    = (ps2_mouseclk_ena)?      ps2_mouseclk_out       : 1'bZ;
 assign ps2_mousedat    = (ps2_mousedat_ena)?      ps2_mousedat_out       : 1'bZ;
 
-reg ps2_mouseclk_ena;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                   ps2_mouseclk_ena <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                                   ps2_mouseclk_ena <= 1'b0;
     else if(mouse_timeout_reset)                                                        ps2_mouseclk_ena <= 1'b0;
     else if(mouse_state == PS2_SEND_INHIBIT || mouse_state == PS2_WAIT_START)           ps2_mouseclk_ena <= 1'b1;
     else if(mouse_state == PS2_SEND_CLOCK_RELEASE || mouse_state == PS2_WAIT_FINISH)    ps2_mouseclk_ena <= 1'b0;
 end
 
-reg ps2_mouseclk_out;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           ps2_mouseclk_out <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                           ps2_mouseclk_out <= 1'b0;
     else if(mouse_state == PS2_SEND_INHIBIT || mouse_state == PS2_WAIT_START)   ps2_mouseclk_out <= 1'b0;
 end
 
-reg ps2_mousedat_ena;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               ps2_mousedat_ena <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                               ps2_mousedat_ena <= 1'b0;
     else if(mouse_timeout_reset)                                    ps2_mousedat_ena <= 1'b0;
     else if(mouse_state == PS2_SEND_DATA_LOW)                       ps2_mousedat_ena <= 1'b1;
     else if(ps2_mouse_write_shift && mouse_bit_counter == 4'd9)     ps2_mousedat_ena <= 1'b0;  //stop bit
 end
 
-reg ps2_mousedat_out;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                           ps2_mousedat_out <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                           ps2_mousedat_out <= 1'b0;
     else if(mouse_state == PS2_SEND_DATA_LOW)                   ps2_mousedat_out <= 1'b0;               //start bit
     else if(ps2_mouse_write_shift && mouse_bit_counter < 4'd8)  ps2_mousedat_out <= inputbuffer[0];     //data bits
     else if(ps2_mouse_write_shift && mouse_bit_counter == 4'd8) ps2_mousedat_out <= ~(mouse_parity);    //parity bit
 end
 
-reg [15:0] mouse_clk_mv;
-reg mouse_clk_mv_wait;
-reg was_ps2_mouseclk;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0) begin
+always @(posedge clk) begin
+    if(rst) begin
         mouse_clk_mv         <= 16'd0;
         mouse_clk_mv_wait    <= 1'b0;
         was_ps2_mouseclk       <= 1'b0;
@@ -703,31 +774,27 @@ always @(posedge clk or negedge rst_n) begin
     end
 end
 
-reg mouse_mouseclk;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   mouse_mouseclk <= 1'b1;
+always @(posedge clk) begin
+    if(rst)   mouse_mouseclk <= 1'b1;
     else                mouse_mouseclk <= ps2_mouseclk;
 end    
 
-reg mouse_mousedat;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   mouse_mousedat <= 1'b1;
+always @(posedge clk) begin
+    if(rst)   mouse_mousedat <= 1'b1;
     else                mouse_mousedat <= ps2_mousedat;
 end
 
-reg [25:0] mouse_timeout;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                           mouse_timeout <= 26'h0;
+always @(posedge clk) begin
+    if(rst)                                                           mouse_timeout <= 26'h0;
     else if(mouse_state == PS2_SEND_INHIBIT || mouse_state == PS2_RECV_START)   mouse_timeout <= 26'h3FFFFFF;
     else if(mouse_state == PS2_IDLE)                                            mouse_timeout <= 26'h0;
     else if(mouse_timeout > 26'd0)                                              mouse_timeout <= mouse_timeout - 26'd1;
 end
 
-wire mouse_timeout_reset = mouse_timeout == 26'd1;
+ assign mouse_timeout_reset = mouse_timeout == 26'd1;
 
-reg [12:0] mouse_timer;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                           mouse_timer <= 13'd0;
+always @(posedge clk) begin
+    if(rst)                           mouse_timer <= 13'd0;
     else if(mouse_timeout_reset)                mouse_timer <= 13'd0;
     else if(mouse_state == PS2_SEND_INHIBIT)    mouse_timer <= 13'd8191;
     else if(mouse_state == PS2_WAIT_START)      mouse_timer <= 13'd8191;
@@ -735,9 +802,8 @@ always @(posedge clk or negedge rst_n) begin
     else if(mouse_timer > 13'd0)                mouse_timer <= mouse_timer - 13'd1;
 end
 
-reg [3:0] mouse_bit_counter;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               mouse_bit_counter <= 4'd0;
+always @(posedge clk) begin
+    if(rst)                               mouse_bit_counter <= 4'd0;
     else if(mouse_timeout_reset)                    mouse_bit_counter <= 4'd0;
     
     else if(mouse_state == PS2_SEND_CLOCK_RELEASE)  mouse_bit_counter <= 4'd0;
@@ -747,9 +813,8 @@ always @(posedge clk or negedge rst_n) begin
     else if(mouse_recv)                             mouse_bit_counter <= mouse_bit_counter + 4'd1;
 end
 
-reg mouse_parity;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               mouse_parity <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                               mouse_parity <= 1'b0;
     
     else if(mouse_state == PS2_SEND_CLOCK_RELEASE)  mouse_parity <= 1'b0;
     else if(ps2_mouse_write_shift)                  mouse_parity <= mouse_parity ^ inputbuffer[0];
@@ -758,27 +823,24 @@ always @(posedge clk or negedge rst_n) begin
     else if(mouse_recv)                             mouse_parity <= mouse_parity ^ mouse_mousedat;
 end
 
-reg [7:0] mouse_recv_buffer;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               mouse_recv_buffer <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                               mouse_recv_buffer <= 8'd0;
     else if(mouse_recv && mouse_bit_counter < 4'd8) mouse_recv_buffer <= { mouse_mousedat, mouse_recv_buffer[7:1] };
 end
 
-wire mouse_recv              = mouse_state == PS2_RECV_BITS && was_ps2_mouseclk;
-wire mouse_recv_ok           = mouse_recv && mouse_bit_counter == 4'd8 && ~(mouse_parity) == mouse_mousedat;
-wire mouse_recv_parity_err   = mouse_recv && mouse_bit_counter == 4'd8 && ~(mouse_parity) != mouse_mousedat;
+ assign mouse_recv = mouse_state == PS2_RECV_BITS && was_ps2_mouseclk;
+ assign mouse_recv_ok = mouse_recv && mouse_bit_counter == 4'd8 && ~(mouse_parity) == mouse_mousedat;
+ assign mouse_recv_parity_err = mouse_recv && mouse_bit_counter == 4'd8 && ~(mouse_parity) != mouse_mousedat;
 
-reg mouse_recv_result;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       mouse_recv_result <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                       mouse_recv_result <= 1'b0;
     else if(mouse_state == PS2_RECV_BITS)   mouse_recv_result <= mouse_recv_ok;
 end
-wire mouse_recv_final = mouse_state == PS2_RECV_WAIT_FOR_IDLE && mouse_mouseclk == 1'b1 && mouse_mousedat == 1'b1 && mouse_recv_result;
+ assign mouse_recv_final = mouse_state == PS2_RECV_WAIT_FOR_IDLE && mouse_mouseclk == 1'b1 && mouse_mousedat == 1'b1 && mouse_recv_result;
 
-reg [3:0] mouse_state;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                                       mouse_state <= PS2_IDLE;
+always @(posedge clk) begin
+    if(rst)                                                                                                       mouse_state <= PS2_IDLE;
     else if(mouse_timeout_reset)                                                                                            mouse_state <= PS2_IDLE;
     
     //buffer full
@@ -809,18 +871,14 @@ always @(posedge clk or negedge rst_n) begin
     else if(mouse_state == PS2_RECV_WAIT_FOR_IDLE && mouse_mouseclk == 1'b1 && mouse_mousedat == 1'b1)  mouse_state <= PS2_IDLE;
 end
 
-wire [6:0]  mouse_fifo_counter = { mouse_fifo_full, mouse_fifo_usedw };
-wire        mouse_fifo_full;
-wire [5:0]  mouse_fifo_usedw;
+ assign mouse_fifo_counter = { mouse_fifo_full, mouse_fifo_usedw };
 
-wire [7:0]  mouse_fifo_q;
-wire        mouse_fifo_empty;
 
-wire ps2_mouse_write_shift = mouse_state == PS2_SEND_BITS && was_ps2_mouseclk;
+ assign ps2_mouse_write_shift = mouse_state == PS2_SEND_BITS && was_ps2_mouseclk;
 
-wire ps2_mouse_write_done = mouse_state == PS2_SEND_FINISHED;
+ assign ps2_mouse_write_done = mouse_state == PS2_SEND_FINISHED;
 
-wire ps2_mouse_reply_done = mouse_reply_valid && mouse_fifo_counter < 7'd60 && ~(mouse_recv_final);
+ assign ps2_mouse_reply_done = mouse_reply_valid && mouse_fifo_counter < 7'd60 && ~(mouse_recv_final);
 
 simple_fifo #(
     .width      (8),
@@ -828,7 +886,7 @@ simple_fifo #(
 )
 mouse_fifo(
     .clk        (clk),
-    .rst_n      (rst_n),
+    .rst      (rst),
     
     .sclr       (cmd_self_test),                                                //input
     
@@ -845,9 +903,9 @@ mouse_fifo(
 //------------------------------------------------------------------------------
 
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, sysctl_read, sysctl_writedata[7:2], 1'b0 };
+ assign _unused_ok = &{ 1'b0, sysctl_read, sysctl_writedata[7:2], 1'b0 };
 // synthesis translate_on
 
 //------------------------------------------------------------------------------
-
+   
 endmodule
diff --git a/rtl/soc/rtc/rtc.v b/rtl/soc/rtc/rtc.v
index 3584f8e..fb31f4c 100644
--- a/rtl/soc/rtc/rtc.v
+++ b/rtl/soc/rtc/rtc.v
@@ -1,17 +1,17 @@
 /*
  * Copyright (c) 2014, Aleksander Osman
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
- * 
+ *
  * * Redistributions of source code must retain the above copyright notice, this
  *   list of conditions and the following disclaimer.
- * 
+ *
  * * Redistributions in binary form must reproduce the above copyright notice,
  *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
@@ -24,19 +24,21 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+`include "../rtl/params.v"
+
 module rtc(
     input               clk,
-    input               rst_n,
-    
+    input               rst,
+
     output reg          irq,
-    
+
     //io slave
     input               io_address,
     input               io_read,
     output reg  [7:0]   io_readdata,
     input               io_write,
     input       [7:0]   io_writedata,
-    
+
     //mgmt slave
     /*
     128.[26:0]: cycles in second
@@ -49,27 +51,101 @@ module rtc(
 
 //------------------------------------------------------------------------------
 
+   localparam [2:0] SEC_UPDATE_START       = 3'd0;
+localparam [2:0] SEC_UPDATE_IN_PROGRESS = 3'd1;
+localparam [2:0] SEC_SECOND_START       = 3'd2;
+localparam [2:0] SEC_SECOND_IN_PROGRESS = 3'd3;
+localparam [2:0] SEC_STOPPED            = 3'd4;
 reg io_read_last;
-always @(posedge clk or negedge rst_n) begin if(rst_n == 1'b0) io_read_last <= 1'b0; else if(io_read_last) io_read_last <= 1'b0; else io_read_last <= io_read; end 
-wire io_read_valid = io_read && io_read_last == 1'b0;
+reg [26:0] cycles_in_second;
+reg [12:0] cycles_in_122us;
+reg [2:0] sec_state;
+reg [26:0] sec_timeout;
+reg update_interrupt;
+reg [7:0] rtc_second;
+reg [7:0] rtc_minute;
+reg [7:0] rtc_hour;
+reg [7:0] rtc_dayofweek;
+reg [7:0] rtc_dayofmonth;
+reg [7:0] rtc_month;
+reg [7:0] rtc_year;
+reg [7:0] rtc_century;
+reg [7:0] alarm_second;
+reg [7:0] alarm_minute;
+reg [7:0] alarm_hour;
+reg alarm_interrupt;
+reg crb_freeze;
+reg crb_int_periodic_ena;
+reg crb_int_alarm_ena;
+reg crb_int_update_ena;
+reg crb_binarymode;
+reg crb_24hour;
+reg crb_daylightsaving;
+reg [2:0] divider;
+reg [3:0] periodic_rate;
+reg [12:0] periodic_minor;
+reg [12:0] periodic_major;
+reg periodic_interrupt;
+reg [6:0] ram_address;
+   reg [7:0] init_cnt;
+   reg [7:0] init_addr;
+   reg [7:0] init_data;
+   reg       init_flag;
+wire io_read_valid;
+wire [7:0] io_readdata_next ;
+wire interrupt_start;
+wire max_second;
+wire [7:0] next_second ;
+wire max_minute;
+wire [7:0] next_minute ;
+wire dst_april;
+wire dst_october;
+wire max_hour;
+wire [7:0] next_hour ;
+wire max_dayofweek;
+wire [7:0] next_dayofweek ;
+wire leap_year;
+wire max_dayofmonth;
+wire [7:0] next_dayofmonth ;
+wire max_month;
+wire [7:0] next_month ;
+wire max_year;
+wire [7:0] next_year ;
+wire max_century;
+wire [7:0] next_century ;
+wire rtc_second_update;
+wire rtc_minute_update;
+wire rtc_hour_update;
+wire rtc_day_update;
+wire rtc_month_update;
+wire rtc_year_update;
+wire rtc_century_update;
+wire alarm_interrupt_activate;
+wire periodic_enabled;
+wire periodic_start;
+wire periodic_count;
+wire [12:0] periodic_major_initial ;
+wire [7:0] ram_q;
+wire _unused_ok;
+
+always @(posedge clk) begin if(rst) io_read_last <= 1'b0; else if(io_read_last) io_read_last <= 1'b0; else io_read_last <= io_read; end
+ assign io_read_valid = io_read/* && io_read_last == 1'b0*/;
 
 //------------------------------------------------------------------------------ cycle count from mgmt
 
-reg [26:0] cycles_in_second;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               cycles_in_second <= 27'd30303030;
+always @(posedge clk) begin
+    if(rst)                               cycles_in_second <= `RTC_CYCLES_IN_SECOND;
     else if(mgmt_write && mgmt_address == 8'd128)   cycles_in_second <= mgmt_writedata[26:0];
 end
 
-reg [12:0] cycles_in_122us;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               cycles_in_122us <= 13'd4069;
+always @(posedge clk) begin
+    if(rst)                               cycles_in_122us <= `RTC_CYCLES_IN_122US;
     else if(mgmt_write && mgmt_address == 8'd129)   cycles_in_122us <= mgmt_writedata[12:0];
 end
 
 //------------------------------------------------------------------------------ io read
 
-wire [7:0] io_readdata_next =
+ assign io_readdata_next =
     (io_address == 1'b0)?       8'hFF :
     (ram_address == 7'h00)?     rtc_second :
     (ram_address == 7'h01)?     alarm_second :
@@ -90,97 +166,89 @@ wire [7:0] io_readdata_next =
     (ram_address == 7'h37)?     rtc_century :
                                 ram_q;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)   io_readdata <= 8'd0;
+always @(posedge clk) begin
+    if(rst)   io_readdata <= 8'd0;
     else                io_readdata <= io_readdata_next;
 end
 
 //------------------------------------------------------------------------------ irq
 
-wire interrupt_start = irq == 1'b0 && (
+ assign interrupt_start = irq == 1'b0 && (
     (crb_int_periodic_ena && periodic_interrupt) ||
     (crb_int_alarm_ena    && alarm_interrupt) ||
     (crb_int_update_ena   && update_interrupt) );
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       irq <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                       irq <= 1'b0;
     else if(io_read_valid && io_address == 1'b1 && ram_address == 7'h0C)    irq <= 1'b0;
     else if(interrupt_start)                                                irq <= 1'b1;
 end
 
 //------------------------------------------------------------------------------ once per second state machine
 
-localparam [2:0] SEC_UPDATE_START       = 3'd0;
-localparam [2:0] SEC_UPDATE_IN_PROGRESS = 3'd1;
-localparam [2:0] SEC_SECOND_START       = 3'd2;
-localparam [2:0] SEC_SECOND_IN_PROGRESS = 3'd3;
-localparam [2:0] SEC_STOPPED            = 3'd4;
 
-reg [2:0] sec_state;
 
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                   sec_state <= SEC_UPDATE_START;
-    
+always @(posedge clk) begin
+    if(rst)                                                                                   sec_state <= SEC_UPDATE_START;
+
     else if(crb_freeze || divider[2:1] == 2'b11)                                                        sec_state <= SEC_STOPPED;
     else if(sec_state == SEC_STOPPED)                                                                   sec_state <= SEC_UPDATE_START;
-    
+
     else if(sec_state == SEC_UPDATE_START)                                                              sec_state <= SEC_UPDATE_IN_PROGRESS;
     else if(sec_state == SEC_UPDATE_IN_PROGRESS && sec_timeout == 27'd0)                                sec_state <= SEC_SECOND_START;
     else if(sec_state == SEC_SECOND_START)                                                              sec_state <= SEC_SECOND_IN_PROGRESS;
     else if(sec_state == SEC_SECOND_IN_PROGRESS && sec_timeout == { 13'd0, cycles_in_122us, 1'b0 })     sec_state <= SEC_UPDATE_START;
 end
 
-reg [26:0] sec_timeout;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                               sec_timeout <= 27'd8137; //4069*2 -1
+always @(posedge clk) begin
+    if(rst)                               sec_timeout <= 27'd8137; //4069*2 -1
     else if(crb_freeze || divider[2:1] == 2'b11)    sec_timeout <= 27'd8137; //4069*2 -1
     else if(sec_timeout == 27'd0)                   sec_timeout <= cycles_in_second;
     else                                            sec_timeout <= sec_timeout - 27'd1;
 end
 
-reg update_interrupt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       update_interrupt <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                       update_interrupt <= 1'b0;
     else if(io_read_valid && io_address == 1'b1 && ram_address == 7'h0C)    update_interrupt <= 1'b0;
     else if(sec_state == SEC_SECOND_START)                                  update_interrupt <= 1'b1;
 end
 
 //------------------------------------------------------------------------------
 
-wire max_second = 
+ assign max_second =
     (crb_binarymode && rtc_second >= 8'd59) ||
     (~(crb_binarymode) && (rtc_second[7:4] >= 4'd6 || (rtc_second[7:4] == 4'd5 && rtc_second[3:0] >= 4'd9)));
 
-wire [7:0] next_second =
+ assign next_second =
     (max_second)?                                       8'd0 :
     (~(crb_binarymode) && rtc_second[3:0] >= 4'd9)?     { rtc_second[7:4] + 4'd1, 4'd0 } :
                                                         rtc_second + 8'd1;
 
-wire max_minute = 
+ assign max_minute =
     (crb_binarymode && rtc_minute >= 8'd59) ||
     (~(crb_binarymode) && (rtc_minute[7:4] >= 4'd6 || (rtc_minute[7:4] == 4'd5 && rtc_minute[3:0] >= 4'd9)));
 
-wire [7:0] next_minute =
+ assign next_minute =
     (max_minute)?                                       8'd0 :
     (~(crb_binarymode) && rtc_minute[3:0] >= 4'd9)?     { rtc_minute[7:4] + 4'd1, 4'd0 } :
                                                         rtc_minute + 8'd1;
 
-wire dst_april   = crb_daylightsaving && rtc_dayofweek == 8'd1 && rtc_month == 8'd4 &&
+ assign dst_april = crb_daylightsaving && rtc_dayofweek == 8'd1 && rtc_month == 8'd4 &&
     ((crb_binarymode && rtc_dayofmonth >= 8'd24) || (~(crb_binarymode) && rtc_dayofmonth[7:4] >= 4'd2 && rtc_dayofmonth[3:0] >= 4'd4)) &&
     rtc_hour == 8'd1;
 
-wire dst_october = crb_daylightsaving && rtc_dayofweek == 8'd1 &&
+ assign dst_october = crb_daylightsaving && rtc_dayofweek == 8'd1 &&
     ((crb_binarymode && rtc_month == 8'd10) || (~(crb_binarymode) && rtc_month[7:4] == 4'd1 && rtc_month[3:0] == 4'd0)) &&
     ((crb_binarymode && rtc_dayofmonth >= 8'd25) || (~(crb_binarymode) && rtc_dayofmonth[7:4] >= 4'd2 && rtc_dayofmonth[3:0] >= 4'd5)) &&
     rtc_hour == 8'd1;
-    
-wire max_hour =
+
+ assign max_hour =
     (~(crb_24hour) && crb_binarymode    && rtc_hour[7] && rtc_hour[6:0] >= 7'd12) ||
     (crb_24hour    && crb_binarymode    && rtc_hour >= 8'd23) ||
     (~(crb_24hour) && ~(crb_binarymode) && rtc_hour[7] && (rtc_hour[6:4] >= 3'd2 || (rtc_hour[6:4] == 3'd1 && rtc_hour[3:0] >= 4'd2))) ||
     (crb_24hour    && ~(crb_binarymode) && (rtc_hour[7:4] >= 4'd3 || (rtc_hour[7:4] == 4'd2 && rtc_hour[3:0] >= 4'd3)));
 
-wire [7:0] next_hour =
+ assign next_hour =
     (dst_april)?                                                                                8'd3 :
     (dst_october)?                                                                              8'd1 :
     (~(crb_24hour) && max_hour)?                                                                8'd1 :
@@ -191,18 +259,18 @@ wire [7:0] next_hour =
     (crb_24hour    && ~(crb_binarymode) && rtc_hour[3:0] >= 4'd9)?                              { rtc_hour[7:4] + 4'd1, 4'd0 } :
                                                                                                 rtc_hour + 8'd1;
 
-wire max_dayofweek = rtc_dayofweek >= 8'd7;
+ assign max_dayofweek = rtc_dayofweek >= 8'd7;
 
-wire [7:0] next_dayofweek =
+ assign next_dayofweek =
     (max_dayofweek)?    8'd1 :
                         rtc_dayofweek + 8'd1;
 
 //simplified leap year condition
-wire leap_year =
+ assign leap_year =
     (crb_binarymode    && rtc_year[1:0] == 2'b00) ||
     (~(crb_binarymode) && ((rtc_year[1:0] == 2'b00 && rtc_year[4] == 1'b0) || (rtc_year[1:0] == 2'b10 && rtc_year[4] == 1'b1)));
 
-wire max_dayofmonth = 
+ assign max_dayofmonth =
     (crb_binarymode && (
         (rtc_month <= 8'd1  && rtc_dayofmonth >= 8'd31) ||
         (rtc_month == 8'd2  && ((~(leap_year) && rtc_dayofmonth >= 8'd28) || (leap_year && rtc_dayofmonth >= 8'd29))) ||
@@ -233,106 +301,98 @@ wire max_dayofmonth =
         (rtc_month >= 8'h12 && (rtc_dayofmonth[7:4] >= 4'd4 || (rtc_dayofmonth[7:4] == 4'd3 && rtc_dayofmonth[3:0] >= 4'd1))))
     );
 
-wire [7:0] next_dayofmonth =
+ assign next_dayofmonth =
     (max_dayofmonth)?                                       8'd1 :
     (~(crb_binarymode) && rtc_dayofmonth[3:0] >= 4'd9)?     { rtc_dayofmonth[7:4] + 4'd1, 4'd0 } :
                                                             rtc_dayofmonth + 8'd1;
 
-wire max_month =
+ assign max_month =
     (crb_binarymode && rtc_month >= 8'd12) || (~(crb_binarymode) && (rtc_month[7:4] >= 4'd2 || (rtc_month[7:4] == 4'd1 && rtc_month[3:0] >= 4'd2)));
 
-wire [7:0] next_month =
+ assign next_month =
     (max_month)?                                    8'd1 :
     (~(crb_binarymode) && rtc_month[3:0] >= 4'd9)?  { rtc_month[7:4] + 4'd1, 4'd0 } :
                                                     rtc_month + 8'd1;
-    
-wire max_year =
+
+ assign max_year =
     (crb_binarymode && rtc_year >= 8'd99) || (~(crb_binarymode) && (rtc_year[7:4] >= 4'd10 || (rtc_year[7:4] == 4'd9 && rtc_year[3:0] >= 4'd9)));
 
-wire [7:0] next_year =
+ assign next_year =
     (max_year)?                                     8'd0 :
     (~(crb_binarymode) && rtc_year[3:0] >= 4'd9)?   { rtc_year[7:4] + 4'd1, 4'd0 } :
                                                     rtc_year + 8'd1;
 
-wire max_century =
+ assign max_century =
     (crb_binarymode && rtc_century >= 8'd99) || (~(crb_binarymode) && (rtc_century[7:4] >= 4'd10 || (rtc_century[7:4] == 4'd9 && rtc_century[3:0] >= 4'd9)));
 
-wire [7:0] next_century =
+ assign next_century =
     (max_century)?                                      8'd0 :
     (~(crb_binarymode) && rtc_century[3:0] >= 4'd9)?    { rtc_century[7:4] + 4'd1, 4'd0 } :
                                                         rtc_century + 8'd1;
-    
+
 //------------------------------------------------------------------------------
 
-wire rtc_second_update = sec_state == SEC_SECOND_START;
-wire rtc_minute_update = rtc_second_update && max_second;
-wire rtc_hour_update   = rtc_minute_update && max_minute;
-wire rtc_day_update    = rtc_hour_update   && max_hour;
-wire rtc_month_update  = rtc_day_update    && max_dayofmonth;
-wire rtc_year_update   = rtc_month_update  && max_month;
-wire rtc_century_update= rtc_year_update   && max_year;
+ assign rtc_second_update = sec_state == SEC_SECOND_START;
+ assign rtc_minute_update = rtc_second_update && max_second;
+ assign rtc_hour_update = rtc_minute_update && max_minute;
+ assign rtc_day_update = rtc_hour_update   && max_hour;
+ assign rtc_month_update = rtc_day_update    && max_dayofmonth;
+ assign rtc_year_update = rtc_month_update  && max_month;
+ assign rtc_century_update = rtc_year_update   && max_year;
 
 //------------------------------------------------------------------------------
 
-reg [7:0] rtc_second;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   rtc_second <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                                   rtc_second <= 8'd0;
     else if(mgmt_write && mgmt_address == 8'h00)                        rtc_second <= mgmt_writedata[7:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h00)     rtc_second <= io_writedata;
-    else if(rtc_second_update)                                          rtc_second <= next_second; 
+    else if(rtc_second_update)                                          rtc_second <= next_second;
 end
 
-reg [7:0] rtc_minute;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   rtc_minute <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                                   rtc_minute <= 8'd0;
     else if(mgmt_write && mgmt_address == 8'h02)                        rtc_minute <= mgmt_writedata[7:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h02)     rtc_minute <= io_writedata;
     else if(rtc_minute_update)                                          rtc_minute <= next_minute;
 end
 
-reg [7:0] rtc_hour;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   rtc_hour <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                                   rtc_hour <= 8'd0;
     else if(mgmt_write && mgmt_address == 8'h04)                        rtc_hour <= mgmt_writedata[7:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h04)     rtc_hour <= io_writedata;
     else if(rtc_hour_update)                                            rtc_hour <= next_hour;
 end
 
-reg [7:0] rtc_dayofweek;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   rtc_dayofweek <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                                   rtc_dayofweek <= 8'd0;
     else if(mgmt_write && mgmt_address == 8'h06)                        rtc_dayofweek <= mgmt_writedata[7:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h06)     rtc_dayofweek <= io_writedata;
     else if(rtc_day_update)                                             rtc_dayofweek <= next_dayofweek;
 end
 
-reg [7:0] rtc_dayofmonth;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   rtc_dayofmonth <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                                   rtc_dayofmonth <= 8'd0;
     else if(mgmt_write && mgmt_address == 8'h07)                        rtc_dayofmonth <= mgmt_writedata[7:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h07)     rtc_dayofmonth <= io_writedata;
     else if(rtc_day_update)                                             rtc_dayofmonth <= next_dayofmonth;
 end
 
-reg [7:0] rtc_month;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   rtc_month <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                                   rtc_month <= 8'd0;
     else if(mgmt_write && mgmt_address == 8'h08)                        rtc_month <= mgmt_writedata[7:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h08)     rtc_month <= io_writedata;
     else if(rtc_month_update)                                           rtc_month <= next_month;
 end
 
-reg [7:0] rtc_year;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   rtc_year <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                                   rtc_year <= 8'd0;
     else if(mgmt_write && mgmt_address == 8'h09)                        rtc_year <= mgmt_writedata[7:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h09)     rtc_year <= io_writedata;
     else if(rtc_year_update)                                            rtc_year <= next_year;
 end
 
-reg [7:0] rtc_century;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   rtc_century <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                                   rtc_century <= 8'd0;
     else if(mgmt_write && mgmt_address == 8'h32)                        rtc_century <= mgmt_writedata[7:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h32)     rtc_century <= io_writedata;
     else if(io_write && io_address == 1'b1 && ram_address == 7'h37)     rtc_century <= io_writedata;
@@ -341,35 +401,31 @@ end
 
 //------------------------------------------------------------------------------
 
-reg [7:0] alarm_second;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   alarm_second <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                                   alarm_second <= 8'd0;
     else if(mgmt_write && mgmt_address == 8'h01)                        alarm_second <= mgmt_writedata[7:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h01)     alarm_second <= io_writedata;
 end
 
-reg [7:0] alarm_minute;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   alarm_minute <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                                   alarm_minute <= 8'd0;
     else if(mgmt_write && mgmt_address == 8'h03)                        alarm_minute <= mgmt_writedata[7:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h03)     alarm_minute <= io_writedata;
 end
 
-reg [7:0] alarm_hour;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   alarm_hour <= 8'd0;
+always @(posedge clk) begin
+    if(rst)                                                   alarm_hour <= 8'd0;
     else if(mgmt_write && mgmt_address == 8'h05)                        alarm_hour <= mgmt_writedata[7:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h05)     alarm_hour <= io_writedata;
 end
 
-wire alarm_interrupt_activate =
+ assign alarm_interrupt_activate =
     (alarm_second[7:6] == 2'b11 || (rtc_second_update && next_second == alarm_second)) &&
     (alarm_minute[7:6] == 2'b11 || (rtc_minute_update && next_minute == alarm_minute) || (~(rtc_minute_update) && rtc_minute == alarm_minute)) &&
     (alarm_hour[7:6] == 2'b11   || (rtc_hour_update && next_hour == alarm_hour)       || (~(rtc_hour_update)   && rtc_hour == alarm_hour));
 
-reg alarm_interrupt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       alarm_interrupt <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                       alarm_interrupt <= 1'b0;
     else if(io_read_valid && io_address == 1'b1 && ram_address == 7'h0C)    alarm_interrupt <= 1'b0;
     else if(sec_state == SEC_SECOND_START && alarm_interrupt_activate)      alarm_interrupt <= 1'b1;
 end
@@ -380,53 +436,46 @@ end
 crb_freeze 1: no update, no alarm
 */
 
-reg crb_freeze;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   crb_freeze <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                   crb_freeze <= 1'b0;
     else if(mgmt_write && mgmt_address == 8'h0B)                        crb_freeze <= mgmt_writedata[7];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h0B)     crb_freeze <= io_writedata[7];
 end
 
-reg crb_int_periodic_ena;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   crb_int_periodic_ena <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                   crb_int_periodic_ena <= 1'b0;
     else if(mgmt_write && mgmt_address == 8'h0B)                        crb_int_periodic_ena <= mgmt_writedata[6];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h0B)     crb_int_periodic_ena <= io_writedata[6];
 end
 
-reg crb_int_alarm_ena;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   crb_int_alarm_ena <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                   crb_int_alarm_ena <= 1'b0;
     else if(mgmt_write && mgmt_address == 8'h0B)                        crb_int_alarm_ena <= mgmt_writedata[5];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h0B)     crb_int_alarm_ena <= io_writedata[5];
 end
 
-reg crb_int_update_ena;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   crb_int_update_ena <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                   crb_int_update_ena <= 1'b0;
     else if(mgmt_write && mgmt_address == 8'h0B)                        crb_int_update_ena <= ~(mgmt_writedata[7]) & mgmt_writedata[4];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h0B)     crb_int_update_ena <= ~(io_writedata[7]) & io_writedata[4];
 end
 
-reg crb_binarymode;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   crb_binarymode <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                   crb_binarymode <= 1'b0;
     else if(mgmt_write && mgmt_address == 8'h0B)                        crb_binarymode <= mgmt_writedata[2];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h0B)     crb_binarymode <= io_writedata[2];
 end
 
-reg crb_24hour;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   crb_24hour <= 1'b1;
+always @(posedge clk) begin
+    if(rst)                                                   crb_24hour <= 1'b1;
     else if(mgmt_write && mgmt_address == 8'h0B)                        crb_24hour <= mgmt_writedata[1];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h0B)     crb_24hour <= io_writedata[1];
 end
 
-reg crb_daylightsaving;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   crb_daylightsaving <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                   crb_daylightsaving <= 1'b0;
     else if(mgmt_write && mgmt_address == 8'h0B)                        crb_daylightsaving <= mgmt_writedata[0];
-    else if(io_write && io_address == 1'b1 && ram_address == 7'h0B)     crb_daylightsaving <= io_writedata[0]; 
+    else if(io_write && io_address == 1'b1 && ram_address == 7'h0B)     crb_daylightsaving <= io_writedata[0];
 end
 
 //------------------------------------------------------------------------------
@@ -436,67 +485,60 @@ divider 00x : no periodic
 divider 11x : no update, no alarm
 */
 
-reg [2:0] divider;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   divider <= 3'd2;
+always @(posedge clk) begin
+    if(rst)                                                   divider <= 3'd2;
     else if(mgmt_write && mgmt_address == 8'h0A)                        divider <= mgmt_writedata[6:4];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h0A)     divider <= io_writedata[6:4];
 end
 
-reg [3:0] periodic_rate;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   periodic_rate <= 4'd6;
+always @(posedge clk) begin
+    if(rst)                                                   periodic_rate <= 4'd6;
     else if(mgmt_write && mgmt_address == 8'h0A)                        periodic_rate <= mgmt_writedata[3:0];
     else if(io_write && io_address == 1'b1 && ram_address == 7'h0A)     periodic_rate <= io_writedata[3:0];
 end
 
-wire periodic_enabled = divider[2:1] != 2'b00 && periodic_rate != 4'd0;
-wire periodic_start   = periodic_enabled && (
+ assign periodic_enabled = divider[2:1] != 2'b00 && periodic_rate != 4'd0;
+ assign periodic_start = periodic_enabled && (
                             (periodic_minor == 13'd0 && periodic_major == 13'd0) ||
                             (periodic_minor == 13'd0 && periodic_major == 13'd1));
-wire periodic_count   = periodic_enabled && periodic_major >= 13'd1;
+ assign periodic_count = periodic_enabled && periodic_major >= 13'd1;
 
-wire [12:0] periodic_major_initial = {
+ assign periodic_major_initial = {
     periodic_rate == 4'd15, periodic_rate == 4'd14, periodic_rate == 4'd13, periodic_rate == 4'd12,
-    periodic_rate == 4'd11, periodic_rate == 4'd10, periodic_rate == 4'd9 || periodic_rate == 4'd2,  periodic_rate == 4'd8 || periodic_rate == 4'd1,  
+    periodic_rate == 4'd11, periodic_rate == 4'd10, periodic_rate == 4'd9 || periodic_rate == 4'd2,  periodic_rate == 4'd8 || periodic_rate == 4'd1,
     periodic_rate == 4'd7,  periodic_rate == 4'd6,  periodic_rate == 4'd5,  periodic_rate == 4'd4,
     periodic_rate == 4'd3 };
 
-reg [12:0] periodic_minor;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   periodic_minor <= 13'd0;
+always @(posedge clk) begin
+    if(rst)                                   periodic_minor <= 13'd0;
     else if(~(periodic_enabled))                        periodic_minor <= 13'd0;
     else if(periodic_start)                             periodic_minor <= cycles_in_122us;
     else if(periodic_count && periodic_minor == 13'd0)  periodic_minor <= cycles_in_122us;
     else if(periodic_count)                             periodic_minor <= periodic_minor - 13'd1;
 end
 
-reg [12:0] periodic_major;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   periodic_major <= 13'd0;
+always @(posedge clk) begin
+    if(rst)                                   periodic_major <= 13'd0;
     else if(~(periodic_enabled))                        periodic_major <= 13'd0;
     else if(periodic_start)                             periodic_major <= periodic_major_initial;
     else if(periodic_count && periodic_minor == 13'd0)  periodic_major <= periodic_major - 13'd1;
 end
 
-reg periodic_interrupt;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                               periodic_interrupt <= 1'b0;
+always @(posedge clk) begin
+    if(rst)                                                               periodic_interrupt <= 1'b0;
     else if(io_read_valid && io_address == 1'b1 && ram_address == 7'h0C)            periodic_interrupt <= 1'b0;
     else if(periodic_enabled && periodic_minor == 13'd0 && periodic_major == 13'd1) periodic_interrupt <= 1'b1;
 end
 
 //------------------------------------------------------------------------------
 
-reg [6:0] ram_address;
-always @(posedge clk or negedge rst_n) begin
-    if(rst_n == 1'b0)                       ram_address <= 7'd0;
+always @(posedge clk) begin
+    if(rst)                       ram_address <= 7'd0;
     else if(io_write && io_address == 1'b0) ram_address <= io_writedata[6:0];
 end
 
 //------------------------------------------------------------------------------
 
-wire [7:0] ram_q;
 
 simple_ram #(
     .width      (8),
@@ -504,19 +546,165 @@ simple_ram #(
 )
 rtc_ram_inst(
     .clk                (clk),
-    
-    .wraddress          ((mgmt_write && mgmt_address[7] == 1'b0)?   mgmt_address[6:0] : ram_address),
-    .wren               ((mgmt_write && mgmt_address[7] == 1'b0) || (io_write && io_address == 1'b1)),
-    .data               ((mgmt_write && mgmt_address[7] == 1'b0)?   mgmt_writedata[7:0] : io_writedata),
-    
+
+    .wraddress          ((init_flag) ? init_addr: (mgmt_write && mgmt_address[7] == 1'b0)?   mgmt_address[6:0] : ram_address),
+    .wren               ((init_flag) || (mgmt_write && mgmt_address[7] == 1'b0) || (io_write && io_address == 1'b1)),
+    .data               ((init_flag) ? init_data : (mgmt_write && mgmt_address[7] == 1'b0)?   mgmt_writedata[7:0] : io_writedata),
+
     .rdaddress          ((io_write && io_address == 1'b0)?  io_writedata[6:0] : ram_address),
     .q                  (ram_q)
 );
 
+
+always @(posedge clk) begin
+   if(rst) begin
+      init_flag <= 1;
+      init_cnt <= 0;
+      init_addr <= 0;
+   end else begin
+      if(init_flag) begin
+   init_cnt <= init_cnt + 1;
+   init_addr <= init_cnt;
+   case(init_cnt)
+     8'h0:
+       init_data <= `RTC_SECONDS;
+     8'h1:
+       init_data <= `RTC_SECONDS_ALARM;
+     8'h2:
+       init_data <= `RTC_MINUTES;
+     8'h3:
+       init_data <= `RTC_MINUTES_ALARM;
+     8'h4:
+       init_data <= `RTC_HOURS;
+     8'h5:
+       init_data <= `RTC_HOURS_ALARM;
+     8'h6:
+       init_data <= `RTC_DAYOFWEEK;
+     8'h7:
+       init_data <= `RTC_DATEDAY;
+     8'h8:
+       init_data <= `RTC_DATEMONTH;
+     8'h9:
+       init_data <= `RTC_DATEYEAR;
+     8'ha:
+       init_data <= `RTC_STATUSREGISTER_A;
+     8'hb:
+       init_data <= `RTC_STATUSREGISTER_B;
+     8'hc:
+       init_data <= `RTC_STATUSREGISTER_C;
+     8'hd:
+       init_data <= `RTC_STATUSREGISTER_D;
+     8'he:
+       init_data <= `RTC_DIAGNOSTIC_STATUS;
+     8'hf:
+       init_data <= `RTC_CMOS_SHUTDOWN_STATUS;
+     8'h10:
+       init_data <= `RTC_FLOPPY_DRIVE_TYPE;
+     8'h11:
+       init_data <= `RTC_SYSTEM_CONFIG_SETTING;
+     8'h12:
+       init_data <= `RTC_HDD_TYPE;
+     8'h13:
+       init_data <= `RTC_TYPEMATIC_PARAMS;
+     8'h14:
+       init_data <= `RTC_INSTALLED_EQUIPMENTS;
+     8'h15:
+       init_data <= `RTC_BASEMEMORY_LOW;
+     8'h16:
+       init_data <= `RTC_BASEMEMORY_HIGH;
+     8'h17:
+       init_data <= `RTC_EXTMEMORY_LOW;
+     8'h18:
+       init_data <= `RTC_EXTMEMORY_HIGH;
+     8'h19:
+       init_data <= `RTC_HDD0_EXTENDEDTYPE;
+     8'h1a:
+       init_data <= `RTC_HDD1_EXTENDEDTYPE;
+     8'h1b:
+       init_data <= `RTC_HDD0_CYLINDERS_LOW;
+     8'h1c:
+       init_data <= `RTC_HDD0_CYLINDERS_HIGH;
+     8'h1d:
+       init_data <= `RTC_HDD0_HEADS;
+     8'h1e:
+       init_data <= `RTC_HDD0_WRITE_PRECOMP_LOW;
+     8'h1f:
+       init_data <= `RTC_HDD0_WRITE_PRECOMP_HIGH;
+     8'h20:
+       init_data <= `RTC_HDD0_CONTROL_BYTE;
+     8'h21:
+       init_data <= `RTC_HDD0_LANDING_ZONE_LOW;
+     8'h22:
+       init_data <= `RTC_HDD0_LANDING_ZONE_HIGH;
+     8'h23:
+       init_data <= `RTC_HDD0_SPT;
+     8'h24:
+       init_data <= `RTC_HDD1_CYLINDERS_LOW;
+     8'h25:
+       init_data <= `RTC_HDD1_CYLINDERS_HIGH;
+     8'h26:
+       init_data <= `RTC_HDD1_HEADS;
+     8'h27:
+       init_data <= `RTC_HDD1_WRITE_PRECOMP_LOW;
+     8'h28:
+       init_data <= `RTC_HDD1_WRITE_PRECOMP_HIGH;
+     8'h29:
+       init_data <= `RTC_HDD1_CONTROL_BYTE;
+     8'h2a:
+       init_data <= `RTC_HDD1_LANDING_ZONE_LOW;
+     8'h2b:
+       init_data <= `RTC_HDD1_LANDING_ZONE_HIGH;
+     8'h2c:
+       init_data <= `RTC_HDD1_SPT;
+     8'h2d:
+       init_data <= `RTC_SYSTEM_OPERATIONAL_FLAGS;
+     8'h2e:
+       init_data <= `RTC_CMOS_CHECKSUM_HIGH;
+     8'h2f:
+       init_data <= `RTC_CMOS_CHECKSUM_LOW;
+     8'h30:
+       init_data <= `RTC_MEMSIZE_ABOVE_1M_IN_1K_LOW;
+     8'h31:
+       init_data <= `RTC_MEMSIZE_ABOVE_1M_IN_1K_HIGH;
+     8'h32:
+       init_data <= `RTC_IBM_CENTURY;
+     8'h33:
+       init_data <= `RTC_POST_INFO_FLAGS;
+     8'h34:
+       init_data <= `RTC_MEMSIZE_ABOVE_16M_IN_64K_LOW;
+     8'h35:
+       init_data <= `RTC_MEMSIZE_ABOVE_16M_IN_64K_HIGH;
+     8'h36:
+       init_data <= `RTC_CHIPSET_SPECIFIC_INFO;
+     8'h37:
+       init_data <= `RTC_IBM_PS2_CENTURY;
+     8'h38:
+       init_data <= `RTC_ELTORITO_BOOT_SEQUENCE;
+     8'h39:
+       init_data <= `RTC_ATA_TRANSLATION_POLICY0;
+     8'h3a:
+       init_data <= `RTC_ATA_TRANSLATION_POLICY1;
+     8'h3b:
+       init_data <= `RTC_3B;
+     8'h3c:
+       init_data <= `RTC_3C;
+     8'h3d:
+       init_data <= `RTC_3D;
+     8'h3e:
+       init_data <= `RTC_3E;
+     8'h3f:
+       init_data <= `RTC_3F;
+     8'h40:
+       init_flag <= 0;
+   endcase
+      end
+   end
+end
+
 //------------------------------------------------------------------------------
 
 // synthesis translate_off
-wire _unused_ok = &{ 1'b0, mgmt_writedata[31:27], 1'b0 };
+ assign _unused_ok = &{ 1'b0, mgmt_writedata[31:27], 1'b0 };
 // synthesis translate_on
 
 //------------------------------------------------------------------------------
diff --git a/rtl/soc/vga/vga.v b/rtl/soc/vga/vga.v
index 4aa6ac4..17e1ca4 100644
--- a/rtl/soc/vga/vga.v
+++ b/rtl/soc/vga/vga.v
@@ -1,17 +1,17 @@
 /*
  * Copyright (c) 2014, Aleksander Osman
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
- * 
+ *
  * * Redistributions of source code must retain the above copyright notice, this
  *   list of conditions and the following disclaimer.
- * 
+ *
  * * Redistributions in binary form must reproduce the above copyright notice,
  *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
@@ -24,1432 +24,1548 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+`default_nettype wire
+
 module vga(
-    input               clk_26,
-    input               rst_n,
-    
-    //avalon slave for system overlay
-    input       [7:0]   sys_address,
-    input               sys_read,
-    output      [31:0]  sys_readdata,
-    input               sys_write,
-    input       [31:0]  sys_writedata,
-    
-    //avalon slave vga io
-    input       [3:0]   io_b_address,
-    input               io_b_read,
-    output      [7:0]   io_b_readdata,
-    input               io_b_write,
-    input       [7:0]   io_b_writedata,
-    
-    //avalon slave vga io
-    input       [3:0]   io_c_address,
-    input               io_c_read,
-    output      [7:0]   io_c_readdata,
-    input               io_c_write,
-    input       [7:0]   io_c_writedata,
-    
-    //avalon slave vga io
-    input       [3:0]   io_d_address,
-    input               io_d_read,
-    output      [7:0]   io_d_readdata,
-    input               io_d_write,
-    input       [7:0]   io_d_writedata,
-    
-    //avalon slave vga memory
-    input       [16:0]  mem_address,
-    input               mem_read,
-    output      [7:0]   mem_readdata,
-    input               mem_write,
-    input       [7:0]   mem_writedata,
-    
-    //vga
-    output              vga_clock,
-    output              vga_sync_n,
-    output              vga_blank_n,
-    output              vga_horiz_sync,
-    output              vga_vert_sync,
-    
-    output      [7:0]   vga_r,
-    output      [7:0]   vga_g,
-    output      [7:0]   vga_b
-);
-
-//------------------------------------------------------------------------------
-
-//not needed sys_read_valid
-
-reg io_b_read_last;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) io_b_read_last <= 1'b0; else if(io_b_read_last) io_b_read_last <= 1'b0; else io_b_read_last <= io_b_read; end 
-wire io_b_read_valid = io_b_read && io_b_read_last == 1'b0;
-
-reg io_c_read_last;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) io_c_read_last <= 1'b0; else if(io_c_read_last) io_c_read_last <= 1'b0; else io_c_read_last <= io_c_read; end 
-wire io_c_read_valid = io_c_read && io_c_read_last == 1'b0;
-
-reg io_d_read_last;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) io_d_read_last <= 1'b0; else if(io_d_read_last) io_d_read_last <= 1'b0; else io_d_read_last <= io_d_read; end 
-wire io_d_read_valid = io_d_read && io_d_read_last == 1'b0;
-
-reg mem_read_last;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) mem_read_last <= 1'b0; else if(mem_read_last) mem_read_last <= 1'b0; else mem_read_last <= mem_read; end 
-wire mem_read_valid = mem_read && mem_read_last == 1'b0;
-
-//------------------------------------------------------------------------------
-
-wire [7:0] io_writedata =
-    (io_b_write)?   io_b_writedata :
-    (io_c_write)?   io_c_writedata :
-                    io_d_writedata;
-
-//------------------------------------------------------------------------------ sequencer io
-
-reg seq_async_reset_n;
-reg seq_sync_reset_n;
-
-reg seq_8dot_char;
-
-reg seq_dotclock_divided;
-
-reg seq_screen_disable; //sync works, data blank
-
-reg [3:0] seq_map_write_enable;
-
-reg [2:0] seq_char_map_a; // depends on seq_access_256kb
-reg [2:0] seq_char_map_b; // depends on seq_access_256kb
-
-reg seq_access_256kb;
-reg seq_access_odd_even_disabled;
-reg seq_access_chain4;
-
-// not implemented sequencer regs: 
-reg seq_not_impl_shift_load_2;
-reg seq_not_impl_shift_load_4;
-
-//------------------------------------------------------------------------------
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_async_reset_n <= 1'b1; else if(seq_io_write && seq_io_index == 3'd0) seq_async_reset_n <= io_writedata[0]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_sync_reset_n  <= 1'b1; else if(seq_io_write && seq_io_index == 3'd0) seq_sync_reset_n  <= io_writedata[1]; end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_8dot_char        <= 1'b1; else if(seq_io_write && seq_io_index == 3'd1) seq_8dot_char        <= io_writedata[0]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_dotclock_divided <= 1'b0; else if(seq_io_write && seq_io_index == 3'd1) seq_dotclock_divided <= io_writedata[3]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_screen_disable   <= 1'b0; else if(seq_io_write && seq_io_index == 3'd1) seq_screen_disable   <= io_writedata[5]; end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_map_write_enable <= 4'hF; else if(seq_io_write && seq_io_index == 3'd2) seq_map_write_enable <= io_writedata[3:0]; end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                               seq_char_map_a <= 3'd0;
-    else if(seq_io_write && seq_io_index == 3'd3)   seq_char_map_a <= { io_writedata[5], io_writedata[3:2] };
-    else if(seq_sync_reset_n || seq_async_reset_n)  seq_char_map_a <= 3'd0;
-end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                               seq_char_map_b <= 3'd0;
-    else if(seq_io_write && seq_io_index == 3'd3)   seq_char_map_b <= { io_writedata[4], io_writedata[1:0] };
-    else if(seq_sync_reset_n || seq_async_reset_n)  seq_char_map_b <= 3'd0;
-end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_access_256kb             <= 1'b1; else if(seq_io_write && seq_io_index == 3'd4) seq_access_256kb             <= io_writedata[1]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_access_odd_even_disabled <= 1'b1; else if(seq_io_write && seq_io_index == 3'd4) seq_access_odd_even_disabled <= io_writedata[2]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_access_chain4            <= 1'b1; else if(seq_io_write && seq_io_index == 3'd4) seq_access_chain4            <= io_writedata[3]; end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_not_impl_shift_load_2 <= 1'b0; else if(seq_io_write && seq_io_index == 3'd1) seq_not_impl_shift_load_2 <= io_writedata[2]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_not_impl_shift_load_4 <= 1'b0; else if(seq_io_write && seq_io_index == 3'd1) seq_not_impl_shift_load_4 <= io_writedata[4]; end
-
-//------------------------------------------------------------------------------
-
-wire [7:0] host_io_read_seq =
-    (seq_io_index == 3'd0)?     { 6'd0, seq_sync_reset_n, seq_async_reset_n } :
-    (seq_io_index == 3'd1)?     { 2'd0, seq_screen_disable, seq_not_impl_shift_load_4, seq_dotclock_divided, seq_not_impl_shift_load_2, 1'b0, seq_8dot_char } :
-    (seq_io_index == 3'd2)?     { 4'd0, seq_map_write_enable } :
-    (seq_io_index == 3'd3)?     { 2'd0, seq_char_map_a[2], seq_char_map_b[2], seq_char_map_a[1:0], seq_char_map_b[1:0] } :
-    (seq_io_index == 3'd4)?     { 4'd0, seq_access_chain4, seq_access_odd_even_disabled, seq_access_256kb, 1'b0 } :
-                                8'h00;
-
-//------------------------------------------------------------------------------ crtc io
-
-reg [7:0]   crtc_horizontal_total;
-reg [7:0]   crtc_horizontal_display_size;
-reg [7:0]   crtc_horizontal_blanking_start;
-reg [5:0]   crtc_horizontal_blanking_end;
-reg [7:0]   crtc_horizontal_retrace_start;
-reg [1:0]   crtc_horizontal_retrace_skew;
-reg [4:0]   crtc_horizontal_retrace_end;
-
-reg [9:0]   crtc_vertical_total;
-reg [9:0]   crtc_vertical_retrace_start;
-reg [3:0]   crtc_vertical_retrace_end;
-reg [9:0]   crtc_vertical_display_size;
-reg [9:0]   crtc_vertical_blanking_start;
-reg [7:0]   crtc_vertical_blanking_end;
-
-reg         crtc_vertical_doublescan;
-
-reg [4:0]   crtc_row_preset;
-reg [4:0]   crtc_row_max;
-reg [4:0]   crtc_row_underline;
-
-reg         crtc_cursor_off;
-reg [4:0]   crtc_cursor_row_start;
-reg [4:0]   crtc_cursor_row_end;
-reg [1:0]   crtc_cursor_skew;
-
-reg [15:0]  crtc_address_start;
-reg [1:0]   crtc_address_byte_panning;
-reg [7:0]   crtc_address_offset;
-reg [15:0]  crtc_address_cursor;
-reg         crtc_address_doubleword;
-reg         crtc_address_byte;
-reg         crtc_address_bit0;
-reg         crtc_address_bit13;
-reg         crtc_address_bit14;
-
-reg         crtc_enable_sync;
-
-reg [9:0]   crtc_line_compare;
-
-reg         crtc_protect;
-
-//not implemented crtc regs:
-reg [1:0]   crtc_not_impl_display_enable_skew;
-reg         crtc_not_impl_clear_vert_int;
-reg         crtc_not_impl_enable_vert_int;
-reg         crtc_not_impl_5_refresh_cycles;
-reg         crtc_not_impl_scan_line_clk_div_2;
-reg         crtc_not_impl_address_clk_div_2;
-reg         crtc_not_impl_address_clk_div_4;
-
-//------------------------------------------------------------------------------
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_horizontal_total          <= 8'd95; else if(crtc_io_write && crtc_io_index == 5'h00) crtc_horizontal_total          <= io_writedata[7:0]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_horizontal_display_size   <= 8'd79; else if(crtc_io_write && crtc_io_index == 5'h01) crtc_horizontal_display_size   <= io_writedata[7:0]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_horizontal_blanking_start <= 8'd80; else if(crtc_io_write && crtc_io_index == 5'h02) crtc_horizontal_blanking_start <= io_writedata[7:0]; end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_not_impl_display_enable_skew <= 2'd0; else if(crtc_io_write && crtc_io_index == 5'h03) crtc_not_impl_display_enable_skew <= io_writedata[6:5]; end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   crtc_horizontal_blanking_end <= 6'd34;
-    else if(crtc_io_write && crtc_io_index == 5'h03)    crtc_horizontal_blanking_end <= { crtc_horizontal_blanking_end[5], io_writedata[4:0] };
-    else if(crtc_io_write && crtc_io_index == 5'h05)    crtc_horizontal_blanking_end <= { io_writedata[7], crtc_horizontal_blanking_end[4:0] };
-end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_horizontal_retrace_start <= 8'd84; else if(crtc_io_write && crtc_io_index == 5'h04) crtc_horizontal_retrace_start <= io_writedata[7:0]; end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_horizontal_retrace_skew <= 2'd0; else if(crtc_io_write && crtc_io_index == 5'h05) crtc_horizontal_retrace_skew <= io_writedata[6:5]; end        
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_horizontal_retrace_end  <= 5'd0; else if(crtc_io_write && crtc_io_index == 5'h05) crtc_horizontal_retrace_end  <= io_writedata[4:0]; end         
-        
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   crtc_vertical_total <= 10'd447;
-    else if(crtc_io_write && crtc_io_index == 5'h06)    crtc_vertical_total <= { crtc_vertical_total[9:8], io_writedata[7:0] };
-    else if(crtc_io_write && crtc_io_index == 5'h07)    crtc_vertical_total <= { io_writedata[5], io_writedata[0], crtc_vertical_total[7:0] };
-end        
-        
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   crtc_vertical_retrace_start <= 10'd412;
-    else if(crtc_io_write && crtc_io_index == 5'h10)    crtc_vertical_retrace_start <= { crtc_vertical_retrace_start[9:8], io_writedata[7:0] };
-    else if(crtc_io_write && crtc_io_index == 5'h07)    crtc_vertical_retrace_start <= { io_writedata[7], io_writedata[2], crtc_vertical_retrace_start[7:0] };
-end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   crtc_vertical_display_size <= 10'd399;
-    else if(crtc_io_write && crtc_io_index == 5'h12)    crtc_vertical_display_size <= { crtc_vertical_display_size[9:8], io_writedata[7:0] };
-    else if(crtc_io_write && crtc_io_index == 5'h07)    crtc_vertical_display_size <= { io_writedata[6], io_writedata[1], crtc_vertical_display_size[7:0] };
-end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                           crtc_line_compare <= 10'd1023;
-    else if(crtc_io_write_compare && crtc_io_index == 5'h18)    crtc_line_compare <= { crtc_line_compare[9:8], io_writedata[7:0] };
-    else if(crtc_io_write_compare && crtc_io_index == 5'h07)    crtc_line_compare <= { crtc_line_compare[9], io_writedata[4], crtc_line_compare[7:0] };
-    else if(crtc_io_write_compare && crtc_io_index == 5'h09)    crtc_line_compare <= { io_writedata[6], crtc_line_compare[8:0] };
-end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   crtc_vertical_blanking_start <= 10'd406;
-    else if(crtc_io_write && crtc_io_index == 5'h15)    crtc_vertical_blanking_start <= { crtc_vertical_blanking_start[9:8], io_writedata[7:0] };
-    else if(crtc_io_write && crtc_io_index == 5'h07)    crtc_vertical_blanking_start <= { crtc_vertical_blanking_start[9], io_writedata[3], crtc_vertical_blanking_start[7:0] };
-    else if(crtc_io_write && crtc_io_index == 5'h09)    crtc_vertical_blanking_start <= { io_writedata[5], crtc_vertical_blanking_start[8:0] };
-end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_address_byte_panning <= 2'd0; else if(crtc_io_write && crtc_io_index == 5'h08) crtc_address_byte_panning <= io_writedata[6:5]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_row_preset           <= 5'd0; else if(crtc_io_write && crtc_io_index == 5'h08) crtc_row_preset           <= io_writedata[4:0]; end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_vertical_doublescan  <= 1'd0; else if(crtc_io_write && crtc_io_index == 5'h09) crtc_vertical_doublescan  <= io_writedata[7]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_row_max              <= 5'd1; else if(crtc_io_write && crtc_io_index == 5'h09) crtc_row_max              <= io_writedata[4:0]; end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_cursor_off           <= 1'd0; else if(crtc_io_write && crtc_io_index == 5'h0A) crtc_cursor_off           <= io_writedata[5]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_cursor_row_start     <= 5'd0; else if(crtc_io_write && crtc_io_index == 5'h0A) crtc_cursor_row_start     <= io_writedata[4:0]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_cursor_skew          <= 2'd0; else if(crtc_io_write && crtc_io_index == 5'h0B) crtc_cursor_skew          <= io_writedata[6:5]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_cursor_row_end       <= 5'd0; else if(crtc_io_write && crtc_io_index == 5'h0B) crtc_cursor_row_end       <= io_writedata[4:0]; end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   crtc_address_start <= 16'd0;
-    else if(crtc_io_write && crtc_io_index == 5'h0C)    crtc_address_start <= { io_writedata[7:0], crtc_address_start[7:0] };
-    else if(crtc_io_write && crtc_io_index == 5'h0D)    crtc_address_start <= { crtc_address_start[15:8], io_writedata[7:0] };
-end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   crtc_address_cursor <= 16'd0;
-    else if(crtc_io_write && crtc_io_index == 5'h0E)    crtc_address_cursor <= { io_writedata[7:0], crtc_address_cursor[7:0] };
-    else if(crtc_io_write && crtc_io_index == 5'h0F)    crtc_address_cursor <= { crtc_address_cursor[15:8], io_writedata[7:0] };
-end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_protect                   <= 1'd1;  else if(crtc_io_write && crtc_io_index == 5'h11) crtc_protect                   <= io_writedata[7]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_not_impl_5_refresh_cycles <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h11) crtc_not_impl_5_refresh_cycles <= io_writedata[6]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_not_impl_enable_vert_int  <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h11) crtc_not_impl_enable_vert_int  <= io_writedata[5]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_not_impl_clear_vert_int   <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h11) crtc_not_impl_clear_vert_int   <= io_writedata[4]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_vertical_retrace_end      <= 4'd14; else if(crtc_io_write && crtc_io_index == 5'h11) crtc_vertical_retrace_end      <= io_writedata[3:0]; end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_address_offset            <= 8'd40; else if(crtc_io_write && crtc_io_index == 5'h13) crtc_address_offset            <= io_writedata[7:0]; end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_address_doubleword         <= 1'b1; else if(crtc_io_write && crtc_io_index == 5'h14) crtc_address_doubleword        <= io_writedata[6]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_not_impl_address_clk_div_4 <= 1'b0; else if(crtc_io_write && crtc_io_index == 5'h14) crtc_not_impl_address_clk_div_4<= io_writedata[5]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_row_underline              <= 5'd0; else if(crtc_io_write && crtc_io_index == 5'h14) crtc_row_underline             <= io_writedata[4:0]; end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_vertical_blanking_end <= 8'd185; else if(crtc_io_write && crtc_io_index == 5'h16) crtc_vertical_blanking_end <= io_writedata[7:0]; end
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_enable_sync                  <= 1'd1;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_enable_sync                  <= io_writedata[7]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_address_byte                 <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_address_byte                 <= io_writedata[6]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_address_bit0                 <= 1'd1;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_address_bit0                 <= io_writedata[5]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_not_impl_address_clk_div_2   <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_not_impl_address_clk_div_2   <= io_writedata[3]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_not_impl_scan_line_clk_div_2 <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_not_impl_scan_line_clk_div_2 <= io_writedata[2]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_address_bit14                <= 1'd1;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_address_bit14                <= io_writedata[1]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) crtc_address_bit13                <= 1'd1;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_address_bit13                <= io_writedata[0]; end
-
-//------------------------------------------------------------------------------
-
-wire [7:0] host_io_read_crtc =
-    (crtc_io_index == 5'h00)?       crtc_horizontal_total :
-    (crtc_io_index == 5'h01)?       crtc_horizontal_display_size :
-    (crtc_io_index == 5'h02)?       crtc_horizontal_blanking_start :
-    (crtc_io_index == 5'h03)?       { 1'b1, crtc_not_impl_display_enable_skew, crtc_horizontal_blanking_end[4:0] } :
-    (crtc_io_index == 5'h04)?       crtc_horizontal_retrace_start :
-    (crtc_io_index == 5'h05)?       { crtc_horizontal_blanking_end[5], crtc_horizontal_retrace_skew, crtc_horizontal_retrace_end } :
-    (crtc_io_index == 5'h06)?       crtc_vertical_total[7:0] :
-    (crtc_io_index == 5'h07)?       { crtc_vertical_retrace_start[9], crtc_vertical_display_size[9], crtc_vertical_total[9], crtc_line_compare[8], crtc_vertical_blanking_start[8],
-                                      crtc_vertical_retrace_start[8], crtc_vertical_display_size[8], crtc_vertical_total[8] } :
-    (crtc_io_index == 5'h08)?       { 1'b0, crtc_address_byte_panning, crtc_row_preset } :
-    (crtc_io_index == 5'h09)?       { crtc_vertical_doublescan, crtc_line_compare[9], crtc_vertical_blanking_start[9], crtc_row_max } :
-    (crtc_io_index == 5'h0A)?       { 2'b0, crtc_cursor_off, crtc_cursor_row_start } :
-    (crtc_io_index == 5'h0B)?       { 1'b0, crtc_cursor_skew, crtc_cursor_row_end } :
-    (crtc_io_index == 5'h0C)?       crtc_address_start[15:8] :
-    (crtc_io_index == 5'h0D)?       crtc_address_start[7:0] :
-    (crtc_io_index == 5'h0E)?       crtc_address_cursor[15:8] :
-    (crtc_io_index == 5'h0F)?       crtc_address_cursor[7:0] :
-    (crtc_io_index == 5'h10)?       crtc_vertical_retrace_start[7:0] :
-    (crtc_io_index == 5'h11)?       { crtc_protect, crtc_not_impl_5_refresh_cycles, crtc_not_impl_enable_vert_int, crtc_not_impl_clear_vert_int, crtc_vertical_retrace_end } :
-    (crtc_io_index == 5'h12)?       crtc_vertical_display_size[7:0] :
-    (crtc_io_index == 5'h13)?       crtc_address_offset :
-    (crtc_io_index == 5'h14)?       { 1'b0, crtc_address_doubleword, crtc_not_impl_address_clk_div_4, crtc_row_underline } :
-    (crtc_io_index == 5'h15)?       crtc_vertical_blanking_start[7:0] :
-    (crtc_io_index == 5'h16)?       crtc_vertical_blanking_end :
-    (crtc_io_index == 5'h17)?       { crtc_enable_sync, crtc_address_byte, crtc_address_bit0, 1'b0, crtc_not_impl_address_clk_div_2, crtc_not_impl_scan_line_clk_div_2, crtc_address_bit14, crtc_address_bit13 } :
-    (crtc_io_index == 5'h18)?       crtc_line_compare[7:0] :
-                                    8'h00;
-
-//------------------------------------------------------------------------------ graphic io                                    
-                                    
-reg [3:0] graph_color_compare_map;
-reg [3:0] graph_color_compare_dont_care;
-
-reg [3:0] graph_write_set_map;
-reg [3:0] graph_write_enable_map;
-reg [1:0] graph_write_function;
-reg [2:0] graph_write_rotate;
-reg [7:0] graph_write_mask;
-reg [1:0] graph_write_mode;
-
-reg [1:0] graph_read_map_select;
-reg       graph_read_mode;
-
-reg [1:0] graph_shift_mode;
-
-reg [1:0] graph_system_memory;
-
-//not implemented graphic regs:
-reg       graph_not_impl_chain_odd_even;
-reg       graph_not_impl_host_odd_even;
-reg       graph_not_impl_graphic_mode;
+       input     clk_sys,
+       input     clk_26,
+       input     rst,
+
+       //avalon slave for system overlay
+       input [7:0]   sys_address,
+       input     sys_read,
+       output [31:0] sys_readdata,
+       input     sys_write,
+       input [31:0]  sys_writedata,
+
+       //avalon slave vga io
+       input [3:0]   io_b_address,
+       input     io_b_read,
+       output [7:0]  io_b_readdata,
+       input     io_b_write,
+       input [7:0]   io_b_writedata,
+
+       //avalon slave vga io
+       input [3:0]   io_c_address,
+       input     io_c_read,
+       output [7:0]  io_c_readdata,
+       input     io_c_write,
+       input [7:0]   io_c_writedata,
+
+       //avalon slave vga io
+       input [3:0]   io_d_address,
+       input     io_d_read,
+       output [7:0]  io_d_readdata,
+       input     io_d_write,
+       input [7:0]   io_d_writedata,
+
+       //avalon slave vga memory
+       input [16:0]  mem_address,
+       input     mem_read,
+       output [7:0]  mem_readdata,
+       input     mem_write,
+       input [7:0]   mem_writedata,
+
+       //vga
+       output    vga_clock,
+       output    vga_sync_n,
+       output    vga_blank_n,
+       output    vga_horiz_sync,
+       output    vga_vert_sync,
+
+       output [7:0]  vga_r,
+       output [7:0]  vga_g,
+       output [7:0]  vga_b
+       );
+
+   //------------------------------------------------------------------------------
+   reg           io_b_read_last;
+   reg           io_c_read_last;
+   reg           io_d_read_last;
+   reg           mem_read_last;
+   reg           seq_async_reset_n;
+   reg           seq_sync_reset_n;
+   reg           seq_8dot_char;
+   reg           seq_dotclock_divided;
+   reg           seq_screen_disable; //sync works, data blank
+   reg [3:0]         seq_map_write_enable;
+   reg [2:0]         seq_char_map_a; // depends on seq_access_256kb
+   reg [2:0]         seq_char_map_b; // depends on seq_access_256kb
+   reg           seq_access_256kb;
+   reg           seq_access_odd_even_disabled;
+   reg           seq_access_chain4;
+   reg           seq_not_impl_shift_load_2;
+   reg           seq_not_impl_shift_load_4;
+   reg [7:0]         crtc_horizontal_total;
+   reg [7:0]         crtc_horizontal_display_size;
+   reg [7:0]         crtc_horizontal_blanking_start;
+   reg [5:0]         crtc_horizontal_blanking_end;
+   reg [7:0]         crtc_horizontal_retrace_start;
+   reg [1:0]         crtc_horizontal_retrace_skew;
+   reg [4:0]         crtc_horizontal_retrace_end;
+   reg [9:0]         crtc_vertical_total;
+   reg [9:0]         crtc_vertical_retrace_start;
+   reg [3:0]         crtc_vertical_retrace_end;
+   reg [9:0]         crtc_vertical_display_size;
+   reg [9:0]         crtc_vertical_blanking_start;
+   reg [7:0]         crtc_vertical_blanking_end;
+   reg           crtc_vertical_doublescan;
+   reg [4:0]         crtc_row_preset;
+   reg [4:0]         crtc_row_max;
+   reg [4:0]         crtc_row_underline;
+   reg           crtc_cursor_off;
+   reg [4:0]         crtc_cursor_row_start;
+   reg [4:0]         crtc_cursor_row_end;
+   reg [1:0]         crtc_cursor_skew;
+   reg [15:0]        crtc_address_start;
+   reg [1:0]         crtc_address_byte_panning;
+   reg [7:0]         crtc_address_offset;
+   reg [15:0]        crtc_address_cursor;
+   reg           crtc_address_doubleword;
+   reg           crtc_address_byte;
+   reg           crtc_address_bit0;
+   reg           crtc_address_bit13;
+   reg           crtc_address_bit14;
+   reg           crtc_enable_sync;
+   reg [9:0]         crtc_line_compare;
+   reg           crtc_protect;
+   reg [1:0]         crtc_not_impl_display_enable_skew;
+   reg           crtc_not_impl_clear_vert_int;
+   reg           crtc_not_impl_enable_vert_int;
+   reg           crtc_not_impl_5_refresh_cycles;
+   reg           crtc_not_impl_scan_line_clk_div_2;
+   reg           crtc_not_impl_address_clk_div_2;
+   reg           crtc_not_impl_address_clk_div_4;
+   reg [3:0]         graph_color_compare_map;
+   reg [3:0]         graph_color_compare_dont_care;
+   reg [3:0]         graph_write_set_map;
+   reg [3:0]         graph_write_enable_map;
+   reg [1:0]         graph_write_function;
+   reg [2:0]         graph_write_rotate;
+   reg [7:0]         graph_write_mask;
+   reg [1:0]         graph_write_mode;
+   reg [1:0]         graph_read_map_select;
+   reg           graph_read_mode;
+   reg [1:0]         graph_shift_mode;
+   reg [1:0]         graph_system_memory;
+   reg           graph_not_impl_chain_odd_even;
+   reg           graph_not_impl_host_odd_even;
+   reg           graph_not_impl_graphic_mode;
+   reg           attrib_color_8bit_enable;
+   reg           attrib_color_bit5_4_enable;
+   reg [1:0]         attrib_color_bit7_6_value;
+   reg [1:0]         attrib_color_bit5_4_value;
+   reg           attrib_panning_after_compare_match;
+   reg [3:0]         attrib_panning_value;
+   reg           attrib_blinking;
+   reg           attrib_9bit_same_as_8bit;
+   reg           attrib_graphic_mode;
+   reg [7:0]         attrib_color_overscan;
+   reg [3:0]         attrib_mask;
+   reg           attrib_not_impl_mono_emulation;
+   reg           general_vsync;
+   reg           general_hsync;
+   reg           general_enable_ram;
+   reg           general_io_space;
+   reg [1:0]         general_not_impl_clock_select;
+   reg           general_not_impl_odd_even_page;
+   reg [3:0]         host_io_read_address_last;
+   reg [2:0]         seq_io_index;
+   reg [4:0]         crtc_io_index;
+   reg [3:0]         graph_io_index;
+   reg [4:0]         attrib_io_index;
+   reg           attrib_video_enable;
+   reg           attrib_flip_flop;
+   reg [7:0]         dac_mask;
+   reg           dac_is_read;
+   reg [11:0]        dac_write_buffer;
+   reg [7:0]         dac_write_index;
+   reg [7:0]         dac_read_index;
+   reg [1:0]         dac_cnt;
+   reg [7:0]         host_io_read_reg;
+   reg [7:0]         host_ram0_reg;
+   reg [7:0]         host_ram1_reg;
+   reg [7:0]         host_ram2_reg;
+   reg [7:0]         host_ram3_reg;
+   reg           host_read_out_of_bounds;
+   reg [16:0]        host_address_reduced_last;
+   reg           host_read_last;
+   reg [15:0]        memory_start_line;
+   reg [15:0]        memory_address_reg;
+   reg [4:0]         memory_row_scan_reg;
+   reg           memory_row_scan_double;
+   reg [2:0]         memory_char_map_a;
+   reg [2:0]         memory_char_map_b;
+   reg [3:0]         memory_panning_reg;
+   reg           memory_load_step_a;
+   reg           memory_load_step_b;
+   reg [15:0]        memory_address_reg_final;
+   reg [7:0]         plane_ram0;
+   reg [7:0]         plane_ram1;
+   reg [7:0]         plane_ram2;
+   reg [7:0]         plane_ram3;
+   reg [5:0]         plane_shift_cnt;
+   reg [7:0]         plane_shift0;
+   reg [7:0]         plane_shift1;
+   reg [7:0]         plane_shift2;
+   reg [7:0]         plane_shift3;
+   reg [7:0]         plane_txt_shift;
+   reg [3:0]         txt_foreground;
+   reg [3:0]         txt_background;
+   reg [3:0]         pel_input_last;
+   reg           pel_line_graphic_char;
+   reg [3:0]         pel_background;
+   reg [35:0]        pel_shift_reg;
+   reg           plane_shift_enable_last;
+   reg           pel_color_8bit_cnt;
+   reg [7:0]         pel_color_8bit_buffer;
+   reg [3:0]         dot_cnt;
+   reg [7:0]         horiz_cnt;
+   reg [9:0]         vert_cnt;
+   reg           dot_cnt_div;
+   reg           host_io_vertical_retrace_last;
+   reg [5:0]         blink_cnt;
+   reg           vgaprep_horiz_blank;
+   reg           vgaprep_vert_blank;
+   reg           sys_enabled;
+   reg [6:0]         sys_horiz_cnt;
+   reg           sys_inverted;
+   reg [9:0]         hcnt, vcnt;
+   reg           vsync, hsync;
+   reg           vgareg_blank_n;
+   reg           vgareg0_horiz_sync;
+   reg           vgareg1_horiz_sync;
+   reg           vgareg0_vert_sync;
+   reg           vgareg1_vert_sync;
+   reg [7:0]         vgareg_r;
+   reg [7:0]         vgareg_g;
+   reg [7:0]         vgareg_b;
+   wire          io_b_read_valid;
+   wire          io_c_read_valid;
+   wire          io_d_read_valid;
+   wire          mem_read_valid;
+   wire [7:0]        io_writedata ;
+   wire [7:0]        host_io_read_seq ;
+   wire [7:0]        host_io_read_crtc ;
+   wire [7:0]        host_io_read_graph ;
+   wire [7:0]        host_io_read_attrib ;
+   wire          host_io_ignored;
+   wire          seq_io_write;
+   wire          crtc_io_write;
+   wire          crtc_io_write_compare;
+   wire          graph_io_write;
+   wire          attrib_io_write;
+   wire          general_io_write_misc;
+   wire          host_io_vertical_retrace;
+   wire          host_io_not_displaying;
+   wire [7:0]        host_io_read_wire ;
+   wire [5:0]        host_palette_q;
+   wire [17:0]       dac_read_q;
+   wire          host_memory_out_of_bounds;
+   wire [16:0]       host_address_reduced ;
+   wire [15:0]       host_address ;
+   wire [7:0]        host_ram0_q;
+   wire [7:0]        host_ram1_q;
+   wire [7:0]        host_ram2_q;
+   wire [7:0]        host_ram3_q;
+   wire [7:0]        host_read_mode_1 ;
+   wire          host_write;
+   wire [7:0]        host_writedata_rotate ;
+   wire [7:0]        host_write_set_0 ;
+   wire [7:0]        host_write_set_1 ;
+   wire [7:0]        host_write_set_2 ;
+   wire [7:0]        host_write_set_3 ;
+   wire [31:0]       host_write_function ;
+   wire [7:0]        host_write_mask_0 ;
+   wire [7:0]        host_write_mask_1 ;
+   wire [7:0]        host_write_mask_2 ;
+   wire [7:0]        host_write_mask_3 ;
+   wire [7:0]        host_write_mode_3_mask ;
+   wire [7:0]        host_write_mode_3_ram0 ;
+   wire [7:0]        host_write_mode_3_ram1 ;
+   wire [7:0]        host_write_mode_3_ram2 ;
+   wire [7:0]        host_write_mode_3_ram3 ;
+   wire [31:0]       host_writedata ;
+   wire [3:0]        host_write_enable_for_chain4 ;
+   wire [3:0]        host_write_enable_for_odd_even ;
+   wire [3:0]        host_write_enable ;
+   wire          dot_memory_load;
+   wire          dot_memory_load_first_in_frame;
+   wire          dot_memory_load_first_in_line_matched;
+   wire          dot_memory_load_first_in_line;
+   wire          dot_memory_load_vertical_retrace_start;
+   wire          memory_address_load;
+   wire [15:0]       memory_address ;
+   wire [4:0]        memory_row_scan ;
+   wire [15:0]       memory_address_step_1 ;
+   wire [15:0]       memory_address_step_2 ;
+   wire [2:0]        memory_txt_index ;
+   wire [15:0]       memory_txt_address_base ;
+   wire [15:0]       memory_txt_address ;
+   wire [7:0]        plane_ram0_q;
+   wire [7:0]        plane_ram1_q;
+   wire [7:0]        plane_ram2_q;
+   wire [7:0]        plane_ram3_q;
+   wire          plane_shift_enable;
+   wire          plane_shift_9dot;
+   wire [7:0]        plane_shift_value0 ;
+   wire [7:0]        plane_shift_value1 ;
+   wire [7:0]        plane_shift_value2 ;
+   wire [7:0]        plane_shift_value3 ;
+   wire          blink_txt_value;
+   wire          blink_cursor_value;
+   wire          txt_blink_enabled;
+   wire          txt_underline_enable;
+   wire          txt_cursor_enable;
+   wire [7:0]        plane_txt_shift_value ;
+   wire          txt_line_graphic_char;
+   wire [3:0]        pel_input ;
+   wire [3:0]        pel_after_enable ;
+   wire [3:0]        pel_after_blink ;
+   wire [7:0]        pel_after_panning ;
+   wire [5:0]        pel_palette;
+   wire [7:0]        pel_palette_index ;
+   wire          vgaprep_overscan;
+   wire [7:0]        pel_index ;
+   wire [17:0]       dac_color;
+   wire          character_last_dot;
+   wire          line_last_dot;
+   wire          screen_last_dot;
+   wire          dot_cnt_enable;
+   wire          vgaprep_blank;
+   wire          vgaprep_horiz_sync;
+   wire          vgaprep_vert_sync;
+   wire [8:0]        sys_readdata_from_ram;
+   wire [8:0]        sys_character;
+   wire [7:0]        sys_line;
+   wire [6:0]        sys_horiz_cnt_plus_4 ;
+   wire          sys_pixel;
+   wire [7:0]        sys_pixel_color ;
+   wire          _unused_ok;
+
+   //not needed sys_read_valid
+
+   always @(posedge clk_sys) begin if(rst) io_b_read_last <= 1'b0; else if(io_b_read_last) io_b_read_last <= 1'b0; else io_b_read_last <= io_b_read; end
+   assign io_b_read_valid = io_b_read/* && io_b_read_last == 1'b0*/;
+
+   always @(posedge clk_sys) begin if(rst) io_c_read_last <= 1'b0; else if(io_c_read_last) io_c_read_last <= 1'b0; else io_c_read_last <= io_c_read; end
+   assign io_c_read_valid = io_c_read/* && io_c_read_last == 1'b0*/;
+
+   always @(posedge clk_sys) begin if(rst) io_d_read_last <= 1'b0; else if(io_d_read_last) io_d_read_last <= 1'b0; else io_d_read_last <= io_d_read; end
+   assign io_d_read_valid = io_d_read/* && io_d_read_last == 1'b0*/;
+
+   always @(posedge clk_sys) begin if(rst) mem_read_last <= 1'b0; else if(mem_read_last) mem_read_last <= 1'b0; else mem_read_last <= mem_read; end
+   assign mem_read_valid = mem_read/* && mem_read_last == 1'b0*/;
+
+   //------------------------------------------------------------------------------
+
+   assign io_writedata =
+            (io_b_write)?   io_b_writedata :
+            (io_c_write)?   io_c_writedata :
+            io_d_writedata;
+
+   //------------------------------------------------------------------------------ sequencer io
+
+
+
+
+
+
+
+
+   // not implemented sequencer regs:
+
+   //------------------------------------------------------------------------------
+
+   always @(posedge clk_sys) begin if(rst) seq_async_reset_n <= 1'b1; else if(seq_io_write && seq_io_index == 3'd0) seq_async_reset_n <= io_writedata[0]; end
+   always @(posedge clk_sys) begin if(rst) seq_sync_reset_n  <= 1'b1; else if(seq_io_write && seq_io_index == 3'd0) seq_sync_reset_n  <= io_writedata[1]; end
+
+   always @(posedge clk_sys) begin if(rst) seq_8dot_char        <= 1'b1; end //else if(seq_io_write && seq_io_index == 3'd1) seq_8dot_char        <= io_writedata[0]; end
+   always @(posedge clk_sys) begin if(rst) seq_dotclock_divided <= 1'b0; else if(seq_io_write && seq_io_index == 3'd1) seq_dotclock_divided <= io_writedata[3]; end
+   always @(posedge clk_sys) begin if(rst) seq_screen_disable   <= 1'b0; else if(seq_io_write && seq_io_index == 3'd1) seq_screen_disable   <= io_writedata[5]; end
+
+   always @(posedge clk_sys) begin if(rst) seq_map_write_enable <= 4'hF; else if(seq_io_write && seq_io_index == 3'd2) seq_map_write_enable <= io_writedata[3:0]; end
+
+   always @(posedge clk_sys) begin
+      if(rst)                               seq_char_map_a <= 3'd0;
+      else if(seq_io_write && seq_io_index == 3'd3)   seq_char_map_a <= { io_writedata[5], io_writedata[3:2] };
+      else if(seq_sync_reset_n || seq_async_reset_n)  seq_char_map_a <= 3'd0;
+   end
+
+   always @(posedge clk_sys) begin
+      if(rst)                               seq_char_map_b <= 3'd0;
+      else if(seq_io_write && seq_io_index == 3'd3)   seq_char_map_b <= { io_writedata[4], io_writedata[1:0] };
+      else if(seq_sync_reset_n || seq_async_reset_n)  seq_char_map_b <= 3'd0;
+   end
+
+   always @(posedge clk_sys) begin if(rst) seq_access_256kb             <= 1'b1; else if(seq_io_write && seq_io_index == 3'd4) seq_access_256kb             <= io_writedata[1]; end
+   always @(posedge clk_sys) begin if(rst) seq_access_odd_even_disabled <= 1'b1; else if(seq_io_write && seq_io_index == 3'd4) seq_access_odd_even_disabled <= io_writedata[2]; end
+   always @(posedge clk_sys) begin if(rst) seq_access_chain4            <= 1'b1; else if(seq_io_write && seq_io_index == 3'd4) seq_access_chain4            <= io_writedata[3]; end
+
+   always @(posedge clk_sys) begin if(rst) seq_not_impl_shift_load_2 <= 1'b0; else if(seq_io_write && seq_io_index == 3'd1) seq_not_impl_shift_load_2 <= io_writedata[2]; end
+   always @(posedge clk_sys) begin if(rst) seq_not_impl_shift_load_4 <= 1'b0; else if(seq_io_write && seq_io_index == 3'd1) seq_not_impl_shift_load_4 <= io_writedata[4]; end
+
+   //------------------------------------------------------------------------------
+
+   assign host_io_read_seq =
+                (seq_io_index == 3'd0)?     { 6'd0, seq_sync_reset_n, seq_async_reset_n } :
+                (seq_io_index == 3'd1)?     { 2'd0, seq_screen_disable, seq_not_impl_shift_load_4, seq_dotclock_divided, seq_not_impl_shift_load_2, 1'b0, seq_8dot_char } :
+                (seq_io_index == 3'd2)?     { 4'd0, seq_map_write_enable } :
+                (seq_io_index == 3'd3)?     { 2'd0, seq_char_map_a[2], seq_char_map_b[2], seq_char_map_a[1:0], seq_char_map_b[1:0] } :
+                (seq_io_index == 3'd4)?     { 4'd0, seq_access_chain4, seq_access_odd_even_disabled, seq_access_256kb, 1'b0 } :
+                            8'h00;
+
+   //------------------------------------------------------------------------------ crtc io
+
+
+
+
+
+
+
+
+
+
+   //not implemented crtc regs:
+
+   //------------------------------------------------------------------------------
+
+   always @(posedge clk_sys) begin if(rst) crtc_horizontal_total          <= 8'd95; else if(crtc_io_write && crtc_io_index == 5'h00) crtc_horizontal_total          <= io_writedata[7:0]; end
+   always @(posedge clk_sys) begin if(rst) crtc_horizontal_display_size   <= 8'd79; else if(crtc_io_write && crtc_io_index == 5'h01) crtc_horizontal_display_size   <= io_writedata[7:0]; end
+   always @(posedge clk_sys) begin if(rst) crtc_horizontal_blanking_start <= 8'd80; else if(crtc_io_write && crtc_io_index == 5'h02) crtc_horizontal_blanking_start <= io_writedata[7:0]; end
+
+   always @(posedge clk_sys) begin if(rst) crtc_not_impl_display_enable_skew <= 2'd0; else if(crtc_io_write && crtc_io_index == 5'h03) crtc_not_impl_display_enable_skew <= io_writedata[6:5]; end
+
+
+   always @(posedge clk_sys) begin
+      if(rst)                                   crtc_horizontal_blanking_end <= 6'd34;
+      else if(crtc_io_write && crtc_io_index == 5'h03)    crtc_horizontal_blanking_end <= { crtc_horizontal_blanking_end[5], io_writedata[4:0] };
+      else if(crtc_io_write && crtc_io_index == 5'h05)    crtc_horizontal_blanking_end <= { io_writedata[7], crtc_horizontal_blanking_end[4:0] };
+   end
+
+   always @(posedge clk_sys) begin if(rst) crtc_horizontal_retrace_start <= 8'd84;  end // else if(crtc_io_write && crtc_io_index == 5'h04) crtc_horizontal_retrace_start <= io_writedata[7:0]; end
+
+   always @(posedge clk_sys) begin if(rst) crtc_horizontal_retrace_skew <= 2'd0;  end // else if(crtc_io_write && crtc_io_index == 5'h05) crtc_horizontal_retrace_skew <= io_writedata[6:5]; end
+   always @(posedge clk_sys) begin if(rst) crtc_horizontal_retrace_end  <= 5'd0;  end // else if(crtc_io_write && crtc_io_index == 5'h05) crtc_horizontal_retrace_end  <= io_writedata[4:0]; end
+
+
+   always @(posedge clk_sys) begin
+      if(rst)                                   crtc_vertical_total <= 10'd449; //10'd447;
+      else if(crtc_io_write && crtc_io_index == 5'h06)    crtc_vertical_total <= { crtc_vertical_total[9:8], io_writedata[7:0] };
+      else if(crtc_io_write && crtc_io_index == 5'h07)    crtc_vertical_total <= { io_writedata[5], io_writedata[0], crtc_vertical_total[7:0] };
+   end
+
+   always @(posedge clk_sys) begin
+      if(rst)                                   crtc_vertical_retrace_start <= 10'd412;
+      else if(crtc_io_write && crtc_io_index == 5'h10)    crtc_vertical_retrace_start <= { crtc_vertical_retrace_start[9:8], io_writedata[7:0] };
+      else if(crtc_io_write && crtc_io_index == 5'h07)    crtc_vertical_retrace_start <= { io_writedata[7], io_writedata[2], crtc_vertical_retrace_start[7:0] };
+   end
+
+   always @(posedge clk_sys) begin
+      if(rst)                                   crtc_vertical_display_size <= 10'd399;
+      else if(crtc_io_write && crtc_io_index == 5'h12)    crtc_vertical_display_size <= { crtc_vertical_display_size[9:8], io_writedata[7:0] };
+      else if(crtc_io_write && crtc_io_index == 5'h07)    crtc_vertical_display_size <= { io_writedata[6], io_writedata[1], crtc_vertical_display_size[7:0] };
+   end
+
+   always @(posedge clk_sys) begin
+      if(rst)                                           crtc_line_compare <= 10'd1023;
+      else if(crtc_io_write_compare && crtc_io_index == 5'h18)    crtc_line_compare <= { crtc_line_compare[9:8], io_writedata[7:0] };
+      else if(crtc_io_write_compare && crtc_io_index == 5'h07)    crtc_line_compare <= { crtc_line_compare[9], io_writedata[4], crtc_line_compare[7:0] };
+      else if(crtc_io_write_compare && crtc_io_index == 5'h09)    crtc_line_compare <= { io_writedata[6], crtc_line_compare[8:0] };
+   end
+
+   always @(posedge clk_sys) begin
+      if(rst)                                   crtc_vertical_blanking_start <= 10'd406;
+      else if(crtc_io_write && crtc_io_index == 5'h15)    crtc_vertical_blanking_start <= { crtc_vertical_blanking_start[9:8], io_writedata[7:0] };
+      else if(crtc_io_write && crtc_io_index == 5'h07)    crtc_vertical_blanking_start <= { crtc_vertical_blanking_start[9], io_writedata[3], crtc_vertical_blanking_start[7:0] };
+      else if(crtc_io_write && crtc_io_index == 5'h09)    crtc_vertical_blanking_start <= { io_writedata[5], crtc_vertical_blanking_start[8:0] };
+   end
+
+
+
+   always @(posedge clk_sys) begin if(rst) crtc_address_byte_panning <= 2'd0; else if(crtc_io_write && crtc_io_index == 5'h08) crtc_address_byte_panning <= io_writedata[6:5]; end
+   always @(posedge clk_sys) begin if(rst) crtc_row_preset           <= 5'd0; else if(crtc_io_write && crtc_io_index == 5'h08) crtc_row_preset           <= io_writedata[4:0]; end
+
+   always @(posedge clk_sys) begin if(rst) crtc_vertical_doublescan  <= 1'd0; else if(crtc_io_write && crtc_io_index == 5'h09) crtc_vertical_doublescan  <= io_writedata[7]; end
+   always @(posedge clk_sys) begin if(rst) crtc_row_max              <= 5'd1; else if(crtc_io_write && crtc_io_index == 5'h09) crtc_row_max              <= io_writedata[4:0]; end
+
+   always @(posedge clk_sys) begin if(rst) crtc_cursor_off           <= 1'd0; else if(crtc_io_write && crtc_io_index == 5'h0A) crtc_cursor_off           <= io_writedata[5]; end
+   always @(posedge clk_sys) begin if(rst) crtc_cursor_row_start     <= 5'd0; else if(crtc_io_write && crtc_io_index == 5'h0A) crtc_cursor_row_start     <= io_writedata[4:0]; end
+   always @(posedge clk_sys) begin if(rst) crtc_cursor_skew          <= 2'd0; else if(crtc_io_write && crtc_io_index == 5'h0B) crtc_cursor_skew          <= io_writedata[6:5]; end
+   always @(posedge clk_sys) begin if(rst) crtc_cursor_row_end       <= 5'd0; else if(crtc_io_write && crtc_io_index == 5'h0B) crtc_cursor_row_end       <= io_writedata[4:0]; end
+
+   always @(posedge clk_sys) begin
+      if(rst)                                   crtc_address_start <= 16'd0;
+      else if(crtc_io_write && crtc_io_index == 5'h0C)    crtc_address_start <= { io_writedata[7:0], crtc_address_start[7:0] };
+      else if(crtc_io_write && crtc_io_index == 5'h0D)    crtc_address_start <= { crtc_address_start[15:8], io_writedata[7:0] };
+   end
+
+   always @(posedge clk_sys) begin
+      if(rst)                                   crtc_address_cursor <= 16'd0;
+      else if(crtc_io_write && crtc_io_index == 5'h0E)    crtc_address_cursor <= { io_writedata[7:0], crtc_address_cursor[7:0] };
+      else if(crtc_io_write && crtc_io_index == 5'h0F)    crtc_address_cursor <= { crtc_address_cursor[15:8], io_writedata[7:0] };
+   end
+
+   always @(posedge clk_sys) begin if(rst) crtc_protect                   <= 1'd1;  else if(crtc_io_write && crtc_io_index == 5'h11) crtc_protect                   <= io_writedata[7]; end
+   always @(posedge clk_sys) begin if(rst) crtc_not_impl_5_refresh_cycles <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h11) crtc_not_impl_5_refresh_cycles <= io_writedata[6]; end
+   always @(posedge clk_sys) begin if(rst) crtc_not_impl_enable_vert_int  <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h11) crtc_not_impl_enable_vert_int  <= io_writedata[5]; end
+   always @(posedge clk_sys) begin if(rst) crtc_not_impl_clear_vert_int   <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h11) crtc_not_impl_clear_vert_int   <= io_writedata[4]; end
+   always @(posedge clk_sys) begin if(rst) crtc_vertical_retrace_end      <= 4'd14; else if(crtc_io_write && crtc_io_index == 5'h11) crtc_vertical_retrace_end      <= io_writedata[3:0]; end
+
+   always @(posedge clk_sys) begin if(rst) crtc_address_offset            <= 8'd40; else if(crtc_io_write && crtc_io_index == 5'h13) crtc_address_offset            <= io_writedata[7:0]; end
+
+   always @(posedge clk_sys) begin if(rst) crtc_address_doubleword         <= 1'b1; else if(crtc_io_write && crtc_io_index == 5'h14) crtc_address_doubleword        <= io_writedata[6]; end
+   always @(posedge clk_sys) begin if(rst) crtc_not_impl_address_clk_div_4 <= 1'b0; else if(crtc_io_write && crtc_io_index == 5'h14) crtc_not_impl_address_clk_div_4<= io_writedata[5]; end
+   always @(posedge clk_sys) begin if(rst) crtc_row_underline              <= 5'd0; else if(crtc_io_write && crtc_io_index == 5'h14) crtc_row_underline             <= io_writedata[4:0]; end
+
+   always @(posedge clk_sys) begin if(rst) crtc_vertical_blanking_end <= 8'd185; else if(crtc_io_write && crtc_io_index == 5'h16) crtc_vertical_blanking_end <= io_writedata[7:0]; end
+
+   always @(posedge clk_sys) begin if(rst) crtc_enable_sync                  <= 1'd1;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_enable_sync                  <= io_writedata[7]; end
+   always @(posedge clk_sys) begin if(rst) crtc_address_byte                 <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_address_byte                 <= io_writedata[6]; end
+   always @(posedge clk_sys) begin if(rst) crtc_address_bit0                 <= 1'd1;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_address_bit0                 <= io_writedata[5]; end
+   always @(posedge clk_sys) begin if(rst) crtc_not_impl_address_clk_div_2   <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_not_impl_address_clk_div_2   <= io_writedata[3]; end
+   always @(posedge clk_sys) begin if(rst) crtc_not_impl_scan_line_clk_div_2 <= 1'd0;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_not_impl_scan_line_clk_div_2 <= io_writedata[2]; end
+   always @(posedge clk_sys) begin if(rst) crtc_address_bit14                <= 1'd1;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_address_bit14                <= io_writedata[1]; end
+   always @(posedge clk_sys) begin if(rst) crtc_address_bit13                <= 1'd1;  else if(crtc_io_write && crtc_io_index == 5'h17) crtc_address_bit13                <= io_writedata[0]; end
+
+   //------------------------------------------------------------------------------
+
+   assign host_io_read_crtc =
+                 (crtc_io_index == 5'h00)?       crtc_horizontal_total :
+                 (crtc_io_index == 5'h01)?       crtc_horizontal_display_size :
+                 (crtc_io_index == 5'h02)?       crtc_horizontal_blanking_start :
+                 (crtc_io_index == 5'h03)?       { 1'b1, crtc_not_impl_display_enable_skew, crtc_horizontal_blanking_end[4:0] } :
+                 (crtc_io_index == 5'h04)?       crtc_horizontal_retrace_start :
+                 (crtc_io_index == 5'h05)?       { crtc_horizontal_blanking_end[5], crtc_horizontal_retrace_skew, crtc_horizontal_retrace_end } :
+                 (crtc_io_index == 5'h06)?       crtc_vertical_total[7:0] :
+                 (crtc_io_index == 5'h07)?       { crtc_vertical_retrace_start[9], crtc_vertical_display_size[9], crtc_vertical_total[9], crtc_line_compare[8], crtc_vertical_blanking_start[8],
+                                   crtc_vertical_retrace_start[8], crtc_vertical_display_size[8], crtc_vertical_total[8] } :
+                 (crtc_io_index == 5'h08)?       { 1'b0, crtc_address_byte_panning, crtc_row_preset } :
+                 (crtc_io_index == 5'h09)?       { crtc_vertical_doublescan, crtc_line_compare[9], crtc_vertical_blanking_start[9], crtc_row_max } :
+                 (crtc_io_index == 5'h0A)?       { 2'b0, crtc_cursor_off, crtc_cursor_row_start } :
+                 (crtc_io_index == 5'h0B)?       { 1'b0, crtc_cursor_skew, crtc_cursor_row_end } :
+                 (crtc_io_index == 5'h0C)?       crtc_address_start[15:8] :
+                 (crtc_io_index == 5'h0D)?       crtc_address_start[7:0] :
+                 (crtc_io_index == 5'h0E)?       crtc_address_cursor[15:8] :
+                 (crtc_io_index == 5'h0F)?       crtc_address_cursor[7:0] :
+                 (crtc_io_index == 5'h10)?       crtc_vertical_retrace_start[7:0] :
+                 (crtc_io_index == 5'h11)?       { crtc_protect, crtc_not_impl_5_refresh_cycles, crtc_not_impl_enable_vert_int, crtc_not_impl_clear_vert_int, crtc_vertical_retrace_end } :
+                 (crtc_io_index == 5'h12)?       crtc_vertical_display_size[7:0] :
+                 (crtc_io_index == 5'h13)?       crtc_address_offset :
+                 (crtc_io_index == 5'h14)?       { 1'b0, crtc_address_doubleword, crtc_not_impl_address_clk_div_4, crtc_row_underline } :
+                 (crtc_io_index == 5'h15)?       crtc_vertical_blanking_start[7:0] :
+                 (crtc_io_index == 5'h16)?       crtc_vertical_blanking_end :
+                 (crtc_io_index == 5'h17)?       { crtc_enable_sync, crtc_address_byte, crtc_address_bit0, 1'b0, crtc_not_impl_address_clk_div_2, crtc_not_impl_scan_line_clk_div_2, crtc_address_bit14, crtc_address_bit13 } :
+                 (crtc_io_index == 5'h18)?       crtc_line_compare[7:0] :
+                             8'h00;
+
+   //------------------------------------------------------------------------------ graphic io
+
+
+
+
+
+
+   //not implemented graphic regs:
+
+   //------------------------------------------------------------------------------
+
+   always @(posedge clk_sys) begin if(rst) graph_write_set_map     <= 4'd0; else if(graph_io_write && graph_io_index == 4'd0) graph_write_set_map     <= io_writedata[3:0]; end
+   always @(posedge clk_sys) begin if(rst) graph_write_enable_map  <= 4'd0; else if(graph_io_write && graph_io_index == 4'd1) graph_write_enable_map  <= io_writedata[3:0]; end
+   always @(posedge clk_sys) begin if(rst) graph_color_compare_map <= 4'd0; else if(graph_io_write && graph_io_index == 4'd2) graph_color_compare_map <= io_writedata[3:0]; end
+
+   always @(posedge clk_sys) begin if(rst) graph_write_function <= 2'd0; else if(graph_io_write && graph_io_index == 4'd3) graph_write_function <= io_writedata[4:3]; end
+   always @(posedge clk_sys) begin if(rst) graph_write_rotate   <= 3'd0; else if(graph_io_write && graph_io_index == 4'd3) graph_write_rotate   <= io_writedata[2:0]; end
+
+   always @(posedge clk_sys) begin if(rst) graph_read_map_select<= 2'd0; else if(graph_io_write && graph_io_index == 4'd4) graph_read_map_select <= io_writedata[1:0]; end
+
+   always @(posedge clk_sys) begin if(rst) graph_shift_mode             <= 2'd2; else if(graph_io_write && graph_io_index == 4'd5) graph_shift_mode             <= io_writedata[6:5]; end
+   always @(posedge clk_sys) begin if(rst) graph_not_impl_host_odd_even <= 1'd0; else if(graph_io_write && graph_io_index == 4'd5) graph_not_impl_host_odd_even <= io_writedata[4]; end
+   always @(posedge clk_sys) begin if(rst) graph_read_mode              <= 1'd0; else if(graph_io_write && graph_io_index == 4'd5) graph_read_mode              <= io_writedata[3]; end
+   always @(posedge clk_sys) begin if(rst) graph_write_mode             <= 2'd0; else if(graph_io_write && graph_io_index == 4'd5) graph_write_mode             <= io_writedata[1:0]; end
+
+   always @(posedge clk_sys) begin if(rst) graph_system_memory           <= 2'd1; else if(graph_io_write && graph_io_index == 4'd6) graph_system_memory           <= io_writedata[3:2]; end
+   always @(posedge clk_sys) begin if(rst) graph_not_impl_chain_odd_even <= 1'd0; else if(graph_io_write && graph_io_index == 4'd6) graph_not_impl_chain_odd_even <= io_writedata[1]; end
+   always @(posedge clk_sys) begin if(rst) graph_not_impl_graphic_mode   <= 1'd1; else if(graph_io_write && graph_io_index == 4'd6) graph_not_impl_graphic_mode   <= io_writedata[0]; end
+
+   always @(posedge clk_sys) begin if(rst) graph_color_compare_dont_care <= 4'hF; else if(graph_io_write && graph_io_index == 4'd7) graph_color_compare_dont_care <= io_writedata[3:0]; end
+
+   always @(posedge clk_sys) begin if(rst) graph_write_mask <= 8'hFF; else if(graph_io_write && graph_io_index == 4'd8) graph_write_mask <= io_writedata[7:0]; end
+
+   //------------------------------------------------------------------------------
+
+   assign host_io_read_graph =
+                  (graph_io_index == 4'd0)?       { 4'b0, graph_write_set_map } :
+                  (graph_io_index == 4'd1)?       { 4'b0, graph_write_enable_map } :
+                  (graph_io_index == 4'd2)?       { 4'b0, graph_color_compare_map } :
+                  (graph_io_index == 4'd3)?       { 3'b0, graph_write_function, graph_write_rotate } :
+                  (graph_io_index == 4'd4)?       { 6'd0, graph_read_map_select } :
+                  (graph_io_index == 4'd5)?       { 1'b0, graph_shift_mode, graph_not_impl_host_odd_even, graph_read_mode, 1'b0, graph_write_mode } :
+                  (graph_io_index == 4'd6)?       { 4'd0, graph_system_memory, graph_not_impl_chain_odd_even, graph_not_impl_graphic_mode } :
+                  (graph_io_index == 4'd7)?       { 4'd0, graph_color_compare_dont_care } :
+                  (graph_io_index == 4'd8)?       graph_write_mask :
+                              8'h00;
+
+   //------------------------------------------------------------------------------ attribute io
+
+
+
+
+
+
 
-//------------------------------------------------------------------------------
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_write_set_map     <= 4'd0; else if(graph_io_write && graph_io_index == 4'd0) graph_write_set_map     <= io_writedata[3:0]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_write_enable_map  <= 4'd0; else if(graph_io_write && graph_io_index == 4'd1) graph_write_enable_map  <= io_writedata[3:0]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_color_compare_map <= 4'd0; else if(graph_io_write && graph_io_index == 4'd2) graph_color_compare_map <= io_writedata[3:0]; end
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_write_function <= 2'd0; else if(graph_io_write && graph_io_index == 4'd3) graph_write_function <= io_writedata[4:3]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_write_rotate   <= 3'd0; else if(graph_io_write && graph_io_index == 4'd3) graph_write_rotate   <= io_writedata[2:0]; end
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_read_map_select<= 2'd0; else if(graph_io_write && graph_io_index == 4'd4) graph_read_map_select <= io_writedata[1:0]; end
+   //not implemented attribute regs:
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_shift_mode             <= 2'd2; else if(graph_io_write && graph_io_index == 4'd5) graph_shift_mode             <= io_writedata[6:5]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_not_impl_host_odd_even <= 1'd0; else if(graph_io_write && graph_io_index == 4'd5) graph_not_impl_host_odd_even <= io_writedata[4]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_read_mode              <= 1'd0; else if(graph_io_write && graph_io_index == 4'd5) graph_read_mode              <= io_writedata[3]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_write_mode             <= 2'd0; else if(graph_io_write && graph_io_index == 4'd5) graph_write_mode             <= io_writedata[1:0]; end
+   //------------------------------------------------------------------------------
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_system_memory           <= 2'd1; else if(graph_io_write && graph_io_index == 4'd6) graph_system_memory           <= io_writedata[3:2]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_not_impl_chain_odd_even <= 1'd0; else if(graph_io_write && graph_io_index == 4'd6) graph_not_impl_chain_odd_even <= io_writedata[1]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_not_impl_graphic_mode   <= 1'd1; else if(graph_io_write && graph_io_index == 4'd6) graph_not_impl_graphic_mode   <= io_writedata[0]; end
+   always @(posedge clk_sys) begin if(rst) attrib_color_bit5_4_enable         <= 1'd0; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_color_bit5_4_enable         <= io_writedata[7]; end
+   always @(posedge clk_sys) begin if(rst) attrib_color_8bit_enable           <= 1'd1; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_color_8bit_enable           <= io_writedata[6]; end
+   always @(posedge clk_sys) begin if(rst) attrib_panning_after_compare_match <= 1'd0; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_panning_after_compare_match <= io_writedata[5]; end
+   always @(posedge clk_sys) begin if(rst) attrib_blinking                    <= 1'd0; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_blinking                    <= io_writedata[3]; end
+   always @(posedge clk_sys) begin if(rst) attrib_9bit_same_as_8bit           <= 1'd0; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_9bit_same_as_8bit           <= io_writedata[2]; end
+   always @(posedge clk_sys) begin if(rst) attrib_not_impl_mono_emulation     <= 1'd0; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_not_impl_mono_emulation     <= io_writedata[1]; end
+   always @(posedge clk_sys) begin if(rst) attrib_graphic_mode                <= 1'd1; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_graphic_mode                <= io_writedata[0]; end
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_color_compare_dont_care <= 4'hF; else if(graph_io_write && graph_io_index == 4'd7) graph_color_compare_dont_care <= io_writedata[3:0]; end
+   always @(posedge clk_sys) begin if(rst) attrib_color_overscan <= 8'd0;        else if(attrib_io_write && attrib_io_index == 5'h11) attrib_color_overscan <= io_writedata[7:0]; end
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_write_mask <= 8'hFF; else if(graph_io_write && graph_io_index == 4'd8) graph_write_mask <= io_writedata[7:0]; end
+   always @(posedge clk_sys) begin if(rst) attrib_mask <= 4'hF;                  else if(attrib_io_write && attrib_io_index == 5'h12) attrib_mask <= io_writedata[3:0]; end
 
-//------------------------------------------------------------------------------
+   always @(posedge clk_sys) begin if(rst) attrib_panning_value <= 4'd0;         else if(attrib_io_write && attrib_io_index == 5'h13) attrib_panning_value <= io_writedata[3:0]; end
 
-wire [7:0] host_io_read_graph =
-    (graph_io_index == 4'd0)?       { 4'b0, graph_write_set_map } :
-    (graph_io_index == 4'd1)?       { 4'b0, graph_write_enable_map } :
-    (graph_io_index == 4'd2)?       { 4'b0, graph_color_compare_map } :
-    (graph_io_index == 4'd3)?       { 3'b0, graph_write_function, graph_write_rotate } :
-    (graph_io_index == 4'd4)?       { 6'd0, graph_read_map_select } :
-    (graph_io_index == 4'd5)?       { 1'b0, graph_shift_mode, graph_not_impl_host_odd_even, graph_read_mode, 1'b0, graph_write_mode } :
-    (graph_io_index == 4'd6)?       { 4'd0, graph_system_memory, graph_not_impl_chain_odd_even, graph_not_impl_graphic_mode } :
-    (graph_io_index == 4'd7)?       { 4'd0, graph_color_compare_dont_care } :
-    (graph_io_index == 4'd8)?       graph_write_mask :
-                                    8'h00;
+   always @(posedge clk_sys) begin if(rst) attrib_color_bit7_6_value <= 2'd0;    else if(attrib_io_write && attrib_io_index == 5'h14) attrib_color_bit7_6_value <= io_writedata[3:2]; end
+   always @(posedge clk_sys) begin if(rst) attrib_color_bit5_4_value <= 2'd0;    else if(attrib_io_write && attrib_io_index == 5'h14) attrib_color_bit5_4_value <= io_writedata[1:0]; end
 
-//------------------------------------------------------------------------------ attribute io
+   //------------------------------------------------------------------------------
 
-reg       attrib_color_8bit_enable;
+   assign host_io_read_attrib =
+                   (attrib_io_index == 5'h10)?     { attrib_color_bit5_4_enable, attrib_color_8bit_enable, attrib_panning_after_compare_match, 1'b0,
+                                 attrib_blinking, attrib_9bit_same_as_8bit, attrib_not_impl_mono_emulation, attrib_graphic_mode } :
+                   (attrib_io_index == 5'h11)?     attrib_color_overscan :
+                   (attrib_io_index == 5'h12)?     { 4'd0, attrib_mask } :
+                   (attrib_io_index == 5'h13)?     { 4'd0, attrib_panning_value } :
+                   (attrib_io_index == 5'h14)?     { 4'd0, attrib_color_bit7_6_value, attrib_color_bit5_4_value } :
+                               8'h00;
 
-reg       attrib_color_bit5_4_enable;
-reg [1:0] attrib_color_bit7_6_value;
-reg [1:0] attrib_color_bit5_4_value;
+   //------------------------------------------------------------------------------ external io
 
-reg       attrib_panning_after_compare_match;
 
-reg [3:0] attrib_panning_value;
 
-reg       attrib_blinking;
+   //not implemented external regs:
 
-reg       attrib_9bit_same_as_8bit;
+   //------------------------------------------------------------------------------
 
-reg       attrib_graphic_mode;
+   always @(posedge clk_sys) begin if(rst) general_vsync <= 1'd0;                    else if(general_io_write_misc) general_vsync <= io_writedata[7]; end
+   always @(posedge clk_sys) begin if(rst) general_hsync <= 1'd1;                    else if(general_io_write_misc) general_hsync <= io_writedata[6]; end
 
-reg [7:0] attrib_color_overscan;
+   always @(posedge clk_sys) begin if(rst) general_not_impl_odd_even_page <= 1'd1;   else if(general_io_write_misc) general_not_impl_odd_even_page <= io_writedata[5]; end
 
-reg [3:0] attrib_mask;
+   always @(posedge clk_sys) begin if(rst) general_not_impl_clock_select <= 2'd0;    else if(general_io_write_misc) general_not_impl_clock_select <= io_writedata[3:2]; end
 
-//not implemented attribute regs:
-reg attrib_not_impl_mono_emulation;
+   always @(posedge clk_sys) begin if(rst) general_enable_ram <= 1'd1;               else if(general_io_write_misc) general_enable_ram <= io_writedata[1]; end
+   always @(posedge clk_sys) begin if(rst) general_io_space   <= 1'd1;               else if(general_io_write_misc) general_io_space   <= io_writedata[0]; end
 
-//------------------------------------------------------------------------------
+   //------------------------------------------------------------------------------ io
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_color_bit5_4_enable         <= 1'd0; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_color_bit5_4_enable         <= io_writedata[7]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_color_8bit_enable           <= 1'd1; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_color_8bit_enable           <= io_writedata[6]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_panning_after_compare_match <= 1'd0; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_panning_after_compare_match <= io_writedata[5]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_blinking                    <= 1'd0; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_blinking                    <= io_writedata[3]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_9bit_same_as_8bit           <= 1'd0; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_9bit_same_as_8bit           <= io_writedata[2]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_not_impl_mono_emulation     <= 1'd0; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_not_impl_mono_emulation     <= io_writedata[1]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_graphic_mode                <= 1'd1; else if(attrib_io_write && attrib_io_index == 5'h10) attrib_graphic_mode                <= io_writedata[0]; end
+   assign host_io_ignored =
+                (general_io_space    && (io_b_read_valid || io_b_write)) ||
+                (~(general_io_space) && (io_d_read_valid || io_d_write));
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_color_overscan <= 8'd0;        else if(attrib_io_write && attrib_io_index == 5'h11) attrib_color_overscan <= io_writedata[7:0]; end
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_mask <= 4'hF;                  else if(attrib_io_write && attrib_io_index == 5'h12) attrib_mask <= io_writedata[3:0]; end
+   always @(posedge clk_sys) begin if(rst) host_io_read_address_last <= 4'd0; else if(io_c_read_valid) host_io_read_address_last <= io_c_address; end
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_panning_value <= 4'd0;         else if(attrib_io_write && attrib_io_index == 5'h13) attrib_panning_value <= io_writedata[3:0]; end
+   always @(posedge clk_sys) begin if(rst) seq_io_index <= 3'd0; else if(io_c_write && io_c_address == 4'h4) seq_io_index <= io_writedata[2:0]; end
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_color_bit7_6_value <= 2'd0;    else if(attrib_io_write && attrib_io_index == 5'h14) attrib_color_bit7_6_value <= io_writedata[3:2]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_color_bit5_4_value <= 2'd0;    else if(attrib_io_write && attrib_io_index == 5'h14) attrib_color_bit5_4_value <= io_writedata[1:0]; end
+   assign seq_io_write = io_c_write && io_c_address == 4'h5;
 
-//------------------------------------------------------------------------------
+   always @(posedge clk_sys) begin
+      if(rst)                                                   crtc_io_index <= 5'd0;
+      else if(io_b_write && io_b_address == 4'h4 && ~(host_io_ignored))   crtc_io_index <= io_b_writedata[4:0];
+      else if(io_d_write && io_d_address == 4'h4 && ~(host_io_ignored))   crtc_io_index <= io_d_writedata[4:0];
+   end
 
-wire [7:0] host_io_read_attrib =
-    (attrib_io_index == 5'h10)?     { attrib_color_bit5_4_enable, attrib_color_8bit_enable, attrib_panning_after_compare_match, 1'b0,
-                                      attrib_blinking, attrib_9bit_same_as_8bit, attrib_not_impl_mono_emulation, attrib_graphic_mode } :
-    (attrib_io_index == 5'h11)?     attrib_color_overscan :
-    (attrib_io_index == 5'h12)?     { 4'd0, attrib_mask } :
-    (attrib_io_index == 5'h13)?     { 4'd0, attrib_panning_value } :
-    (attrib_io_index == 5'h14)?     { 4'd0, attrib_color_bit7_6_value, attrib_color_bit5_4_value } :
-                                    8'h00;
+   assign crtc_io_write = ((io_b_write && io_b_address == 4'd5) || (io_d_write && io_d_address == 4'd5)) && ~(host_io_ignored) && (~(crtc_protect) || crtc_io_index >= 5'd8);
 
-//------------------------------------------------------------------------------ external io
+   assign crtc_io_write_compare = ((io_b_write && io_b_address == 4'd5) || (io_d_write && io_d_address == 4'd5)) && ~(host_io_ignored);
 
-reg general_vsync;
-reg general_hsync;
+   always @(posedge clk_sys) begin if(rst) graph_io_index <= 4'd0; else if(io_c_write && io_c_address == 4'hE) graph_io_index <= io_c_writedata[3:0]; end
 
-reg general_enable_ram;
-reg general_io_space;
+   assign graph_io_write = io_c_write && io_c_address == 4'hF;
 
-//not implemented external regs:
-reg [1:0] general_not_impl_clock_select;
-reg       general_not_impl_odd_even_page;
+   always @(posedge clk_sys) begin if(rst) attrib_video_enable <= 1'd1; else if(io_c_write && io_c_address == 4'h0 && ~(attrib_flip_flop)) attrib_video_enable <= io_c_writedata[5]; end
+   always @(posedge clk_sys) begin if(rst) attrib_io_index     <= 5'd0; else if(io_c_write && io_c_address == 4'h0 && ~(attrib_flip_flop)) attrib_io_index     <= io_c_writedata[4:0]; end
 
-//------------------------------------------------------------------------------
+   always @(posedge clk_sys) begin
+      if(rst)                                                                                                       attrib_flip_flop <= 1'b0;
+      else if(((io_b_read_valid && io_b_address == 4'hA) || (io_d_read_valid && io_d_address == 4'hA)) && ~(host_io_ignored)) attrib_flip_flop <= 1'b0;
+      else if(io_c_write && io_c_address == 4'h0)                                                                             attrib_flip_flop <= ~attrib_flip_flop;
+   end
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) general_vsync <= 1'd0;                    else if(general_io_write_misc) general_vsync <= io_writedata[7]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) general_hsync <= 1'd1;                    else if(general_io_write_misc) general_hsync <= io_writedata[6]; end
+   assign attrib_io_write = io_c_write && io_c_address == 4'h0 && attrib_flip_flop == 1'b1;
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) general_not_impl_odd_even_page <= 1'd1;   else if(general_io_write_misc) general_not_impl_odd_even_page <= io_writedata[5]; end
+   assign general_io_write_misc = io_c_write && io_c_address == 4'h2;
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) general_not_impl_clock_select <= 2'd0;    else if(general_io_write_misc) general_not_impl_clock_select <= io_writedata[3:2]; end
+   //------------------------------------------------------------------------------
 
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) general_enable_ram <= 1'd1;               else if(general_io_write_misc) general_enable_ram <= io_writedata[1]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) general_io_space   <= 1'd1;               else if(general_io_write_misc) general_io_space   <= io_writedata[0]; end
+   always @(posedge clk_sys) begin if(rst) dac_mask <= 8'hFF; else if(io_c_write && io_c_address == 4'h6) dac_mask <= io_c_writedata[7:0]; end
 
-//------------------------------------------------------------------------------ io
+   always @(posedge clk_sys) begin
+      if(rst)                           dac_is_read <= 1'd0;
+      else if(io_c_write && io_c_address == 4'h7) dac_is_read <= 1'b1;
+      else if(io_c_write && io_c_address == 4'h8) dac_is_read <= 1'b0;
+   end
 
-wire host_io_ignored = 
-    (general_io_space    && (io_b_read_valid || io_b_write)) ||
-    (~(general_io_space) && (io_d_read_valid || io_d_write));
-    
-    
-reg [3:0] host_io_read_address_last;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) host_io_read_address_last <= 4'd0; else if(io_c_read_valid) host_io_read_address_last <= io_c_address; end
-    
-reg [2:0]   seq_io_index;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) seq_io_index <= 3'd0; else if(io_c_write && io_c_address == 4'h4) seq_io_index <= io_writedata[2:0]; end
+   always @(posedge clk_sys) begin
+      if(rst)                           dac_write_buffer <= 12'd0;
+      else if(io_c_write && io_c_address == 4'h9) dac_write_buffer <= { dac_write_buffer[5:0], io_c_writedata[5:0] };
+   end
 
-wire        seq_io_write = io_c_write && io_c_address == 4'h5;
+   always @(posedge clk_sys) begin
+      if(rst)                                               dac_write_index <= 8'd0;
+      else if(io_c_write && io_c_address == 4'h8)                     dac_write_index <= io_c_writedata[7:0];
+      else if(io_c_write && io_c_address == 4'h9 && dac_cnt == 2'd2)  dac_write_index <= dac_write_index + 8'd1;
+   end
 
-reg [4:0]   crtc_io_index;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                   crtc_io_index <= 5'd0;
-    else if(io_b_write && io_b_address == 4'h4 && ~(host_io_ignored))   crtc_io_index <= io_b_writedata[4:0];
-    else if(io_d_write && io_d_address == 4'h4 && ~(host_io_ignored))   crtc_io_index <= io_d_writedata[4:0];
-end
+   always @(posedge clk_sys) begin
+      if(rst)                                                       dac_read_index <= 8'd0;
+      else if(io_c_write && io_c_address == 4'h7)                             dac_read_index <= io_c_writedata[7:0];
+      else if(io_c_read_valid  && io_c_address == 4'h9 && dac_cnt == 2'd2)    dac_read_index <= dac_read_index + 8'd1;
+   end
 
-wire crtc_io_write = ((io_b_write && io_b_address == 4'd5) || (io_d_write && io_d_address == 4'd5)) && ~(host_io_ignored) && (~(crtc_protect) || crtc_io_index >= 5'd8);
+   always @(posedge clk_sys) begin
+      if(rst)                                                                   dac_cnt <= 2'd0;
+      else if(io_c_write && io_c_address == 4'h7)                                         dac_cnt <= 2'd0;
+      else if(io_c_write && io_c_address == 4'h8)                                         dac_cnt <= 2'd0;
+      else if((io_c_read_valid || io_c_write) && io_c_address == 4'h9 && dac_cnt == 2'd2) dac_cnt <= 2'd0;
+      else if((io_c_read_valid || io_c_write) && io_c_address == 4'h9)                    dac_cnt <= dac_cnt + 2'd1;
+   end
 
-wire crtc_io_write_compare = ((io_b_write && io_b_address == 4'd5) || (io_d_write && io_d_address == 4'd5)) && ~(host_io_ignored);
+   //------------------------------------------------------------------------------
 
-reg [3:0]   graph_io_index;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) graph_io_index <= 4'd0; else if(io_c_write && io_c_address == 4'hE) graph_io_index <= io_c_writedata[3:0]; end
 
-wire        graph_io_write = io_c_write && io_c_address == 4'hF;
-
-reg [4:0]   attrib_io_index;
-reg         attrib_video_enable;
-reg         attrib_flip_flop;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_video_enable <= 1'd1; else if(io_c_write && io_c_address == 4'h0 && ~(attrib_flip_flop)) attrib_video_enable <= io_c_writedata[5]; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) attrib_io_index     <= 5'd0; else if(io_c_write && io_c_address == 4'h0 && ~(attrib_flip_flop)) attrib_io_index     <= io_c_writedata[4:0]; end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                                       attrib_flip_flop <= 1'b0;
-    else if(((io_b_read_valid && io_b_address == 4'hA) || (io_d_read_valid && io_d_address == 4'hA)) && ~(host_io_ignored)) attrib_flip_flop <= 1'b0;
-    else if(io_c_write && io_c_address == 4'h0)                                                                             attrib_flip_flop <= ~attrib_flip_flop;
-end
-
-wire attrib_io_write = io_c_write && io_c_address == 4'h0 && attrib_flip_flop == 1'b1;
-
-wire general_io_write_misc = io_c_write && io_c_address == 4'h2;
-
-//------------------------------------------------------------------------------
-
-reg [7:0] dac_mask;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) dac_mask <= 8'hFF; else if(io_c_write && io_c_address == 4'h6) dac_mask <= io_c_writedata[7:0]; end
-
-reg       dac_is_read;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                           dac_is_read <= 1'd0;
-    else if(io_c_write && io_c_address == 4'h7) dac_is_read <= 1'b1;
-    else if(io_c_write && io_c_address == 4'h8) dac_is_read <= 1'b0;
-end
-
-reg [11:0] dac_write_buffer;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                           dac_write_buffer <= 12'd0;
-    else if(io_c_write && io_c_address == 4'h9) dac_write_buffer <= { dac_write_buffer[5:0], io_c_writedata[5:0] };
-end
-
-reg [7:0] dac_write_index;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               dac_write_index <= 8'd0;
-    else if(io_c_write && io_c_address == 4'h8)                     dac_write_index <= io_c_writedata[7:0];
-    else if(io_c_write && io_c_address == 4'h9 && dac_cnt == 2'd2)  dac_write_index <= dac_write_index + 8'd1;
-end
-
-reg [7:0] dac_read_index;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                       dac_read_index <= 8'd0;
-    else if(io_c_write && io_c_address == 4'h7)                             dac_read_index <= io_c_writedata[7:0];
-    else if(io_c_read_valid  && io_c_address == 4'h9 && dac_cnt == 2'd2)    dac_read_index <= dac_read_index + 8'd1;
-end
-
-reg [1:0] dac_cnt;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                   dac_cnt <= 2'd0;
-    else if(io_c_write && io_c_address == 4'h7)                                         dac_cnt <= 2'd0;
-    else if(io_c_write && io_c_address == 4'h8)                                         dac_cnt <= 2'd0;
-    else if((io_c_read_valid || io_c_write) && io_c_address == 4'h9 && dac_cnt == 2'd2) dac_cnt <= 2'd0;
-    else if((io_c_read_valid || io_c_write) && io_c_address == 4'h9)                    dac_cnt <= dac_cnt + 2'd1;
-end
-
-//------------------------------------------------------------------------------
-
-wire host_io_vertical_retrace;
-wire host_io_not_displaying;
-
-wire [7:0]  host_io_read_wire =
-    (host_io_ignored)?                                  8'hFF :
-    (io_c_read_valid && io_c_address == 4'hC)?          { general_vsync, general_hsync, general_not_impl_odd_even_page, 1'b0, general_not_impl_clock_select, general_enable_ram, general_io_space } : //misc output reg
-    (io_c_read_valid && io_c_address == 4'h2)?          { 3'b0, 1'b1, 4'b0 } : //input status 0
-    ((io_b_read_valid && io_b_address == 4'hA) || (io_d_read_valid && io_d_address == 4'hA))?
-                                                        { 4'b0, host_io_vertical_retrace, 2'b0, host_io_not_displaying } : //input status 1
-    (io_c_read_valid && io_c_address == 4'h0 && attrib_flip_flop)? 
-                                                        8'h00 : //attrib index in write mode
-    (io_c_read_valid && io_c_address == 4'h0)?          { 2'b0, attrib_video_enable, attrib_io_index } : //attrib in address mode
-    (io_c_read_valid && io_c_address == 4'h1)?          host_io_read_attrib : //attrib read
-    (io_c_read_valid && io_c_address == 4'h4)?          { 5'd0, seq_io_index } : //seq index
-    (io_c_read_valid && io_c_address == 4'h5)?          host_io_read_seq : //seq data
-    (io_c_read_valid && io_c_address == 4'h6)?          dac_mask : //pel mask
-    (io_c_read_valid && io_c_address == 4'h7)?          { 6'd0, dac_is_read? 2'b11 : 2'b00 } : //dac state
-    (io_c_read_valid && io_c_address == 4'h8)?          dac_write_index :
-    (io_c_read_valid && io_c_address == 4'hE)?          { 4'd0, graph_io_index } :
-    (io_c_read_valid && io_c_address == 4'hF)?          host_io_read_graph :
-    (io_d_read_valid && io_d_address == 4'h4)?          { 3'b0, crtc_io_index } :
-    ((io_b_read_valid && io_b_address == 4'h5) || (io_d_read_valid && io_d_address == 4'h5))? 
-                                                        host_io_read_crtc :
-    (io_b_read_valid || io_d_read_valid)?               8'hFF :
-                                                        8'h00; // 6'h1A (Feature Control Register)
-
-reg [7:0] host_io_read_reg;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) host_io_read_reg <= 8'd0; else host_io_read_reg <= host_io_read_wire; end
-
-wire [5:0]  host_palette_q;
-wire [17:0] dac_read_q;
-
-assign io_c_readdata =
-    (host_io_read_address_last == 4'h1 && attrib_io_index <= 5'hF)?     { 2'b0, host_palette_q } :
-    (host_io_read_address_last == 4'h9 && ~(dac_is_read))?              8'h3F :              
-    (host_io_read_address_last == 4'h9 && dac_cnt == 2'd1)?             { 2'b0, dac_read_q[17:12] } :
-    (host_io_read_address_last == 4'h9 && dac_cnt == 2'd2)?             { 2'b0, dac_read_q[11:6] } :
-    (host_io_read_address_last == 4'h9 && dac_cnt == 2'd0)?             { 2'b0, dac_read_q[5:0] } :
-                                                                        host_io_read_reg;
-                                                                        
-assign io_b_readdata = host_io_read_reg;
-assign io_d_readdata = host_io_read_reg;
-
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-
-wire host_memory_out_of_bounds =
-    (graph_system_memory == 2'd1 && mem_address > 17'h0FFFF) ||
-    (graph_system_memory == 2'd2 && (mem_address < 17'h10000 || mem_address > 17'h17FFF)) ||
-    (graph_system_memory == 2'd3 && mem_address < 17'h17FFF);
-
-wire [16:0] host_address_reduced =
-    (graph_system_memory == 2'd1)?  { 1'b0, mem_address[15:0] } :
-    (graph_system_memory == 2'd2)?  { 2'b0, mem_address[14:0] } :
-    (graph_system_memory == 2'd3)?  { 2'b0, mem_address[14:0] } :
-                                    mem_address;
-
-wire [15:0] host_address =
-    (seq_access_chain4)?                { host_address_reduced[15:2], 2'b00 } :
-    (~(seq_access_odd_even_disabled))?  { host_address_reduced[15:1], 1'b0 } :
-                                        host_address_reduced[15:0];
-
-//------------------------------------------------------------------------------ mem read
-
-wire [7:0] host_ram0_q;
-wire [7:0] host_ram1_q;
-wire [7:0] host_ram2_q;
-wire [7:0] host_ram3_q;
-
-reg [7:0] host_ram0_reg;
-reg [7:0] host_ram1_reg;
-reg [7:0] host_ram2_reg;
-reg [7:0] host_ram3_reg;
-
-reg host_read_out_of_bounds;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                       host_read_out_of_bounds <= 1'b0;
-    else if(mem_read_valid && host_memory_out_of_bounds)    host_read_out_of_bounds <= 1'b1;
-    else                                                    host_read_out_of_bounds <= 1'b0;
-end
-
-reg [16:0] host_address_reduced_last;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)       host_address_reduced_last <= 17'd0;
-    else if(mem_read_valid) host_address_reduced_last <= host_address_reduced;
-end
-
-reg host_read_last;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)   host_read_last <= 1'd0;
-    else                host_read_last <= mem_read_valid && ~(host_memory_out_of_bounds);
-end
-
-wire [7:0] host_read_mode_1 = {
-    (graph_color_compare_dont_care[0]? ~(host_ram0_q[7] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[7] ^ graph_color_compare_map[1]) : 1'b1) &
-    (graph_color_compare_dont_care[2]? ~(host_ram2_q[7] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[7] ^ graph_color_compare_map[3]) : 1'b1),
-    (graph_color_compare_dont_care[0]? ~(host_ram0_q[6] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[6] ^ graph_color_compare_map[1]) : 1'b1) &
-    (graph_color_compare_dont_care[2]? ~(host_ram2_q[6] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[6] ^ graph_color_compare_map[3]) : 1'b1),
-    (graph_color_compare_dont_care[0]? ~(host_ram0_q[5] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[5] ^ graph_color_compare_map[1]) : 1'b1) &
-    (graph_color_compare_dont_care[2]? ~(host_ram2_q[5] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[5] ^ graph_color_compare_map[3]) : 1'b1),
-    (graph_color_compare_dont_care[0]? ~(host_ram0_q[4] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[4] ^ graph_color_compare_map[1]) : 1'b1) &
-    (graph_color_compare_dont_care[2]? ~(host_ram2_q[4] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[4] ^ graph_color_compare_map[3]) : 1'b1),
-    (graph_color_compare_dont_care[0]? ~(host_ram0_q[3] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[3] ^ graph_color_compare_map[1]) : 1'b1) &
-    (graph_color_compare_dont_care[2]? ~(host_ram2_q[3] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[3] ^ graph_color_compare_map[3]) : 1'b1),
-    (graph_color_compare_dont_care[0]? ~(host_ram0_q[2] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[2] ^ graph_color_compare_map[1]) : 1'b1) &
-    (graph_color_compare_dont_care[2]? ~(host_ram2_q[2] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[2] ^ graph_color_compare_map[3]) : 1'b1),
-    (graph_color_compare_dont_care[0]? ~(host_ram0_q[1] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[1] ^ graph_color_compare_map[1]) : 1'b1) &
-    (graph_color_compare_dont_care[2]? ~(host_ram2_q[1] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[1] ^ graph_color_compare_map[3]) : 1'b1),
-    (graph_color_compare_dont_care[0]? ~(host_ram0_q[0] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[0] ^ graph_color_compare_map[1]) : 1'b1) &
-    (graph_color_compare_dont_care[2]? ~(host_ram2_q[0] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[0] ^ graph_color_compare_map[3]) : 1'b1)
-};
-
-assign mem_readdata =
-    (host_read_out_of_bounds)?                                                                              8'hFF :
-    (seq_access_chain4 && host_address_reduced_last[1:0] == 2'b00)?                                         host_ram0_q :
-    (seq_access_chain4 && host_address_reduced_last[1:0] == 2'b01)?                                         host_ram1_q :
-    (seq_access_chain4 && host_address_reduced_last[1:0] == 2'b10)?                                         host_ram2_q :
-    (seq_access_chain4 && host_address_reduced_last[1:0] == 2'b11)?                                         host_ram3_q :
-    (graph_read_mode == 1'b0 && ~(seq_access_odd_even_disabled) && host_address_reduced_last[0] == 1'b0)?   host_ram0_q :
-    (graph_read_mode == 1'b0 && ~(seq_access_odd_even_disabled) && host_address_reduced_last[0] == 1'b1)?   host_ram1_q :
-    (graph_read_mode == 1'b0 && graph_read_map_select == 2'd0)?                                             host_ram0_q :
-    (graph_read_mode == 1'b0 && graph_read_map_select == 2'd1)?                                             host_ram1_q :
-    (graph_read_mode == 1'b0 && graph_read_map_select == 2'd2)?                                             host_ram2_q :
-    (graph_read_mode == 1'b0 && graph_read_map_select == 2'd3)?                                             host_ram3_q :
-                                                                                                            host_read_mode_1;
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) host_ram0_reg <= 8'd0; else if(host_read_last) host_ram0_reg <= host_ram0_q; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) host_ram1_reg <= 8'd0; else if(host_read_last) host_ram1_reg <= host_ram1_q; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) host_ram2_reg <= 8'd0; else if(host_read_last) host_ram2_reg <= host_ram2_q; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) host_ram3_reg <= 8'd0; else if(host_read_last) host_ram3_reg <= host_ram3_q; end
-
-
-//------------------------------------------------------------------------------ mem write
-
-wire host_write = mem_write && ~(host_memory_out_of_bounds);
-
-wire [7:0] host_writedata_rotate =
-    (graph_write_rotate == 3'd0)?     mem_writedata[7:0] :
-    (graph_write_rotate == 3'd1)?   { mem_writedata[0],   mem_writedata[7:1] } :
-    (graph_write_rotate == 3'd2)?   { mem_writedata[1:0], mem_writedata[7:2] } :
-    (graph_write_rotate == 3'd3)?   { mem_writedata[2:0], mem_writedata[7:3] } :
-    (graph_write_rotate == 3'd4)?   { mem_writedata[3:0], mem_writedata[7:4] } :
-    (graph_write_rotate == 3'd5)?   { mem_writedata[4:0], mem_writedata[7:5] } :
-    (graph_write_rotate == 3'd6)?   { mem_writedata[5:0], mem_writedata[7:6] } :
-                                    { mem_writedata[6:0], mem_writedata[7] };
-    
-wire [7:0] host_write_set_0 = (graph_write_mode == 2'd2)? {8{mem_writedata[0]}} : graph_write_enable_map[0]?  {8{graph_write_set_map[0]}} : host_writedata_rotate;
-wire [7:0] host_write_set_1 = (graph_write_mode == 2'd2)? {8{mem_writedata[1]}} : graph_write_enable_map[1]?  {8{graph_write_set_map[1]}} : host_writedata_rotate;
-wire [7:0] host_write_set_2 = (graph_write_mode == 2'd2)? {8{mem_writedata[2]}} : graph_write_enable_map[2]?  {8{graph_write_set_map[2]}} : host_writedata_rotate;
-wire [7:0] host_write_set_3 = (graph_write_mode == 2'd2)? {8{mem_writedata[3]}} : graph_write_enable_map[3]?  {8{graph_write_set_map[3]}} : host_writedata_rotate;
-
-wire [31:0] host_write_function =
-    (graph_write_function == 2'd1)? { host_write_set_3, host_write_set_2, host_write_set_1, host_write_set_0 } & { host_ram3_reg, host_ram2_reg, host_ram1_reg, host_ram0_reg } :
-    (graph_write_function == 2'd2)? { host_write_set_3, host_write_set_2, host_write_set_1, host_write_set_0 } | { host_ram3_reg, host_ram2_reg, host_ram1_reg, host_ram0_reg } :
-    (graph_write_function == 2'd3)? { host_write_set_3, host_write_set_2, host_write_set_1, host_write_set_0 } ^ { host_ram3_reg, host_ram2_reg, host_ram1_reg, host_ram0_reg } :
-                                    { host_write_set_3, host_write_set_2, host_write_set_1, host_write_set_0 };
-
-wire [7:0] host_write_mask_0 = (graph_write_mask & host_write_function[7:0])   | (~(graph_write_mask) & host_ram0_reg);
-wire [7:0] host_write_mask_1 = (graph_write_mask & host_write_function[15:8])  | (~(graph_write_mask) & host_ram1_reg);
-wire [7:0] host_write_mask_2 = (graph_write_mask & host_write_function[23:16]) | (~(graph_write_mask) & host_ram2_reg);
-wire [7:0] host_write_mask_3 = (graph_write_mask & host_write_function[31:24]) | (~(graph_write_mask) & host_ram3_reg);
-
-wire [7:0] host_write_mode_3_mask = host_writedata_rotate & graph_write_mask;
-wire [7:0] host_write_mode_3_ram0 = (host_write_mode_3_mask & {8{graph_write_set_map[0]}})   | (~(host_write_mode_3_mask) & host_ram0_reg);
-wire [7:0] host_write_mode_3_ram1 = (host_write_mode_3_mask & {8{graph_write_set_map[1]}})   | (~(host_write_mode_3_mask) & host_ram1_reg);
-wire [7:0] host_write_mode_3_ram2 = (host_write_mode_3_mask & {8{graph_write_set_map[2]}})   | (~(host_write_mode_3_mask) & host_ram2_reg);
-wire [7:0] host_write_mode_3_ram3 = (host_write_mode_3_mask & {8{graph_write_set_map[3]}})   | (~(host_write_mode_3_mask) & host_ram3_reg);
-
-wire [31:0] host_writedata =
-    (graph_write_mode == 2'd0 || graph_write_mode == 2'd2)?     { host_write_mask_3, host_write_mask_2, host_write_mask_1, host_write_mask_0 } :
-    (graph_write_mode == 2'd1)?                                 { host_ram3_reg, host_ram2_reg, host_ram1_reg, host_ram0_reg } :
-                                                                { host_write_mode_3_ram3, host_write_mode_3_ram2, host_write_mode_3_ram1, host_write_mode_3_ram0 };
-    
-wire [3:0] host_write_enable_for_chain4 =
-    (host_address_reduced[1:0] == 2'd0)?    4'b0001 :
-    (host_address_reduced[1:0] == 2'd1)?    4'b0010 :
-    (host_address_reduced[1:0] == 2'd2)?    4'b0100 :
-                                            4'b1000;
-wire [3:0] host_write_enable_for_odd_even =
-    (host_address_reduced[0] == 1'd0)?      4'b0101 :
-                                            4'b1010;
-                                            
-wire [3:0] host_write_enable = 
-    {4{host_write}} & seq_map_write_enable & (
-    (seq_access_chain4)?                host_write_enable_for_chain4 :
-    (~(seq_access_odd_even_disabled))?  host_write_enable_for_odd_even :
-                                        4'b1111); 
-
-//------------------------------------------------------------------------------
-
-wire dot_memory_load;
-wire dot_memory_load_first_in_frame;
-wire dot_memory_load_first_in_line_matched;
-wire dot_memory_load_first_in_line;
-wire dot_memory_load_vertical_retrace_start;
-
-wire memory_address_load = dot_memory_load_first_in_frame || dot_memory_load_first_in_line_matched || dot_memory_load_first_in_line;
-
-reg [15:0] memory_start_line;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)               memory_start_line <= 16'd0;
-    else if(memory_address_load)    memory_start_line <= memory_address;
-end
-
-reg [15:0] memory_address_reg;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                               memory_address_reg <= 16'd0;
-    else if(memory_address_load || dot_memory_load) memory_address_reg <= memory_address;
-end
-
-reg [4:0] memory_row_scan_reg;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)               memory_row_scan_reg <= 5'd0;
-    else if(memory_address_load)    memory_row_scan_reg <= memory_row_scan;
-end
-
-reg memory_row_scan_double;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                               memory_row_scan_double <= 1'b0;
-    else if(crtc_vertical_doublescan && (dot_memory_load_first_in_frame || dot_memory_load_first_in_line_matched))  memory_row_scan_double <= 1'b1;
-    else if(crtc_vertical_doublescan && dot_memory_load_first_in_line)                                              memory_row_scan_double <= ~memory_row_scan_double;
-    else if(~(crtc_vertical_doublescan) || dot_memory_load_vertical_retrace_start)                                  memory_row_scan_double <= 1'b0;
-end
-
-//do not change charmap in the middle of a character row scan
-reg [2:0] memory_char_map_a;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                                                               memory_char_map_a <= 3'd0;
-    else if(dot_memory_load_first_in_frame || dot_memory_load_first_in_line_matched || (dot_memory_load_first_in_line && memory_row_scan == 5'd0))  memory_char_map_a <= seq_char_map_a;
-end
-
-reg [2:0] memory_char_map_b;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                                                               memory_char_map_b <= 3'd0;
-    else if(dot_memory_load_first_in_frame || dot_memory_load_first_in_line_matched || (dot_memory_load_first_in_line && memory_row_scan == 5'd0))  memory_char_map_b <= seq_char_map_b;
-end
-
-
-reg [3:0] memory_panning_reg;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                       memory_panning_reg <= 4'd0;
-    else if(dot_memory_load_first_in_line_matched && attrib_panning_after_compare_match)    memory_panning_reg <= 4'd0;
-    else if(dot_memory_load_first_in_frame)                                                 memory_panning_reg <= attrib_panning_value;
-end
-
-reg memory_load_step_a;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           memory_load_step_a <= 1'b0;
-    else if(dot_memory_load)    memory_load_step_a <= 1'b1;
-    else                        memory_load_step_a <= 1'b0;
-end
-
-reg memory_load_step_b;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           memory_load_step_b <= 1'b0;
-    else if(memory_load_step_a) memory_load_step_b <= 1'b1;
-    else                        memory_load_step_b <= 1'b0;
-end
-
-wire [15:0] memory_address =
-    (dot_memory_load_first_in_line_matched)?                                    16'd0 :
-    (dot_memory_load_first_in_frame)?                                           crtc_address_start + { 14'd0, crtc_address_byte_panning } :
-    (dot_memory_load_first_in_line && memory_row_scan_double)?                  memory_start_line :
-    (dot_memory_load_first_in_line && memory_row_scan_reg < crtc_row_max)?      memory_start_line :
-    (dot_memory_load_first_in_line)?                                            memory_start_line + { 7'd0, crtc_address_offset[7:0], 1'b0 } :
-    (dot_memory_load)?                                                          memory_address_reg + 16'd1 :
-                                                                                memory_address_reg;
-    
-wire [4:0] memory_row_scan =
-    (dot_memory_load_first_in_line_matched)?                                5'd0 :
-    (dot_memory_load_first_in_frame && crtc_row_preset <= crtc_row_max)?    crtc_row_preset :
-    (dot_memory_load_first_in_frame)?                                       5'd0 :
-    (dot_memory_load_first_in_line && memory_row_scan_double)?              memory_row_scan_reg :
-    (dot_memory_load_first_in_line && memory_row_scan_reg == crtc_row_max)? 5'd0 :
-    (dot_memory_load_first_in_line)?                                        memory_row_scan_reg + 5'd1 :
-                                                                            memory_row_scan_reg;
-
-wire [15:0] memory_address_step_1 =
-    (crtc_address_doubleword)?  { memory_address[13:0], memory_address[15:14] } :
-    (crtc_address_byte)?        memory_address :
-    (crtc_address_bit0)?        { memory_address[14:0], memory_address[15] } :
-                                { memory_address[14:0], memory_address[13] };
-
-wire [15:0] memory_address_step_2 = {
-    memory_address_step_1[15],
-    (crtc_address_bit14)?           memory_address_step_1[14] : memory_row_scan[1],
-    (crtc_address_bit13)?           memory_address_step_1[13] : memory_row_scan[0],
-    memory_address_step_1[12:0]
-};
-
-reg [15:0] memory_address_reg_final;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           memory_address_reg_final <= 16'd0;
-    else if(dot_memory_load)    memory_address_reg_final <= memory_address;
-end
-
-wire [2:0] memory_txt_index = plane_ram1_q[3]? memory_char_map_a : memory_char_map_b;
-
-wire [15:0] memory_txt_address_base =
-    ((~(seq_access_256kb) && memory_txt_index[2] == 1'b0) || memory_txt_index == 3'b000)?   16'h0000 :
-    ((~(seq_access_256kb) && memory_txt_index[2] == 1'b1) || memory_txt_index == 3'b100)?   16'h2000 :
-    (memory_txt_index == 3'b001)?                                                           16'h4000 :
-    (memory_txt_index == 3'b101)?                                                           16'h6000 :
-    (memory_txt_index == 3'b010)?                                                           16'h8000 :
-    (memory_txt_index == 3'b110)?                                                           16'hA000 :
-    (memory_txt_index == 3'b011)?                                                           16'hC000 :
-                                                                                            16'hE000;
-
-wire [15:0] memory_txt_address = { memory_txt_address_base[15:13], plane_ram0_q[7:0], memory_row_scan_reg };
-
-//------------------------------------------------------------------------------
-
-wire [7:0] plane_ram0_q;
-wire [7:0] plane_ram1_q;
-wire [7:0] plane_ram2_q;
-wire [7:0] plane_ram3_q;
-
-
-simple_bidir_ram #(
-    .widthad    (16),
-    .width      (8)
-)
-plane_ram_inst0(
-    .clk            (clk_26),
-    
-    .address_a      (host_address),
-    .data_a         (host_writedata[7:0]),
-    .wren_a         (general_enable_ram && host_write_enable[0]),
-    .q_a            (host_ram0_q),
-    
-    .address_b      (memory_address_step_2),
-    .q_b            (plane_ram0_q)
-);
-
-simple_bidir_ram #(
-    .widthad    (16),
-    .width      (8)
-)
-plane_ram_inst1(
-    .clk            (clk_26),
-    
-    .address_a      (host_address),
-    .data_a         (host_writedata[15:8]),
-    .wren_a         (general_enable_ram && host_write_enable[1]),
-    .q_a            (host_ram1_q),
-    
-    .address_b      (memory_address_step_2),
-    .q_b            (plane_ram1_q)
-);
-
-simple_bidir_ram #(
-    .widthad    (16),
-    .width      (8)
-)
-plane_ram_inst2(
-    .clk            (clk_26),
-    
-    .address_a      (host_address),
-    .data_a         (host_writedata[23:16]),
-    .wren_a         (general_enable_ram && host_write_enable[2]),
-    .q_a            (host_ram2_q),
-    
-    .address_b      (memory_load_step_a? memory_txt_address : memory_address_step_2),
-    .q_b            (plane_ram2_q)
-);
-
-simple_bidir_ram #(
-    .widthad    (16),
-    .width      (8)
-)
-plane_ram_inst3(
-    .clk            (clk_26),
-    
-    .address_a      (host_address),
-    .data_a         (host_writedata[31:24]),
-    .wren_a         (general_enable_ram && host_write_enable[3]),
-    .q_a            (host_ram3_q),
-    
-    .address_b      (memory_address_step_2),
-    .q_b            (plane_ram3_q)
-);
-
-//------------------------------------------------------------------------------
-
-reg [7:0] plane_ram0;
-reg [7:0] plane_ram1;
-reg [7:0] plane_ram2;
-reg [7:0] plane_ram3;
-
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) plane_ram0 <= 8'd0; else if(memory_load_step_a) plane_ram0 <= plane_ram0_q; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) plane_ram1 <= 8'd0; else if(memory_load_step_a) plane_ram1 <= plane_ram1_q; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) plane_ram2 <= 8'd0; else if(memory_load_step_a) plane_ram2 <= plane_ram2_q; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) plane_ram3 <= 8'd0; else if(memory_load_step_a) plane_ram3 <= plane_ram3_q; end
-
-//------------------------------------------------------------------------------
-
-reg [5:0] plane_shift_cnt;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                   plane_shift_cnt <= 6'd0;
-    else if(memory_load_step_b)         plane_shift_cnt <= 6'd1;
-    else if(plane_shift_cnt == 6'd34)   plane_shift_cnt <= 6'd0;
-    else if(plane_shift_cnt != 6'd0)    plane_shift_cnt <= plane_shift_cnt + 6'd1;
-end
-
-wire plane_shift_enable = 
-    (~(seq_dotclock_divided) && plane_shift_cnt >= 6'd1) ||
-    (  seq_dotclock_divided  && plane_shift_cnt >= 6'd1 && plane_shift_cnt[0]);
-    
-wire plane_shift_9dot =
-    ~(seq_8dot_char) && plane_shift_enable &&
-    (~(seq_dotclock_divided) && plane_shift_cnt == 6'd9) ||
-    (  seq_dotclock_divided  && plane_shift_cnt == 6'd17);
-
-//------------------------------------------------------------------------------
-
-reg [7:0] plane_shift0;
-reg [7:0] plane_shift1;
-reg [7:0] plane_shift2;
-reg [7:0] plane_shift3;
-
-wire [7:0] plane_shift_value0 =
-    (graph_shift_mode == 2'b00)?    plane_ram0 :
-    (graph_shift_mode == 2'b01)?    { plane_ram0[6],plane_ram0[4],plane_ram0[2],plane_ram0[0], plane_ram1[6],plane_ram1[4],plane_ram1[2],plane_ram1[0] } :
-                                    { plane_ram0[4],plane_ram0[0],plane_ram1[4],plane_ram1[0], plane_ram2[4],plane_ram2[0],plane_ram3[4],plane_ram3[0] };
-
-wire [7:0] plane_shift_value1 =
-    (graph_shift_mode == 2'b00)?    plane_ram1 :
-    (graph_shift_mode == 2'b01)?    { plane_ram0[7],plane_ram0[5],plane_ram0[3],plane_ram0[1], plane_ram1[7],plane_ram1[5],plane_ram1[3],plane_ram1[1] } :
-                                    { plane_ram0[5],plane_ram0[1],plane_ram1[5],plane_ram1[1], plane_ram2[5],plane_ram2[1],plane_ram3[5],plane_ram3[1] };
-
-wire [7:0] plane_shift_value2 =
-    (graph_shift_mode == 2'b00)?    plane_ram2 :
-    (graph_shift_mode == 2'b01)?    { plane_ram2[6],plane_ram2[4],plane_ram2[2],plane_ram2[0], plane_ram3[6],plane_ram3[4],plane_ram3[2],plane_ram3[0] } :
-                                    { plane_ram0[6],plane_ram0[2],plane_ram1[6],plane_ram1[2], plane_ram2[6],plane_ram2[2],plane_ram3[6],plane_ram3[2] };
-
-wire [7:0] plane_shift_value3 =
-    (graph_shift_mode == 2'b00)?    plane_ram3 :
-    (graph_shift_mode == 2'b01)?    { plane_ram2[7],plane_ram2[5],plane_ram2[3],plane_ram2[1], plane_ram3[7],plane_ram3[5],plane_ram3[3],plane_ram3[1] } :
-                                    { plane_ram0[7],plane_ram0[3],plane_ram1[7],plane_ram1[3], plane_ram2[7],plane_ram2[3],plane_ram3[7],plane_ram3[3] };
-                                    
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           plane_shift0 <= 8'd0;
-    else if(memory_load_step_b) plane_shift0 <= plane_shift_value0;
-    else if(plane_shift_enable) plane_shift0 <= { plane_shift0[6:0], 1'b0 };
-end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           plane_shift1 <= 8'd0;
-    else if(memory_load_step_b) plane_shift1 <= plane_shift_value1;
-    else if(plane_shift_enable) plane_shift1 <= { plane_shift1[6:0], 1'b0 };
-end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           plane_shift2 <= 8'd0;
-    else if(memory_load_step_b) plane_shift2 <= plane_shift_value2;
-    else if(plane_shift_enable) plane_shift2 <= { plane_shift2[6:0], 1'b0 };
-end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           plane_shift3 <= 8'd0;
-    else if(memory_load_step_b) plane_shift3 <= plane_shift_value3;
-    else if(plane_shift_enable) plane_shift3 <= { plane_shift3[6:0], 1'b0 };
-end
-
-//------------------------------------------------------------------------------
-
-reg [7:0] plane_txt_shift;
-
-wire blink_txt_value;
-wire blink_cursor_value;
-
-wire txt_blink_enabled = attrib_blinking && plane_ram1[7] && blink_txt_value;
-
-wire txt_underline_enable = plane_ram1[2:0] == 3'b001 && plane_ram1[6:4] == 3'b000 && crtc_row_underline > 5'd0 && crtc_row_underline - 5'd1 == memory_row_scan_reg;
-
-wire txt_cursor_enable =
-    ~(crtc_cursor_off) &&
-    blink_cursor_value &&
-    memory_address_reg_final == crtc_address_cursor + { 14'd0, crtc_cursor_skew } &&
-    memory_row_scan_reg >= crtc_cursor_row_start &&
-    memory_row_scan_reg <= crtc_cursor_row_end &&
-    crtc_cursor_row_start <= crtc_cursor_row_end;
-
-wire [7:0] plane_txt_shift_value =
-    (txt_blink_enabled)?        8'd0 :
-    (txt_underline_enable)?     8'hFF :
-    (txt_cursor_enable)?        8'hFF :
-                                plane_ram2_q;
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           plane_txt_shift <= 8'd0;
-    else if(memory_load_step_b) plane_txt_shift <= plane_txt_shift_value;
-    else if(plane_shift_enable) plane_txt_shift <= { plane_txt_shift[6:0], 1'b0 };
-end
-
-reg [3:0] txt_foreground;
-reg [3:0] txt_background;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           txt_foreground <= 4'd0;
-    else if(memory_load_step_b) txt_foreground <= plane_ram1[3:0];
-end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           txt_background <= 4'd0;
-    else if(memory_load_step_b) txt_background <= (attrib_blinking)? { 1'b0, plane_ram1[6:4] } : plane_ram1[7:4];
-end
-
-wire txt_line_graphic_char = plane_ram0 >= 8'hB0 && plane_ram0 <= 8'hDF;
-
-//------------------------------------------------------------------------------
-
-wire [3:0] pel_input =
-    (plane_shift_9dot && attrib_9bit_same_as_8bit && pel_line_graphic_char)?   pel_input_last :
-    (plane_shift_9dot)?                                                        pel_background :
-    
-    (attrib_graphic_mode)?  { plane_shift3[7], plane_shift2[7], plane_shift1[7], plane_shift0[7] } :
-    (plane_txt_shift[7])?   txt_foreground :
-                            txt_background;
-
-reg [3:0] pel_input_last;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           pel_input_last <= 4'd0;
-    else if(plane_shift_enable) pel_input_last <= pel_input;
-end
-
-reg pel_line_graphic_char;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           pel_line_graphic_char <= 1'b0;
-    else if(plane_shift_enable) pel_line_graphic_char <= txt_line_graphic_char;
-end
-
-reg [3:0] pel_background;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           pel_background <= 4'd0;
-    else if(plane_shift_enable) pel_background <= txt_background;
-end
-
-//------------------------------------------------------------------------------
-
-wire [3:0] pel_after_enable = attrib_mask & pel_input;
-
-//APA blinking logic (undocumented)
-wire [3:0] pel_after_blink =
-    (attrib_graphic_mode && attrib_blinking && blink_txt_value)?    { 1'b1, pel_after_enable[2:0] } :
-    (attrib_graphic_mode && attrib_blinking)?                       pel_after_enable ^ 4'b1000 :
-                                                                    pel_after_enable;
-
-reg [35:0] pel_shift_reg;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           pel_shift_reg <= 36'd0;
-    else if(plane_shift_enable) pel_shift_reg <= { pel_after_blink, pel_shift_reg[35:4] };
-end
-
-wire [7:0] pel_after_panning =
-    (memory_panning_reg == 4'd0)?     pel_shift_reg[11:4] :
-    (memory_panning_reg == 4'd1)?     pel_shift_reg[15:8] :
-    (memory_panning_reg == 4'd2)?     pel_shift_reg[19:12] :
-    (memory_panning_reg == 4'd3)?     pel_shift_reg[23:16] :
-    (memory_panning_reg == 4'd4)?     pel_shift_reg[27:20] :
-    (memory_panning_reg == 4'd5)?     pel_shift_reg[31:24] :
-    (memory_panning_reg == 4'd6)?     pel_shift_reg[35:28] :
-    (memory_panning_reg == 4'd7)?     { 4'd0, pel_shift_reg[35:32] } :
-                                      pel_shift_reg[7:0];
-
-reg plane_shift_enable_last;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) plane_shift_enable_last <= 1'b0; else plane_shift_enable_last <= plane_shift_enable; end
-                                      
-reg pel_color_8bit_cnt;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                               pel_color_8bit_cnt <= 1'b0;
-    else if(plane_shift_enable && plane_shift_enable_last == 1'b0)  pel_color_8bit_cnt <= 1'b1;
-    else                                                            pel_color_8bit_cnt <= ~pel_color_8bit_cnt;
-end
-
-reg [7:0] pel_color_8bit_buffer;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                   pel_color_8bit_buffer <= 8'd0;
-    else if(pel_color_8bit_cnt == 1'b0) pel_color_8bit_buffer <= pel_after_panning;
-end
-//------------------------------------------------------------------------------
-
-wire [5:0] pel_palette;
-
-simple_bidir_ram #(
-    .widthad    (4),
-    .width      (6)
-)
-internal_palette_ram_inst(
-    .clk            (clk_26),
-    
-    .address_a      (attrib_io_index[3:0]),
-    .data_a         (io_c_writedata[5:0]),
-    .wren_a         (attrib_io_write && attrib_io_index < 5'h10),
-    .q_a            (host_palette_q),
-    
-    .address_b      (pel_after_panning[3:0]),
-    .q_b            (pel_palette)
-);
-
-wire [7:0] pel_palette_index = {
-    attrib_color_bit7_6_value,
-    (attrib_color_bit5_4_enable)? attrib_color_bit5_4_value : pel_palette[5:4],
-    pel_palette[3:0]
-};
-
-wire vgaprep_overscan;
-
-wire [7:0] pel_index =
-    (vgaprep_overscan)?             attrib_color_overscan :
-    (~(attrib_video_enable))?       8'h00 :
-    (attrib_color_8bit_enable)?     { pel_color_8bit_buffer[3:0], pel_color_8bit_buffer[7:4] } :
-                                    pel_palette_index;
-
-//------------------------------------------------------------------------------
-
-wire [17:0] dac_color;
-
-simple_bidir_ram #(
-    .widthad    (8),
-    .width      (18)
-)
-dac_ram_inst(
-    .clk            (clk_26),
-    
-    .address_a      (dac_is_read? dac_read_index : dac_write_index),
-    .data_a         ({ dac_write_buffer, io_c_writedata[5:0] }),
-    .wren_a         (io_c_write && io_c_address == 4'h9 && dac_cnt == 2'd2),
-    .q_a            (dac_read_q),
-    
-    .address_b      (pel_index),
-    .q_b            (dac_color)
-);
-
-//------------------------------------------------------------------------------
-
-wire character_last_dot = dot_cnt_enable && ((dot_cnt == 4'd8 && ~(seq_8dot_char)) || (dot_cnt == 4'd7 && seq_8dot_char));
-wire line_last_dot      = horiz_cnt == crtc_horizontal_total + 8'd4 && character_last_dot;
-wire screen_last_dot    = vert_cnt == crtc_vertical_total - 10'd1   && line_last_dot;
-
-reg [3:0] dot_cnt;
-reg [7:0] horiz_cnt;
-reg [9:0] vert_cnt;
-
-reg dot_cnt_div;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)   dot_cnt_div <= 1'b0;
-    else                dot_cnt_div <= ~(dot_cnt_div);
-end
-
-wire dot_cnt_enable = ~(seq_dotclock_divided) || dot_cnt_div;
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                               dot_cnt <= 4'd0;
-    else if(dot_cnt_enable && character_last_dot)   dot_cnt <= 4'd0;
-    else if(dot_cnt_enable)                         dot_cnt <= dot_cnt + 4'd1;
-end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           horiz_cnt <= 8'd0;
-    else if(line_last_dot)      horiz_cnt <= 8'd0;
-    else if(character_last_dot) horiz_cnt <= horiz_cnt + 8'd1;
-end
-
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           vert_cnt <= 10'd0;
-    else if(screen_last_dot)    vert_cnt <= 10'd0;
-    else if(line_last_dot)      vert_cnt <= vert_cnt + 10'd1;
-end
-
-assign dot_memory_load = 
-    (   (seq_8dot_char    && ~(seq_dotclock_divided) && dot_cnt_enable    && dot_cnt == 4'd3) ||
-        (seq_8dot_char    && seq_dotclock_divided    && ~(dot_cnt_enable) && dot_cnt == 4'd6) ||
-        (~(seq_8dot_char) && ~(seq_dotclock_divided) && dot_cnt_enable    && dot_cnt == 4'd4) ||
-        (~(seq_8dot_char) && seq_dotclock_divided    && ~(dot_cnt_enable) && dot_cnt == 4'd7)
-    ) &&
-    (   (vert_cnt == crtc_vertical_total - 10'd1 && horiz_cnt >= crtc_horizontal_total + 8'd3) ||
-        (vert_cnt < crtc_vertical_display_size && (horiz_cnt <= crtc_horizontal_display_size - 8'd2 || horiz_cnt >= crtc_horizontal_total + 8'd3)) ||
-        (vert_cnt == crtc_vertical_display_size && horiz_cnt <= crtc_horizontal_display_size - 8'd2)
-    );
-    
-assign dot_memory_load_first_in_frame = dot_memory_load && vert_cnt == crtc_vertical_total - 10'd1 && horiz_cnt == crtc_horizontal_total + 8'd3;
-assign dot_memory_load_first_in_line  = dot_memory_load && horiz_cnt == crtc_horizontal_total + 8'd3;
-assign dot_memory_load_first_in_line_matched =
-    dot_memory_load_first_in_line && (
-    (crtc_line_compare > 10'd0 && vert_cnt == crtc_line_compare - 10'd1) ||
-    (crtc_line_compare == 10'd0 && vert_cnt == crtc_vertical_total - 10'd1));
-
-assign dot_memory_load_vertical_retrace_start = vert_cnt == crtc_vertical_retrace_start;
-    
-//------------------------------------------------------------------------------
-
-reg host_io_vertical_retrace_last;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)   host_io_vertical_retrace_last <= 1'b0;
-    else                host_io_vertical_retrace_last <= host_io_vertical_retrace;
-end
-
-reg [5:0] blink_cnt;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)           blink_cnt <= 6'd0;
-    else if(host_io_vertical_retrace_last == 1'b1 && host_io_vertical_retrace == 1'b0) blink_cnt <= blink_cnt + 6'd1;
-end
-
-assign blink_txt_value    = blink_cnt[5];
-assign blink_cursor_value = blink_cnt[4];
-
-//------------------------------------------------------------------------------
-
-reg vgaprep_horiz_blank;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                                       vgaprep_horiz_blank <= 1'b0;
-    else if(horiz_cnt == crtc_horizontal_blanking_start)                                                    vgaprep_horiz_blank <= 1'b1;
-    else if(horiz_cnt > crtc_horizontal_blanking_start && horiz_cnt[5:0] == crtc_horizontal_blanking_end)   vgaprep_horiz_blank <= 1'b0;
-end
-
-reg vgaprep_vert_blank;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                               vgaprep_vert_blank <= 1'b0;
-    else if(vert_cnt == crtc_vertical_blanking_start)                                               vgaprep_vert_blank <= 1'b1;
-    else if(vert_cnt > crtc_vertical_blanking_start && vert_cnt[7:0] == crtc_vertical_blanking_end) vgaprep_vert_blank <= 1'b0;
-end
-
-wire vgaprep_blank = 
-    seq_screen_disable || ~(seq_sync_reset_n) || ~(seq_async_reset_n) ||
-    //horizontal
-    horiz_cnt == crtc_horizontal_blanking_start || (horiz_cnt > crtc_horizontal_blanking_start && vgaprep_horiz_blank && horiz_cnt[5:0] != crtc_horizontal_blanking_end) ||
-    //line before vertical blank
-    (horiz_cnt >= crtc_horizontal_blanking_start && vert_cnt + 10'd1 == crtc_vertical_blanking_start) ||
-    //last line of vertical blank
-    ((~(vgaprep_vert_blank) || (vert_cnt[7:0] + 8'd1 != crtc_vertical_blanking_end) || horiz_cnt < crtc_horizontal_blanking_start) &&
-        //vertical
-        (vert_cnt == crtc_vertical_blanking_start    || (vert_cnt > crtc_vertical_blanking_start && vgaprep_vert_blank && vert_cnt[7:0] != crtc_vertical_blanking_end)));
-
-wire vgaprep_horiz_sync =
-    horiz_cnt == (crtc_horizontal_retrace_start + { 6'd0, crtc_horizontal_retrace_skew }) ||
-    (horiz_cnt > (crtc_horizontal_retrace_start + { 6'd0, crtc_horizontal_retrace_skew }) && vgareg0_horiz_sync == ~(general_hsync) && horiz_cnt[4:0] != crtc_horizontal_retrace_end);
-    
-wire vgaprep_vert_sync =
-    vert_cnt == crtc_vertical_retrace_start ||
-    (vert_cnt > crtc_vertical_retrace_start && vgareg0_vert_sync == ~(general_vsync) && vert_cnt[3:0] != crtc_vertical_retrace_end);
-    
-//one cycle before input to vgareg_*
-assign vgaprep_overscan = 
-    (horiz_cnt > crtc_horizontal_display_size  && ~(line_last_dot)) ||
-    (horiz_cnt == crtc_horizontal_display_size && character_last_dot) ||
-    (vert_cnt > crtc_vertical_display_size     && ~(screen_last_dot)) ||
-    (vert_cnt == crtc_vertical_display_size    && line_last_dot);
-
-//------------------------------------------------------------------------------
-
-wire [8:0] sys_readdata_from_ram;
-
-assign sys_readdata = { 23'd0, sys_readdata_from_ram };
-
-reg sys_enabled;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                               sys_enabled <= 1'b0;
-    else if(sys_write && sys_writedata[15] == 1'b1) sys_enabled <= sys_writedata[14];
-end
-
-wire [8:0] sys_character;
-wire [7:0] sys_line;
-
-reg [6:0] sys_horiz_cnt;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                   sys_horiz_cnt <= 7'd0;
-    else if(sys_horiz_cnt == 7'd0 && horiz_cnt == 8'd1) sys_horiz_cnt <= 7'd1;
-    else if(sys_horiz_cnt > 7'd0)                       sys_horiz_cnt <= sys_horiz_cnt + 7'd1;
-end
-
-wire [6:0] sys_horiz_cnt_plus_4 = sys_horiz_cnt + 7'd2;
-
-
-simple_bidir_ram #(
-    .widthad    (8),
-    .width      (9)
-)
-vga_system_ram (
-    .clk        (clk_26),
-
-    .address_a  (sys_address),
-    .wren_a     (sys_write && sys_writedata[15:9] == 7'd0),
-    .data_a     (sys_writedata[8:0]),
-    .q_a        (sys_readdata_from_ram),
-
-    .address_b  ({ ((vert_cnt >= 10'd256)? 4'd0 : vert_cnt[7:4]), sys_horiz_cnt_plus_4[6:3] }),
-    .q_b        (sys_character)
-);
-
-reg sys_inverted;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)   sys_inverted <= 1'b0;
-    else                sys_inverted <= sys_character[8];
-end
-
-simple_single_rom #(
-    .widthad    (11),
-    .width      (8),
-    .datafile   ("./../soc/vga/vga_font.bin")
-)
-vga_font_rom_inst (
-    .clk        (clk_26),
-    .addr       ({ sys_character[6:0], vert_cnt[3:0] }),
-    .q          (sys_line)
-);
-
-wire sys_pixel =
-    (sys_horiz_cnt[2:0] == 3'd0)? sys_line[0] :
-    (sys_horiz_cnt[2:0] == 3'd1)? sys_line[1] :
-    (sys_horiz_cnt[2:0] == 3'd2)? sys_line[2] :
-    (sys_horiz_cnt[2:0] == 3'd3)? sys_line[3] :
-    (sys_horiz_cnt[2:0] == 3'd4)? sys_line[4] :
-    (sys_horiz_cnt[2:0] == 3'd5)? sys_line[5] :
-    (sys_horiz_cnt[2:0] == 3'd6)? sys_line[6] :
-                                  sys_line[7];
-    
-wire [7:0] sys_pixel_color = (sys_pixel ^ sys_inverted)? 8'd255 : 8'd30;
-
-//------------------------------------------------------------------------------
-
-assign host_io_vertical_retrace = vgaprep_vert_sync;
-assign host_io_not_displaying   = vgaprep_blank;
-
-reg vgareg_blank_n;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) vgareg_blank_n <= 1'b0; else vgareg_blank_n <= ~(vgaprep_blank); end
-
-reg vgareg0_horiz_sync;
-reg vgareg1_horiz_sync;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) vgareg0_horiz_sync <= 1'b0; else vgareg0_horiz_sync <= (vgaprep_horiz_sync && crtc_enable_sync)? ~(general_hsync) : general_hsync; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) vgareg1_horiz_sync <= 1'b0; else vgareg1_horiz_sync <= vgareg0_horiz_sync; end
-
-reg vgareg0_vert_sync;
-reg vgareg1_vert_sync;
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) vgareg0_vert_sync <= 1'b0; else vgareg0_vert_sync <= (vgaprep_vert_sync && crtc_enable_sync)? ~(general_vsync) : general_vsync; end
-always @(posedge clk_26 or negedge rst_n) begin if(rst_n == 1'b0) vgareg1_vert_sync <= 1'b0; else vgareg1_vert_sync <= vgareg0_vert_sync; end
-
-reg [7:0] vgareg_r;
-reg [7:0] vgareg_g;
-reg [7:0] vgareg_b;
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                           vgareg_r <= 8'b0;
-    else if(sys_enabled && (horiz_cnt == 8'd1 || sys_horiz_cnt > 7'd0) && vert_cnt < 10'd256)   vgareg_r <= sys_pixel_color;
-    else                                                                                        vgareg_r <= { dac_color[17:12], 2'b0 };
-end
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                           vgareg_g <= 8'b0;
-    else if(sys_enabled && (horiz_cnt == 8'd1 || sys_horiz_cnt > 7'd0) && vert_cnt < 10'd256)   vgareg_g <= sys_pixel_color;
-    else                                                                                        vgareg_g <= { dac_color[11:6], 2'b0 };
-end
-always @(posedge clk_26 or negedge rst_n) begin
-    if(rst_n == 1'b0)                                                                           vgareg_b <= 8'b0;
-    else if(sys_enabled && (horiz_cnt == 8'd1 || sys_horiz_cnt > 7'd0) && vert_cnt < 10'd256)   vgareg_b <= sys_pixel_color;
-    else                                                                                        vgareg_b <= { dac_color[5:0], 2'b0 };
-end
-
-assign vga_clock  = clk_26;
-assign vga_sync_n = 1'b0;
-
-assign vga_blank_n    = vgareg_blank_n;
-assign vga_horiz_sync = vgareg1_horiz_sync;
-assign vga_vert_sync  = vgareg1_vert_sync;
-
-assign vga_r = vgareg_r;
-assign vga_g = vgareg_g;
-assign vga_b = vgareg_b;
-
-//------------------------------------------------------------------------------
-
-// synthesis translate_off
-wire _unused_ok = &{ 1'b0, sys_read, sys_writedata[31:16], host_address_reduced_last[16:2], memory_txt_address_base[12:0], sys_character[7], sys_horiz_cnt_plus_4[2:0], 1'b0 };
-// synthesis translate_on
-
-//------------------------------------------------------------------------------
+   assign host_io_read_wire =
+                 (host_io_ignored)?                                  8'hFF :
+                 (io_c_read_valid && io_c_address == 4'hC)?          { general_vsync, general_hsync, general_not_impl_odd_even_page, 1'b0, general_not_impl_clock_select, general_enable_ram, general_io_space } : //misc output reg
+                 (io_c_read_valid && io_c_address == 4'h2)?          { 3'b0, 1'b1, 4'b0 } : //input status 0
+                 ((io_b_read_valid && io_b_address == 4'hA) || (io_d_read_valid && io_d_address == 4'hA))?
+                             { 4'b0, host_io_vertical_retrace, 2'b0, host_io_not_displaying } : //input status 1
+                 (io_c_read_valid && io_c_address == 4'h0 && attrib_flip_flop)?
+                             8'h00 : //attrib index in write mode
+                 (io_c_read_valid && io_c_address == 4'h0)?          { 2'b0, attrib_video_enable, attrib_io_index } : //attrib in address mode
+                 (io_c_read_valid && io_c_address == 4'h1)?          host_io_read_attrib : //attrib read
+                 (io_c_read_valid && io_c_address == 4'h4)?          { 5'd0, seq_io_index } : //seq index
+                 (io_c_read_valid && io_c_address == 4'h5)?          host_io_read_seq : //seq data
+                 (io_c_read_valid && io_c_address == 4'h6)?          dac_mask : //pel mask
+                 (io_c_read_valid && io_c_address == 4'h7)?          { 6'd0, dac_is_read? 2'b11 : 2'b00 } : //dac state
+                 (io_c_read_valid && io_c_address == 4'h8)?          dac_write_index :
+                 (io_c_read_valid && io_c_address == 4'hE)?          { 4'd0, graph_io_index } :
+                 (io_c_read_valid && io_c_address == 4'hF)?          host_io_read_graph :
+                 (io_d_read_valid && io_d_address == 4'h4)?          { 3'b0, crtc_io_index } :
+                 ((io_b_read_valid && io_b_address == 4'h5) || (io_d_read_valid && io_d_address == 4'h5))?
+                             host_io_read_crtc :
+                 (io_b_read_valid || io_d_read_valid)?               8'hFF :
+                             8'h00; // 6'h1A (Feature Control Register)
+
+   always @(posedge clk_sys) begin if(rst) host_io_read_reg <= 8'd0; else host_io_read_reg <= host_io_read_wire; end
+
+
+   assign io_c_readdata =
+             (host_io_read_address_last == 4'h1 && attrib_io_index <= 5'hF)?     { 2'b0, host_palette_q } :
+             (host_io_read_address_last == 4'h9 && ~(dac_is_read))?              8'h3F :
+             (host_io_read_address_last == 4'h9 && dac_cnt == 2'd1)?             { 2'b0, dac_read_q[17:12] } :
+             (host_io_read_address_last == 4'h9 && dac_cnt == 2'd2)?             { 2'b0, dac_read_q[11:6] } :
+             (host_io_read_address_last == 4'h9 && dac_cnt == 2'd0)?             { 2'b0, dac_read_q[5:0] } :
+                         host_io_read_reg;
+
+   assign io_b_readdata = host_io_read_reg;
+   assign io_d_readdata = host_io_read_reg;
+
+   //------------------------------------------------------------------------------
+
+   //------------------------------------------------------------------------------
+
+   assign host_memory_out_of_bounds =
+                     (graph_system_memory == 2'd1 && mem_address > 17'h0FFFF) ||
+                     (graph_system_memory == 2'd2 && (mem_address < 17'h10000 || mem_address > 17'h17FFF)) ||
+                     (graph_system_memory == 2'd3 && mem_address < 17'h17FFF);
+
+   assign host_address_reduced =
+                (graph_system_memory == 2'd1)?  { 1'b0, mem_address[15:0] } :
+                (graph_system_memory == 2'd2)?  { 2'b0, mem_address[14:0] } :
+                (graph_system_memory == 2'd3)?  { 2'b0, mem_address[14:0] } :
+                                mem_address;
+
+   assign host_address =
+            (seq_access_chain4)?                { host_address_reduced[15:2], 2'b00 } :
+            (~(seq_access_odd_even_disabled))?  { host_address_reduced[15:1], 1'b0 } :
+                        host_address_reduced[15:0];
+
+   //------------------------------------------------------------------------------ mem read
+
+
+
+   always @(posedge clk_sys) begin
+      if(rst)                                       host_read_out_of_bounds <= 1'b0;
+      else if(mem_read_valid && host_memory_out_of_bounds)    host_read_out_of_bounds <= 1'b1;
+      else                                                    host_read_out_of_bounds <= 1'b0;
+   end
+
+   always @(posedge clk_sys) begin
+      if(rst)       host_address_reduced_last <= 17'd0;
+      else if(mem_read_valid) host_address_reduced_last <= host_address_reduced;
+   end
+
+   always @(posedge clk_sys) begin
+      if(rst)   host_read_last <= 1'd0;
+      else                host_read_last <= mem_read_valid && ~(host_memory_out_of_bounds);
+   end
+
+   assign host_read_mode_1 = {
+                  (graph_color_compare_dont_care[0]? ~(host_ram0_q[7] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[7] ^ graph_color_compare_map[1]) : 1'b1) &
+                  (graph_color_compare_dont_care[2]? ~(host_ram2_q[7] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[7] ^ graph_color_compare_map[3]) : 1'b1),
+                  (graph_color_compare_dont_care[0]? ~(host_ram0_q[6] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[6] ^ graph_color_compare_map[1]) : 1'b1) &
+                  (graph_color_compare_dont_care[2]? ~(host_ram2_q[6] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[6] ^ graph_color_compare_map[3]) : 1'b1),
+                  (graph_color_compare_dont_care[0]? ~(host_ram0_q[5] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[5] ^ graph_color_compare_map[1]) : 1'b1) &
+                  (graph_color_compare_dont_care[2]? ~(host_ram2_q[5] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[5] ^ graph_color_compare_map[3]) : 1'b1),
+                  (graph_color_compare_dont_care[0]? ~(host_ram0_q[4] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[4] ^ graph_color_compare_map[1]) : 1'b1) &
+                  (graph_color_compare_dont_care[2]? ~(host_ram2_q[4] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[4] ^ graph_color_compare_map[3]) : 1'b1),
+                  (graph_color_compare_dont_care[0]? ~(host_ram0_q[3] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[3] ^ graph_color_compare_map[1]) : 1'b1) &
+                  (graph_color_compare_dont_care[2]? ~(host_ram2_q[3] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[3] ^ graph_color_compare_map[3]) : 1'b1),
+                  (graph_color_compare_dont_care[0]? ~(host_ram0_q[2] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[2] ^ graph_color_compare_map[1]) : 1'b1) &
+                  (graph_color_compare_dont_care[2]? ~(host_ram2_q[2] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[2] ^ graph_color_compare_map[3]) : 1'b1),
+                  (graph_color_compare_dont_care[0]? ~(host_ram0_q[1] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[1] ^ graph_color_compare_map[1]) : 1'b1) &
+                  (graph_color_compare_dont_care[2]? ~(host_ram2_q[1] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[1] ^ graph_color_compare_map[3]) : 1'b1),
+                  (graph_color_compare_dont_care[0]? ~(host_ram0_q[0] ^ graph_color_compare_map[0]) : 1'b1) & (graph_color_compare_dont_care[1]? ~(host_ram1_q[0] ^ graph_color_compare_map[1]) : 1'b1) &
+                  (graph_color_compare_dont_care[2]? ~(host_ram2_q[0] ^ graph_color_compare_map[2]) : 1'b1) & (graph_color_compare_dont_care[3]? ~(host_ram3_q[0] ^ graph_color_compare_map[3]) : 1'b1)
+                  };
+
+   assign mem_readdata =
+            (host_read_out_of_bounds)?                                                                              8'hFF :
+            (seq_access_chain4 && host_address_reduced_last[1:0] == 2'b00)?                                         host_ram0_q :
+            (seq_access_chain4 && host_address_reduced_last[1:0] == 2'b01)?                                         host_ram1_q :
+            (seq_access_chain4 && host_address_reduced_last[1:0] == 2'b10)?                                         host_ram2_q :
+            (seq_access_chain4 && host_address_reduced_last[1:0] == 2'b11)?                                         host_ram3_q :
+            (graph_read_mode == 1'b0 && ~(seq_access_odd_even_disabled) && host_address_reduced_last[0] == 1'b0)?   host_ram0_q :
+            (graph_read_mode == 1'b0 && ~(seq_access_odd_even_disabled) && host_address_reduced_last[0] == 1'b1)?   host_ram1_q :
+            (graph_read_mode == 1'b0 && graph_read_map_select == 2'd0)?                                             host_ram0_q :
+            (graph_read_mode == 1'b0 && graph_read_map_select == 2'd1)?                                             host_ram1_q :
+            (graph_read_mode == 1'b0 && graph_read_map_select == 2'd2)?                                             host_ram2_q :
+            (graph_read_mode == 1'b0 && graph_read_map_select == 2'd3)?                                             host_ram3_q :
+                        host_read_mode_1;
+
+   always @(posedge clk_sys) begin if(rst) host_ram0_reg <= 8'd0; else if(host_read_last) host_ram0_reg <= host_ram0_q; end
+   always @(posedge clk_sys) begin if(rst) host_ram1_reg <= 8'd0; else if(host_read_last) host_ram1_reg <= host_ram1_q; end
+   always @(posedge clk_sys) begin if(rst) host_ram2_reg <= 8'd0; else if(host_read_last) host_ram2_reg <= host_ram2_q; end
+   always @(posedge clk_sys) begin if(rst) host_ram3_reg <= 8'd0; else if(host_read_last) host_ram3_reg <= host_ram3_q; end
+
+
+   //------------------------------------------------------------------------------ mem write
+
+   assign host_write = mem_write && ~(host_memory_out_of_bounds);
+
+   assign host_writedata_rotate =
+                 (graph_write_rotate == 3'd0)?     mem_writedata[7:0] :
+                 (graph_write_rotate == 3'd1)?   { mem_writedata[0],   mem_writedata[7:1] } :
+                 (graph_write_rotate == 3'd2)?   { mem_writedata[1:0], mem_writedata[7:2] } :
+                 (graph_write_rotate == 3'd3)?   { mem_writedata[2:0], mem_writedata[7:3] } :
+                 (graph_write_rotate == 3'd4)?   { mem_writedata[3:0], mem_writedata[7:4] } :
+                 (graph_write_rotate == 3'd5)?   { mem_writedata[4:0], mem_writedata[7:5] } :
+                 (graph_write_rotate == 3'd6)?   { mem_writedata[5:0], mem_writedata[7:6] } :
+                                 { mem_writedata[6:0], mem_writedata[7] };
+
+   assign host_write_set_0 = (graph_write_mode == 2'd2)? {8{mem_writedata[0]}} : graph_write_enable_map[0]?  {8{graph_write_set_map[0]}} : host_writedata_rotate;
+   assign host_write_set_1 = (graph_write_mode == 2'd2)? {8{mem_writedata[1]}} : graph_write_enable_map[1]?  {8{graph_write_set_map[1]}} : host_writedata_rotate;
+   assign host_write_set_2 = (graph_write_mode == 2'd2)? {8{mem_writedata[2]}} : graph_write_enable_map[2]?  {8{graph_write_set_map[2]}} : host_writedata_rotate;
+   assign host_write_set_3 = (graph_write_mode == 2'd2)? {8{mem_writedata[3]}} : graph_write_enable_map[3]?  {8{graph_write_set_map[3]}} : host_writedata_rotate;
+
+   assign host_write_function =
+                   (graph_write_function == 2'd1)? { host_write_set_3, host_write_set_2, host_write_set_1, host_write_set_0 } & { host_ram3_reg, host_ram2_reg, host_ram1_reg, host_ram0_reg } :
+                   (graph_write_function == 2'd2)? { host_write_set_3, host_write_set_2, host_write_set_1, host_write_set_0 } | { host_ram3_reg, host_ram2_reg, host_ram1_reg, host_ram0_reg } :
+                   (graph_write_function == 2'd3)? { host_write_set_3, host_write_set_2, host_write_set_1, host_write_set_0 } ^ { host_ram3_reg, host_ram2_reg, host_ram1_reg, host_ram0_reg } :
+                               { host_write_set_3, host_write_set_2, host_write_set_1, host_write_set_0 };
+
+   assign host_write_mask_0 = (graph_write_mask & host_write_function[7:0])   | (~(graph_write_mask) & host_ram0_reg);
+   assign host_write_mask_1 = (graph_write_mask & host_write_function[15:8])  | (~(graph_write_mask) & host_ram1_reg);
+   assign host_write_mask_2 = (graph_write_mask & host_write_function[23:16]) | (~(graph_write_mask) & host_ram2_reg);
+   assign host_write_mask_3 = (graph_write_mask & host_write_function[31:24]) | (~(graph_write_mask) & host_ram3_reg);
+
+   assign host_write_mode_3_mask = host_writedata_rotate & graph_write_mask;
+   assign host_write_mode_3_ram0 = (host_write_mode_3_mask & {8{graph_write_set_map[0]}})   | (~(host_write_mode_3_mask) & host_ram0_reg);
+   assign host_write_mode_3_ram1 = (host_write_mode_3_mask & {8{graph_write_set_map[1]}})   | (~(host_write_mode_3_mask) & host_ram1_reg);
+   assign host_write_mode_3_ram2 = (host_write_mode_3_mask & {8{graph_write_set_map[2]}})   | (~(host_write_mode_3_mask) & host_ram2_reg);
+   assign host_write_mode_3_ram3 = (host_write_mode_3_mask & {8{graph_write_set_map[3]}})   | (~(host_write_mode_3_mask) & host_ram3_reg);
+
+   assign host_writedata =
+              (graph_write_mode == 2'd0 || graph_write_mode == 2'd2)?     { host_write_mask_3, host_write_mask_2, host_write_mask_1, host_write_mask_0 } :
+              (graph_write_mode == 2'd1)?                                 { host_ram3_reg, host_ram2_reg, host_ram1_reg, host_ram0_reg } :
+                          { host_write_mode_3_ram3, host_write_mode_3_ram2, host_write_mode_3_ram1, host_write_mode_3_ram0 };
+
+   assign host_write_enable_for_chain4 =
+                    (host_address_reduced[1:0] == 2'd0)?    4'b0001 :
+                    (host_address_reduced[1:0] == 2'd1)?    4'b0010 :
+                    (host_address_reduced[1:0] == 2'd2)?    4'b0100 :
+                                        4'b1000;
+   assign host_write_enable_for_odd_even =
+                      (host_address_reduced[0] == 1'd0)?      4'b0101 :
+                                          4'b1010;
+
+   assign host_write_enable =
+                  {4{host_write}} & seq_map_write_enable & (
+                                    (seq_access_chain4)?                host_write_enable_for_chain4 :
+                                    (~(seq_access_odd_even_disabled))?  host_write_enable_for_odd_even :
+                                    4'b1111);
+
+   //------------------------------------------------------------------------------
+
+
+   assign memory_address_load = dot_memory_load_first_in_frame || dot_memory_load_first_in_line_matched || dot_memory_load_first_in_line;
+
+   always @(posedge clk_26) begin
+      if(rst)               memory_start_line <= 16'd0;
+      else if(memory_address_load)    memory_start_line <= memory_address;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)                               memory_address_reg <= 16'd0;
+      else if(memory_address_load || dot_memory_load) memory_address_reg <= memory_address;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)               memory_row_scan_reg <= 5'd0;
+      else if(memory_address_load)    memory_row_scan_reg <= memory_row_scan;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)                                                                                               memory_row_scan_double <= 1'b0;
+      else if(crtc_vertical_doublescan && (dot_memory_load_first_in_frame || dot_memory_load_first_in_line_matched))  memory_row_scan_double <= 1'b1;
+      else if(crtc_vertical_doublescan && dot_memory_load_first_in_line)                                              memory_row_scan_double <= ~memory_row_scan_double;
+      else if(~(crtc_vertical_doublescan) || dot_memory_load_vertical_retrace_start)                                  memory_row_scan_double <= 1'b0;
+   end
+
+   //do not change charmap in the middle of a character row scan
+   always @(posedge clk_26) begin
+      if(rst)                                                                                                                               memory_char_map_a <= 3'd0;
+      else if(dot_memory_load_first_in_frame || dot_memory_load_first_in_line_matched || (dot_memory_load_first_in_line && memory_row_scan == 5'd0))  memory_char_map_a <= seq_char_map_a;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)                                                                                                                               memory_char_map_b <= 3'd0;
+      else if(dot_memory_load_first_in_frame || dot_memory_load_first_in_line_matched || (dot_memory_load_first_in_line && memory_row_scan == 5'd0))  memory_char_map_b <= seq_char_map_b;
+   end
+
+
+   always @(posedge clk_26) begin
+      if(rst)                                                                       memory_panning_reg <= 4'd0;
+      else if(dot_memory_load_first_in_line_matched && attrib_panning_after_compare_match)    memory_panning_reg <= 4'd0;
+      else if(dot_memory_load_first_in_frame)                                                 memory_panning_reg <= attrib_panning_value;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           memory_load_step_a <= 1'b0;
+      else if(dot_memory_load)    memory_load_step_a <= 1'b1;
+      else                        memory_load_step_a <= 1'b0;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           memory_load_step_b <= 1'b0;
+      else if(memory_load_step_a) memory_load_step_b <= 1'b1;
+      else                        memory_load_step_b <= 1'b0;
+   end
+
+   assign memory_address =
+              (dot_memory_load_first_in_line_matched)?                                    16'd0 :
+              (dot_memory_load_first_in_frame)?                                           crtc_address_start + { 14'd0, crtc_address_byte_panning } :
+              (dot_memory_load_first_in_line && memory_row_scan_double)?                  memory_start_line :
+              (dot_memory_load_first_in_line && memory_row_scan_reg < crtc_row_max)?      memory_start_line :
+              (dot_memory_load_first_in_line)?                                            memory_start_line + { 7'd0, crtc_address_offset[7:0], 1'b0 } :
+              (dot_memory_load)?                                                          memory_address_reg + 16'd1 :
+                          memory_address_reg;
+
+   assign memory_row_scan =
+               (dot_memory_load_first_in_line_matched)?                                5'd0 :
+               (dot_memory_load_first_in_frame && crtc_row_preset <= crtc_row_max)?    crtc_row_preset :
+               (dot_memory_load_first_in_frame)?                                       5'd0 :
+               (dot_memory_load_first_in_line && memory_row_scan_double)?              memory_row_scan_reg :
+               (dot_memory_load_first_in_line && memory_row_scan_reg == crtc_row_max)? 5'd0 :
+               (dot_memory_load_first_in_line)?                                        memory_row_scan_reg + 5'd1 :
+                           memory_row_scan_reg;
+
+   assign memory_address_step_1 =
+                 (crtc_address_doubleword)?  { memory_address[13:0], memory_address[15:14] } :
+                 (crtc_address_byte)?        memory_address :
+                 (crtc_address_bit0)?        { memory_address[14:0], memory_address[15] } :
+                                 { memory_address[14:0], memory_address[13] };
+
+   assign memory_address_step_2 = {
+                   memory_address_step_1[15],
+                   (crtc_address_bit14)?           memory_address_step_1[14] : memory_row_scan[1],
+                   (crtc_address_bit13)?           memory_address_step_1[13] : memory_row_scan[0],
+                   memory_address_step_1[12:0]
+                   };
+
+   always @(posedge clk_26) begin
+      if(rst)           memory_address_reg_final <= 16'd0;
+      else if(dot_memory_load)    memory_address_reg_final <= memory_address;
+   end
+
+   assign memory_txt_index = plane_ram1_q[3]? memory_char_map_a : memory_char_map_b;
+
+   assign memory_txt_address_base =
+                   ((~(seq_access_256kb) && memory_txt_index[2] == 1'b0) || memory_txt_index == 3'b000)?   16'h0000 :
+                   ((~(seq_access_256kb) && memory_txt_index[2] == 1'b1) || memory_txt_index == 3'b100)?   16'h2000 :
+                   (memory_txt_index == 3'b001)?                                                           16'h4000 :
+                   (memory_txt_index == 3'b101)?                                                           16'h6000 :
+                   (memory_txt_index == 3'b010)?                                                           16'h8000 :
+                   (memory_txt_index == 3'b110)?                                                           16'hA000 :
+                   (memory_txt_index == 3'b011)?                                                           16'hC000 :
+                                   16'hE000;
+
+   assign memory_txt_address = { memory_txt_address_base[15:13], plane_ram0_q[7:0], memory_row_scan_reg };
+
+   //------------------------------------------------------------------------------
+
+
+
+   simple_biclk_bidir_ram #(
+                .widthad    (16),
+                .width      (8)
+                )
+   plane_ram_inst0(
+           .clk            (clk_sys),
+
+           .address_a      (host_address),
+           .data_a         (host_writedata[7:0]),
+           .wren_a         (general_enable_ram && host_write_enable[0]),
+           .q_a            (host_ram0_q),
+
+           .clk2           (clk_26),
+           .address_b      (memory_address_step_2),
+           .q_b            (plane_ram0_q)
+           );
+
+   simple_biclk_bidir_ram #(
+                .widthad    (16),
+                .width      (8)
+                )
+   plane_ram_inst1(
+           .clk            (clk_sys),
+
+           .address_a      (host_address),
+           .data_a         (host_writedata[15:8]),
+           .wren_a         (general_enable_ram && host_write_enable[1]),
+           .q_a            (host_ram1_q),
+
+           .clk2           (clk_26),
+           .address_b      (memory_address_step_2),
+           .q_b            (plane_ram1_q)
+           );
+
+   simple_biclk_bidir_ram #(
+                .widthad    (16),
+                .width      (8)
+                )
+   plane_ram_inst2(
+           .clk            (clk_sys),
+
+           .address_a      (host_address),
+           .data_a         (host_writedata[23:16]),
+           .wren_a         (general_enable_ram && host_write_enable[2]),
+           .q_a            (host_ram2_q),
+
+           .clk2           (clk_26),
+           .address_b      (memory_load_step_a? memory_txt_address : memory_address_step_2),
+           .q_b            (plane_ram2_q)
+           );
+
+   simple_biclk_bidir_ram #(
+                .widthad    (16),
+                .width      (8)
+                )
+   plane_ram_inst3(
+           .clk            (clk_sys),
+
+           .address_a      (host_address),
+           .data_a         (host_writedata[31:24]),
+           .wren_a         (general_enable_ram && host_write_enable[3]),
+           .q_a            (host_ram3_q),
+
+           .clk2           (clk_26),
+           .address_b      (memory_address_step_2),
+           .q_b            (plane_ram3_q)
+           );
+
+   //------------------------------------------------------------------------------
+
+
+   always @(posedge clk_26) begin if(rst) plane_ram0 <= 8'd0; else if(memory_load_step_a) plane_ram0 <= plane_ram0_q; end
+   always @(posedge clk_26) begin if(rst) plane_ram1 <= 8'd0; else if(memory_load_step_a) plane_ram1 <= plane_ram1_q; end
+   always @(posedge clk_26) begin if(rst) plane_ram2 <= 8'd0; else if(memory_load_step_a) plane_ram2 <= plane_ram2_q; end
+   always @(posedge clk_26) begin if(rst) plane_ram3 <= 8'd0; else if(memory_load_step_a) plane_ram3 <= plane_ram3_q; end
+
+   //------------------------------------------------------------------------------
+
+   always @(posedge clk_26) begin
+      if(rst)                   plane_shift_cnt <= 6'd0;
+      else if(memory_load_step_b)         plane_shift_cnt <= 6'd1;
+      else if(plane_shift_cnt == 6'd34)   plane_shift_cnt <= 6'd0;
+      else if(plane_shift_cnt != 6'd0)    plane_shift_cnt <= plane_shift_cnt + 6'd1;
+   end
+
+   assign plane_shift_enable =
+                   (~(seq_dotclock_divided) && plane_shift_cnt >= 6'd1) ||
+                   (  seq_dotclock_divided  && plane_shift_cnt >= 6'd1 && plane_shift_cnt[0]);
+
+   assign plane_shift_9dot =
+                ~(seq_8dot_char) && plane_shift_enable &&
+                (~(seq_dotclock_divided) && plane_shift_cnt == 6'd9) ||
+                (  seq_dotclock_divided  && plane_shift_cnt == 6'd17);
+
+   //------------------------------------------------------------------------------
+
+
+   assign plane_shift_value0 =
+                  (graph_shift_mode == 2'b00)?    plane_ram0 :
+                  (graph_shift_mode == 2'b01)?    { plane_ram0[6],plane_ram0[4],plane_ram0[2],plane_ram0[0], plane_ram1[6],plane_ram1[4],plane_ram1[2],plane_ram1[0] } :
+                              { plane_ram0[4],plane_ram0[0],plane_ram1[4],plane_ram1[0], plane_ram2[4],plane_ram2[0],plane_ram3[4],plane_ram3[0] };
+
+   assign plane_shift_value1 =
+                  (graph_shift_mode == 2'b00)?    plane_ram1 :
+                  (graph_shift_mode == 2'b01)?    { plane_ram0[7],plane_ram0[5],plane_ram0[3],plane_ram0[1], plane_ram1[7],plane_ram1[5],plane_ram1[3],plane_ram1[1] } :
+                              { plane_ram0[5],plane_ram0[1],plane_ram1[5],plane_ram1[1], plane_ram2[5],plane_ram2[1],plane_ram3[5],plane_ram3[1] };
+
+   assign plane_shift_value2 =
+                  (graph_shift_mode == 2'b00)?    plane_ram2 :
+                  (graph_shift_mode == 2'b01)?    { plane_ram2[6],plane_ram2[4],plane_ram2[2],plane_ram2[0], plane_ram3[6],plane_ram3[4],plane_ram3[2],plane_ram3[0] } :
+                              { plane_ram0[6],plane_ram0[2],plane_ram1[6],plane_ram1[2], plane_ram2[6],plane_ram2[2],plane_ram3[6],plane_ram3[2] };
+
+   assign plane_shift_value3 =
+                  (graph_shift_mode == 2'b00)?    plane_ram3 :
+                  (graph_shift_mode == 2'b01)?    { plane_ram2[7],plane_ram2[5],plane_ram2[3],plane_ram2[1], plane_ram3[7],plane_ram3[5],plane_ram3[3],plane_ram3[1] } :
+                              { plane_ram0[7],plane_ram0[3],plane_ram1[7],plane_ram1[3], plane_ram2[7],plane_ram2[3],plane_ram3[7],plane_ram3[3] };
+
+   always @(posedge clk_26) begin
+      if(rst)           plane_shift0 <= 8'd0;
+      else if(memory_load_step_b) plane_shift0 <= plane_shift_value0;
+      else if(plane_shift_enable) plane_shift0 <= { plane_shift0[6:0], 1'b0 };
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           plane_shift1 <= 8'd0;
+      else if(memory_load_step_b) plane_shift1 <= plane_shift_value1;
+      else if(plane_shift_enable) plane_shift1 <= { plane_shift1[6:0], 1'b0 };
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           plane_shift2 <= 8'd0;
+      else if(memory_load_step_b) plane_shift2 <= plane_shift_value2;
+      else if(plane_shift_enable) plane_shift2 <= { plane_shift2[6:0], 1'b0 };
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           plane_shift3 <= 8'd0;
+      else if(memory_load_step_b) plane_shift3 <= plane_shift_value3;
+      else if(plane_shift_enable) plane_shift3 <= { plane_shift3[6:0], 1'b0 };
+   end
+
+   //------------------------------------------------------------------------------
+
+
+
+   assign txt_blink_enabled = attrib_blinking && plane_ram1[7] && blink_txt_value;
+
+   assign txt_underline_enable = plane_ram1[2:0] == 3'b001 && plane_ram1[6:4] == 3'b000 && crtc_row_underline > 5'd0 && crtc_row_underline - 5'd1 == memory_row_scan_reg;
+
+   assign txt_cursor_enable =
+                 ~(crtc_cursor_off) &&
+                 blink_cursor_value &&
+                 memory_address_reg_final == crtc_address_cursor + { 14'd0, crtc_cursor_skew } &&
+                 memory_row_scan_reg >= crtc_cursor_row_start &&
+                 memory_row_scan_reg <= crtc_cursor_row_end &&
+                 crtc_cursor_row_start <= crtc_cursor_row_end;
+
+   assign plane_txt_shift_value =
+                 (txt_blink_enabled)?        8'd0 :
+                 (txt_underline_enable)?     8'hFF :
+                 (txt_cursor_enable)?        8'hFF :
+                                 plane_ram2_q;
+
+   always @(posedge clk_26) begin
+      if(rst)           plane_txt_shift <= 8'd0;
+      else if(memory_load_step_b) plane_txt_shift <= plane_txt_shift_value;
+      else if(plane_shift_enable) plane_txt_shift <= { plane_txt_shift[6:0], 1'b0 };
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           txt_foreground <= 4'd0;
+      else if(memory_load_step_b) txt_foreground <= plane_ram1[3:0];
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           txt_background <= 4'd0;
+      else if(memory_load_step_b) txt_background <= (attrib_blinking)? { 1'b0, plane_ram1[6:4] } : plane_ram1[7:4];
+   end
+
+   assign txt_line_graphic_char = plane_ram0 >= 8'hB0 && plane_ram0 <= 8'hDF;
+
+   //------------------------------------------------------------------------------
+
+   assign pel_input =
+             (plane_shift_9dot && attrib_9bit_same_as_8bit && pel_line_graphic_char)?   pel_input_last :
+             (plane_shift_9dot)?                                                        pel_background :
+
+             (attrib_graphic_mode)?  { plane_shift3[7], plane_shift2[7], plane_shift1[7], plane_shift0[7] } :
+             (plane_txt_shift[7])?   txt_foreground :
+                     txt_background;
+
+   always @(posedge clk_26) begin
+      if(rst)           pel_input_last <= 4'd0;
+      else if(plane_shift_enable) pel_input_last <= pel_input;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           pel_line_graphic_char <= 1'b0;
+      else if(plane_shift_enable) pel_line_graphic_char <= txt_line_graphic_char;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           pel_background <= 4'd0;
+      else if(plane_shift_enable) pel_background <= txt_background;
+   end
+
+   //------------------------------------------------------------------------------
+
+   assign pel_after_enable = attrib_mask & pel_input;
+
+   //APA blinking logic (undocumented)
+   assign pel_after_blink =
+               (attrib_graphic_mode && attrib_blinking && blink_txt_value)?    { 1'b1, pel_after_enable[2:0] } :
+               (attrib_graphic_mode && attrib_blinking)?                       pel_after_enable ^ 4'b1000 :
+                           pel_after_enable;
+
+   always @(posedge clk_26) begin
+      if(rst)           pel_shift_reg <= 36'd0;
+      else if(plane_shift_enable) pel_shift_reg <= { pel_after_blink, pel_shift_reg[35:4] };
+   end
+
+   assign pel_after_panning =
+                 (memory_panning_reg == 4'd0)?     pel_shift_reg[11:4] :
+                 (memory_panning_reg == 4'd1)?     pel_shift_reg[15:8] :
+                 (memory_panning_reg == 4'd2)?     pel_shift_reg[19:12] :
+                 (memory_panning_reg == 4'd3)?     pel_shift_reg[23:16] :
+                 (memory_panning_reg == 4'd4)?     pel_shift_reg[27:20] :
+                 (memory_panning_reg == 4'd5)?     pel_shift_reg[31:24] :
+                 (memory_panning_reg == 4'd6)?     pel_shift_reg[35:28] :
+                 (memory_panning_reg == 4'd7)?     { 4'd0, pel_shift_reg[35:32] } :
+                             pel_shift_reg[7:0];
+
+   always @(posedge clk_26) begin if(rst) plane_shift_enable_last <= 1'b0; else plane_shift_enable_last <= plane_shift_enable; end
+
+   always @(posedge clk_26) begin
+      if(rst)                                               pel_color_8bit_cnt <= 1'b0;
+      else if(plane_shift_enable && plane_shift_enable_last == 1'b0)  pel_color_8bit_cnt <= 1'b1;
+      else                                                            pel_color_8bit_cnt <= ~pel_color_8bit_cnt;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)                   pel_color_8bit_buffer <= 8'd0;
+      else if(pel_color_8bit_cnt == 1'b0) pel_color_8bit_buffer <= pel_after_panning;
+   end
+   //------------------------------------------------------------------------------
+
+
+   simple_biclk_bidir_ram #(
+                .widthad    (4),
+                .width      (6)
+                )
+   internal_palette_ram_inst(
+                 .clk            (clk_sys),
+
+                 .address_a      (attrib_io_index[3:0]),
+                 .data_a         (io_c_writedata[5:0]),
+                 .wren_a         (attrib_io_write && attrib_io_index < 5'h10),
+                 .q_a            (host_palette_q),
+
+                 .clk2           (clk_26),
+                 .address_b      (pel_after_panning[3:0]),
+                 .q_b            (pel_palette)
+                 );
+
+   assign pel_palette_index = {
+                   attrib_color_bit7_6_value,
+                   (attrib_color_bit5_4_enable)? attrib_color_bit5_4_value : pel_palette[5:4],
+                   pel_palette[3:0]
+                   };
+
+
+   assign pel_index =
+             (vgaprep_overscan)?             attrib_color_overscan :
+             (~(attrib_video_enable))?       8'h00 :
+             (attrib_color_8bit_enable)?     { pel_color_8bit_buffer[3:0], pel_color_8bit_buffer[7:4] } :
+                     pel_palette_index;
+
+   //------------------------------------------------------------------------------
+
+
+   simple_biclk_bidir_ram #(
+                .widthad    (8),
+                .width      (18)
+                )
+   dac_ram_inst(
+        .clk            (clk_sys),
+
+        .address_a      (dac_is_read? dac_read_index : dac_write_index),
+        .data_a         ({ dac_write_buffer, io_c_writedata[5:0] }),
+        .wren_a         (io_c_write && io_c_address == 4'h9 && dac_cnt == 2'd2),
+        .q_a            (dac_read_q),
+
+        .clk2           (clk_26),
+        .address_b      (pel_index),
+        .q_b            (dac_color)
+        );
+
+   //------------------------------------------------------------------------------
+   assign character_last_dot = dot_cnt_enable && ((dot_cnt == 4'd8 && ~(seq_8dot_char)) || (dot_cnt == 4'd7 && seq_8dot_char));
+   assign line_last_dot = horiz_cnt == crtc_horizontal_total + 8'd4 && character_last_dot;
+   assign screen_last_dot = vert_cnt == crtc_vertical_total - 10'd1   && line_last_dot;
+
+
+   always @(posedge clk_26) begin
+      if(rst)   dot_cnt_div <= 1'b0;
+      else                dot_cnt_div <= ~(dot_cnt_div);
+   end
+
+   assign dot_cnt_enable = ~(seq_dotclock_divided) || dot_cnt_div;
+
+   always @(posedge clk_26) begin
+      if(rst)                               dot_cnt <= 4'd0;
+      else if(dot_cnt_enable && character_last_dot)   dot_cnt <= 4'd0;
+      else if(dot_cnt_enable)                         dot_cnt <= dot_cnt + 4'd1;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           horiz_cnt <= 8'd0;
+      else if(line_last_dot)      horiz_cnt <= 8'd0;
+      else if(character_last_dot) horiz_cnt <= horiz_cnt + 8'd1;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           vert_cnt <= 10'd0;
+      else if(screen_last_dot)    vert_cnt <= 10'd0;
+      else if(line_last_dot)      vert_cnt <= vert_cnt + 10'd1;
+   end
+
+   assign dot_memory_load =
+                (   (seq_8dot_char    && ~(seq_dotclock_divided) && dot_cnt_enable    && dot_cnt == 4'd3) ||
+                (seq_8dot_char    && seq_dotclock_divided    && ~(dot_cnt_enable) && dot_cnt == 4'd6) ||
+                (~(seq_8dot_char) && ~(seq_dotclock_divided) && dot_cnt_enable    && dot_cnt == 4'd4) ||
+                (~(seq_8dot_char) && seq_dotclock_divided    && ~(dot_cnt_enable) && dot_cnt == 4'd7)
+                ) &&
+                (   (vert_cnt == crtc_vertical_total - 10'd1 && horiz_cnt >= crtc_horizontal_total + 8'd3) ||
+                (vert_cnt < crtc_vertical_display_size && (horiz_cnt <= crtc_horizontal_display_size - 8'd2 || horiz_cnt >= crtc_horizontal_total + 8'd3)) ||
+                (vert_cnt == crtc_vertical_display_size && horiz_cnt <= crtc_horizontal_display_size - 8'd2)
+                );
+
+   assign dot_memory_load_first_in_frame = dot_memory_load && vert_cnt == crtc_vertical_total - 10'd1 && horiz_cnt == crtc_horizontal_total + 8'd3;
+   assign dot_memory_load_first_in_line  = dot_memory_load && horiz_cnt == crtc_horizontal_total + 8'd3;
+   assign dot_memory_load_first_in_line_matched =
+                         dot_memory_load_first_in_line && (
+                                           (crtc_line_compare > 10'd0 && vert_cnt == crtc_line_compare - 10'd1) ||
+                                           (crtc_line_compare == 10'd0 && vert_cnt == crtc_vertical_total - 10'd1));
+
+   assign dot_memory_load_vertical_retrace_start = vert_cnt == crtc_vertical_retrace_start;
+
+   //------------------------------------------------------------------------------
+
+   always @(posedge clk_26) begin
+      if(rst)   host_io_vertical_retrace_last <= 1'b0;
+      else                host_io_vertical_retrace_last <= host_io_vertical_retrace;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)           blink_cnt <= 6'd0;
+      else if(host_io_vertical_retrace_last == 1'b1 && host_io_vertical_retrace == 1'b0) blink_cnt <= blink_cnt + 6'd1;
+   end
+
+   assign blink_txt_value    = blink_cnt[5];
+   assign blink_cursor_value = blink_cnt[4];
+
+   //------------------------------------------------------------------------------
+
+   always @(posedge clk_26) begin
+      if(rst)                                                                                       vgaprep_horiz_blank <= 1'b0;
+      else if(horiz_cnt == crtc_horizontal_blanking_start)                                                    vgaprep_horiz_blank <= 1'b1;
+      else if(horiz_cnt > crtc_horizontal_blanking_start && horiz_cnt[5:0] == crtc_horizontal_blanking_end)   vgaprep_horiz_blank <= 1'b0;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst)                                                                               vgaprep_vert_blank <= 1'b0;
+      else if(vert_cnt == crtc_vertical_blanking_start)                                               vgaprep_vert_blank <= 1'b1;
+      else if(vert_cnt > crtc_vertical_blanking_start && vert_cnt[7:0] == crtc_vertical_blanking_end) vgaprep_vert_blank <= 1'b0;
+   end
+
+   assign vgaprep_blank =
+              seq_screen_disable || ~(seq_sync_reset_n) || ~(seq_async_reset_n) ||
+              //horizontal
+              horiz_cnt == crtc_horizontal_blanking_start || (horiz_cnt > crtc_horizontal_blanking_start && vgaprep_horiz_blank && horiz_cnt[5:0] != crtc_horizontal_blanking_end) ||
+              //line before vertical blank
+              (horiz_cnt >= crtc_horizontal_blanking_start && vert_cnt + 10'd1 == crtc_vertical_blanking_start) ||
+              //last line of vertical blank
+              ((~(vgaprep_vert_blank) || (vert_cnt[7:0] + 8'd1 != crtc_vertical_blanking_end) || horiz_cnt < crtc_horizontal_blanking_start) &&
+               //vertical
+               (vert_cnt == crtc_vertical_blanking_start    || (vert_cnt > crtc_vertical_blanking_start && vgaprep_vert_blank && vert_cnt[7:0] != crtc_vertical_blanking_end)));
+
+   assign vgaprep_horiz_sync =
+                  horiz_cnt == (crtc_horizontal_retrace_start + { 6'd0, crtc_horizontal_retrace_skew }) ||
+                  (horiz_cnt > (crtc_horizontal_retrace_start + { 6'd0, crtc_horizontal_retrace_skew }) && vgareg0_horiz_sync == ~(general_hsync) && horiz_cnt[4:0] != crtc_horizontal_retrace_end);
+
+   assign vgaprep_vert_sync =
+                 vert_cnt == crtc_vertical_retrace_start ||
+                 (vert_cnt > crtc_vertical_retrace_start && vgareg0_vert_sync == ~(general_vsync) && vert_cnt[3:0] != crtc_vertical_retrace_end);
+
+   //one cycle before input to vgareg_*
+   assign vgaprep_overscan =
+                 (horiz_cnt > crtc_horizontal_display_size  && ~(line_last_dot)) ||
+                 (horiz_cnt == crtc_horizontal_display_size && character_last_dot) ||
+                 (vert_cnt > crtc_vertical_display_size     && ~(screen_last_dot)) ||
+                 (vert_cnt == crtc_vertical_display_size    && line_last_dot);
+
+   //------------------------------------------------------------------------------
+
+
+   assign sys_readdata = { 23'd0, sys_readdata_from_ram };
+
+   always @(posedge clk_sys) begin
+      if(rst)                               sys_enabled <= 1'b0;
+      else if(sys_write && sys_writedata[15] == 1'b1) sys_enabled <= sys_writedata[14];
+   end
+
+
+   always @(posedge clk_sys) begin
+      if(rst)                                   sys_horiz_cnt <= 7'd0;
+      else if(sys_horiz_cnt == 7'd0 && horiz_cnt == 8'd1) sys_horiz_cnt <= 7'd1;
+      else if(sys_horiz_cnt > 7'd0)                       sys_horiz_cnt <= sys_horiz_cnt + 7'd1;
+   end
+
+   assign sys_horiz_cnt_plus_4 = sys_horiz_cnt + 7'd2;
+
+
+   simple_biclk_bidir_ram #(
+                .widthad    (8),
+                .width      (9)
+                )
+   vga_system_ram
+     (
+      .clk        (clk_sys),
+
+      .address_a  (sys_address),
+      .wren_a     (sys_write && sys_writedata[15:9] == 7'd0),
+      .data_a     (sys_writedata[8:0]),
+      .q_a        (sys_readdata_from_ram),
+
+      .clk2       (clk_26),
+      .address_b  ({ ((vert_cnt >= 10'd256)? 4'd0 : vert_cnt[7:4]), sys_horiz_cnt_plus_4[6:3] }),
+      .q_b        (sys_character)
+      );
+
+   always @(posedge clk_sys) begin
+      if(rst)   sys_inverted <= 1'b0;
+      else                sys_inverted <= sys_character[8];
+   end
+
+   simple_single_rom #(
+               .widthad    (11),
+               .width      (8)
+               )
+   vga_font_rom_inst (
+              .clk        (clk_26),
+              .addr       ({ sys_character[6:0], vert_cnt[3:0] }),
+              .q          (sys_line)
+              );
+
+   assign sys_pixel =
+             (sys_horiz_cnt[2:0] == 3'd0)? sys_line[0] :
+             (sys_horiz_cnt[2:0] == 3'd1)? sys_line[1] :
+             (sys_horiz_cnt[2:0] == 3'd2)? sys_line[2] :
+             (sys_horiz_cnt[2:0] == 3'd3)? sys_line[3] :
+             (sys_horiz_cnt[2:0] == 3'd4)? sys_line[4] :
+             (sys_horiz_cnt[2:0] == 3'd5)? sys_line[5] :
+             (sys_horiz_cnt[2:0] == 3'd6)? sys_line[6] :
+                     sys_line[7];
+
+   assign sys_pixel_color = (sys_pixel ^ sys_inverted)? 8'd255 : 8'd30;
+
+   //------------------------------------------------------------------------------ by kise
+
+   always @(posedge clk_26) begin
+      if(rst) hcnt <= 0;
+      else hcnt <= (line_last_dot==1) ? 0 : hcnt + 1;
+   end
+   always @(posedge clk_26) begin
+      if(rst) vcnt <= 0;
+      else vcnt <= (line_last_dot==0) ? vcnt : (screen_last_dot) ? 0 : vcnt + 1;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst) hsync <= 0;
+      else hsync <= (hcnt>=656 && hcnt<=751) ? 0 : 1;
+   end
+
+   always @(posedge clk_26) begin
+      if(rst) vsync <= 0;
+      else vsync <= (vcnt>=412 && vcnt<=413) ? 0 : 1;
+   end
+
+   //------------------------------------------------------------------------------ by kise
+
+   assign host_io_vertical_retrace = vgaprep_vert_sync;
+   assign host_io_not_displaying   = vgaprep_blank;
+
+   always @(posedge clk_26) begin if(rst) vgareg_blank_n <= 1'b0; else vgareg_blank_n <= ~(vgaprep_blank); end
+
+   always @(posedge clk_26) begin if(rst) vgareg0_horiz_sync <= 1'b0; else vgareg0_horiz_sync <= (vgaprep_horiz_sync && crtc_enable_sync)? ~(general_hsync) : general_hsync; end
+   always @(posedge clk_26) begin if(rst) vgareg1_horiz_sync <= 1'b0; else vgareg1_horiz_sync <= vgareg0_horiz_sync; end
+
+   always @(posedge clk_26) begin if(rst) vgareg0_vert_sync <= 1'b0; else vgareg0_vert_sync <= (vgaprep_vert_sync && crtc_enable_sync)? ~(general_vsync) : general_vsync; end
+   always @(posedge clk_26) begin if(rst) vgareg1_vert_sync <= 1'b0; else vgareg1_vert_sync <= vgareg0_vert_sync; end
+
+   always @(posedge clk_26) begin
+      if(rst)                                                                           vgareg_r <= 8'b0;
+      else if(sys_enabled && (horiz_cnt == 8'd1 || sys_horiz_cnt > 7'd0) && vert_cnt < 10'd256)   vgareg_r <= sys_pixel_color;
+      else                                                                                        vgareg_r <= { dac_color[17:12], 2'b0 };
+   end
+   always @(posedge clk_26) begin
+      if(rst)                                                                           vgareg_g <= 8'b0;
+      else if(sys_enabled && (horiz_cnt == 8'd1 || sys_horiz_cnt > 7'd0) && vert_cnt < 10'd256)   vgareg_g <= sys_pixel_color;
+      else                                                                                        vgareg_g <= { dac_color[11:6], 2'b0 };
+   end
+   always @(posedge clk_26) begin
+      if(rst)                                                                           vgareg_b <= 8'b0;
+      else if(sys_enabled && (horiz_cnt == 8'd1 || sys_horiz_cnt > 7'd0) && vert_cnt < 10'd256)   vgareg_b <= sys_pixel_color;
+      else                                                                                        vgareg_b <= { dac_color[5:0], 2'b0 };
+   end
+
+   assign vga_clock  = clk_26;
+   assign vga_sync_n = 1'b0;
+
+   assign vga_blank_n    = 1; // vgareg_blank_n;
+   //assign vga_horiz_sync = vgareg1_horiz_sync;
+   //assign vga_vert_sync  = vgareg1_vert_sync;
+
+   assign vga_horiz_sync = hsync; // by Kise
+   assign vga_vert_sync  = vsync; // by Kise
+
+   assign vga_r = (hcnt>=640 || vcnt>=400) ? 0 : vgareg_r; // by Kise
+   assign vga_g = (hcnt>=640 || vcnt>=400) ? 0 : vgareg_g; // by Kise
+   assign vga_b = (hcnt>=640 || vcnt>=400) ? 0 : vgareg_b; // by Kise
+
+   //------------------------------------------------------------------------------
+
+   // synthesis translate_off
+   assign _unused_ok = &{ 1'b0, sys_read, sys_writedata[31:16], host_address_reduced_last[16:2], memory_txt_address_base[12:0], sys_character[7], sys_horiz_cnt_plus_4[2:0], 1'b0 };
+   // synthesis translate_on
+
+   //------------------------------------------------------------------------------
 
 endmodule
